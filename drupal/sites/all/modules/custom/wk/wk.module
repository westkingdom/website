<?php

/**
 * @file
 * West Kingdom customizations
 */


use Symfony\Component\Yaml\Yaml;
use Symfony\Component\Yaml\Dumper;
use HierarchicalGroupEmail\Groups;
use Westkingdom\HierarchicalGroupEmail\ServiceAccountAuthenticator;
use Westkingdom\HierarchicalGroupEmail\StandardGroupPolicy;
use Westkingdom\HierarchicalGroupEmail\GoogleAppsGroupsController;
use Westkingdom\HierarchicalGroupEmail\BatchWrapper;
use Westkingdom\HierarchicalGroupEmail\LegacyGroups;

// Calendar status values (used internally only; not stored in database)

define("CALENDAR_STATUS_CLOSED", "CLOSED");
define("CALENDAR_STATUS_PREPARING", "PREPARING");
define("CALENDAR_STATUS_ONE_EVENT", "ONE_EVENT");
define("CALENDAR_STATUS_TWO_EVENTS", "TWO_EVENTS");
define("CALENDAR_STATUS_ALL_EVENTS_NEXT_YEAR", "ALL_EVENTS");

define("UNLIMITED", 999);

// Some magic numbers.  TODO: move to configuration

define("SOCIETY_TID", 75);
define("KINGDOM_OF_THE_WEST_TID", 2);

define("SENESCHAL_TID", 84);
define("WEBMINISTER_TID", 93);
define("HEIRS_TID", 132);
define("REGENT_TID", 130);

define("KINGDOM_WEBMINISTER_GID", 851);
define("KINGDOM_SENESCHAL_GID", 989);

// DateTime::W3C = "Y-m-d\TH:i:sP"
// These are not quite W3C formats, because they are
// missing the timezone component.
define("W3C_NoTZ", "Y-m-d\TH:i:s");
define("W3C_BeginningOfDay", "Y-m-d\T00:00:00");
define("W3C_Noon", "Y-m-d\T12:00:00");
define("W3C_EndOfDay", "Y-m-d\T23:59:59");

// Drupal time formats = "Y-m-d H:i:s"
define("Drupal_BeginningOfDay", "Y-m-d 00:00:00");
define("Drupal_Noon", "Y-m-d 12:00:00");
define("Drupal_EndOfDay", "Y-m-d 23:59:59");

define("ONE_MINUTE", 60);
define("ONE_HOUR", (ONE_MINUTE*60));
define("ONE_DAY", (ONE_HOUR * 24));


// When running via `drush rs`, disable wysiwyg profiles
function wk_boot() {
  if (php_sapi_name() == 'cli-server') {
    cache_set('wysiwyg_profiles', array());
  }
}

/**
 * Alter a list of view modes allowed for a file embedded in the WYSIWYG.
 *
 * @param array $view_modes
 *   An array of view modes that can be used on the file when embedded in the
 *   WYSIWYG.
 * @param object $file
 *   A file entity.
 *
 * @see media_get_wysiwyg_allowed_view_modes()
 */
function wk_media_wysiwyg_wysiwyg_allowed_view_modes_alter(&$view_modes, $file) {
  //$view_modes['default']['label'] = t('Display an unmodified version of the file');
  // We do not want to allow the user to select 'preview' or 'teaser' here.
  unset($view_modes['preview']);
  unset($view_modes['teaser']);
}


/**
 * Alter the output generated by Media filter tags.
 *
 * @param array $element
 *   The renderable array of output generated for the filter tag.
 * @param array $tag_info
 *   The filter tag converted into an associative array by
 *   media_token_to_markup() with the following elements:
 *   - 'fid': The ID of the media file being rendered.
 *   - 'file': The object from file_load() of the media file being rendered.
 *   - 'view_mode': The view mode being used to render the file.
 *   - 'attributes': An additional array of attributes that could be output
 *     with media_get_file_without_label().
 * @param array $settings
 *   An additional array of settings.
 *   - 'wysiwyg': A boolean if the output is for the WYSIWYG preview or FALSE
 *     if for normal rendering.
 *
 * @see media_token_to_markup()
 */
function wk_media_wysiwyg_token_to_markup_alter(&$element, $tag_info, $settings) {
  // If the <img> tag has any of media-left, media-right or media-center,
  // then copy that class to the <div> that wraps the image.
  if (isset($element['content']['file']['#attributes']['class'])) {
    foreach ($element['content']['file']['#attributes']['class'] as $item) {
      if (!in_array($item, array('media-element')) && isset($element['content']['#attributes']['class']) && !array_key_exists($item, $element['content']['#attributes']['class'])) {
        _wk_add_class($element['content']['#attributes'], $item);
      }
    }
  }
  // If there is a user-specified 'style' attribute, check
  // to see if 'float: right' or 'float: left' were applied.
  if (isset($element['content']['file']['#attributes']['style'])) {
    if (strstr($element['content']['file']['#attributes']['style'], 'right')) {
      _wk_add_class($element['content']['#attributes'], 'media-right');
    }
    if (strstr($element['content']['file']['#attributes']['style'], 'left')) {
      _wk_add_class($element['content']['#attributes'], 'media-left');
    }
  }
  if (isset($element['content']['file']['#file']->field_image_width[LANGUAGE_NONE])) {
    $width = $element['content']['file']['#file']->field_image_width[LANGUAGE_NONE];
    if (is_array($width) && isset($width[0]['value'])) {
      $width = $width[0]['value'];
    }
    if (!empty($width) && ($width != '_none')) {
      if (is_array($width)) {
        print "What width is an array?\n" . var_export($width, true) . "\n";
      }
      _wk_add_class($element['content']['#attributes'], 'media-width-' . $width);
    }
  }
}

function _wk_add_class(&$item, $additional) {
  if (isset($item['class']) && !is_array($item['class'])) {
    $item['class'] = [$item['class']];
  }
  $item['class'][] = $additional;
}


/**
 * This is the hook form alter for the media edit dialog that
 * comes up when you click on the "image" icon in the wysiwyg editor.
 *
 * The form that comes up when you click the "edit" button on an
 * image file is form_id file_entity_edit.
 *
 * We want to hide the "link", "width" and "style" controls
 * on the wysiwyg dialog, because these items are specified
 * via the wysiwyg editor controls, not the media dialog.
 */
function wk_form_alter__media_wysiwyg_format_form(&$form, &$form_state) {
  hide($form['options']['fields']['field_image_style']);
  hide($form['options']['fields']['field_image_width']);
  hide($form['options']['fields']['field_link']);
}

/**
 * Implements hook_module_implements_alter
 *
 * Make sure that our hook_form_alter is called after
 * revisioning_form_alter.
 */
function wk_module_implements_alter(&$implementations, $hook) {
  // Do nothing unless we implement the hook being tested (safety)
  if (isset($implementations['wk'])) {
    switch($hook) {
      // Make hook form_alter runs last
      case 'form_alter':
        $group = $implementations['wk'];
        unset($implementations['wk']);
        $implementations['wk'] = $group;
        break;
    }
  }
}

/**
 * Implement hook_mail_alter
 *
 * Drupal will send out email messages where the 'From' header
 * is taken from the email address that the submitting user typed
 * in to a web form.
 *
 * This can cause messages to be rejected by mail servers that
 * implement DMARC.  For example, Google mail will reject any
 * mail proporting to be 'From' any yahoo.com address due to the
 * fact that (a) Google respects DMARC policies, and (b) Yahoo's
 * DMARC policy prohibits 'From' address forgary.
 *
 * See: https://support.google.com/mail/answer/2451690
 */
function wk_mail_alter(&$message) {
  // DMARC failures are only an issue when the domain of
  // the 'From' address is different than the domain of the
  // 'Sender' address.
  $sender_domain = wk_domain_from_address($message['headers']['Sender']);
  $from_domain = wk_domain_from_address($message['headers']['From']);
  if (empty($sender_domain) || empty($from_domain) || !isset($message['params']['name']) || empty($message['params']['name'])) {
    // Fail -- but how should we best notify this situation?
    $message['sent'] = FALSE;
  }
  else if ($sender_domain != $from_domain) {
    $proxy_from_address = 'anonymous';
    $message['headers']['Reply-To'] = $message['headers']['From'];
    $message['headers']['From'] = $message['params']['name'] . ' <' . $proxy_from_address . $sender_domain . '>';
  }
}

/**
 * Implements hook_mail().
 */
function wk_mail($key, &$message, $params) {
  $language = $message['language'];

  $variables['user'] = $params['account'];
  $variables['org_email'] = $params['org_email'];
  if (isset($params['recipient'])) {
    $variables['recipient'] = $params['recipient'];
  }

  $message['subject'] .= _wk_mail_text($key . '_subject', $language, $variables);
  $message['body'][] = _wk_mail_text($key . '_body', $language, $variables);
}

/**
 * Returns a mail string for a variable name.
 */
function _wk_mail_text($key, $language = NULL, $variables = array(), $replace = TRUE) {
  $langcode = isset($language) ? $language->language : NULL;
  $text = '';

  if ($admin_setting = variable_get('wk_mail_' . $key, FALSE)) {
    // An admin setting overrides the default string.
    $text = $admin_setting;
  }
  else {
    // No override, return default string.
    switch ($key) {
      case 'wk_google_apps_account_requested_subject':
        $text = t('[user:name] requests Google Apps email address <[org_email:address]>.', array(), array('langcode' => $langcode));
        break;

      case 'wk_google_apps_account_requested_body':
        $text = t('To approve, visit page http://westkingdom.org/approve-email-requests.', array(), array('langcode' => $langcode));
        break;

      case 'wk_google_apps_account_created_subject':
        $text = t('Your Google Apps email address for wesktingdom.org has been created.', array(), array('langcode' => $langcode));
      break;
      case 'wk_google_apps_account_created_body':
        $text = t("Save this email for your records.

Your westkingdom.org email address:

[org_email:address]

Before you can use this account, you must reset your password. You may do so on the following page:

[org_email:reset]

Once you have reset your organization account password, you may log in to your West Kingdom Google Apps account:

[org_email:login]

You may use your organization account as a regular gmail account if you wish; alternately, you may also configure it to forward all of your organization email to another address.

Please contact the Web Minister if you have any questions.

--  [site:name] team", array(), array('langcode' => $langcode));
      break;
    }
  }

  if ($replace) {
    // We do not sanitize the token replacement, since the output of this
    // replacement is intended for an e-mail message, not a web browser.
    $text = token_replace($text, $variables, array('language' => $language, 'callback' => 'wk_mail_tokens', 'sanitize' => FALSE, 'clear' => TRUE));
  }

  return $text;
}

/**
 * Token callback to add tokens for regnum mails.
 *
 * This function is used by the token_replace() call at the end of
 * _wk_mail_text() to set up some additional tokens that can be
 * used in email messages generated by regnum_mail().
 *
 * @param $replacements
 *   An associative array variable containing mappings from token names to
 *   values (for use with strtr()).
 * @param $data
 *   An associative array of token replacement values.
 * @param $options
 *   Unused parameter required by the token_replace() function.
 */
function wk_mail_tokens(&$replacements, $data, $options) {
  foreach ($data['org_email'] as $key => $value) {
    $replacements["[org_email:$key]"] = $value;
  }
}

/**
 * @param $op:
 *   The operation, e.g. wk_google_apps_account_created
 * @param $org_email
 *   The @westkingdom.org account created
 * @param $account
 *   The Drupal account this address was created for
 */
function _wk_org_email_notify($op, $org_email, $account, $recipient = NULL, $language = NULL) {
  $org_params['address'] = $org_email;
  $org_params['login'] = 'http://www.google.com/a/westkingdom.org';
  $org_params['reset'] = 'http://westkingdom.org/users/' . $account->uid . '/mail/reset';

  $params['org_email'] = $org_params;
  $params['account'] = $account;

  if (!$recipient) {
    $recipient = $account->mail;
  }
  // dpm($params);
  $mail = drupal_mail('wk', $op, $recipient, $language, $params);
  return empty($mail) ? NULL : $mail['result'];
}

// Return the domain the address is part of
// including the '@'.
function wk_domain_from_address($address) {
  $domain = '';
  if (preg_match("/@[^>]*/", $address, $matches)) {
    $domain = $matches[0];
  }
  return $domain;
}

/**
 * Implements hook_entity_info_alter().
 *
 * c.f. http://www.wunderkraut.com/blog/drupal-7-custom-node-view-modes/2010-12-20
 */
function wk_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['toc_entry'] = array(
    'label' => t('TOC entry'),
    'custom settings' => TRUE,
  );
}

function wk_preprocess_page(&$variables) {
  if (isset($variables['node'])) {
    $fn = 'wk_preprocess_page__' . $variables['node']->type;
    if (function_exists($fn)) {
      $fn($variables);
    }
  }

  // http://rickmanelius.com/article/tell-facebook-which-image-share
  $img = FALSE;
  // If there is a page picture, use that.
  if(isset($variables['node']->field_page_picture[LANGUAGE_NONE][0]['uri'])) {
    $img = file_create_url($variables['node']->field_page_picture[LANGUAGE_NONE][0]['uri']);
  }
  // If there is no page picture, but there is a branch group
  // associated with the page, then use that.
  elseif(isset($variables['node']->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['taxonomy_term']->field_arms[LANGUAGE_NONE][0]['uri'])) {
    $img = file_create_url($variables['node']->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['taxonomy_term']->field_arms[LANGUAGE_NONE][0]['uri']);
  }
  // If someone is sharing an officer page, then use the
  // officer badge as the thumbnail image for Facebook.
  elseif(isset($variables['node']->field_office[LANGUAGE_NONE][0]['taxonomy_term']->field_badge[LANGUAGE_NONE][0]['uri'])) {
    $img = file_create_url($variables['node']->field_office[LANGUAGE_NONE][0]['taxonomy_term']->field_badge[LANGUAGE_NONE][0]['uri']);
  }
  if ($img) {
    $element = array(
      '#tag' => 'meta',
      '#attributes' => array(
        "property" => "og:image",
        "content" => $img,
      ),
    );
    drupal_add_html_head($element,'facebook_share_image');
  }
}

function wk_preprocess_page__officers(&$variables) {
  global $user;
  $output = '';
  $office_title='';
  $branch_group_terms=FALSE;
  $officer_terms=FALSE;
  $node = $variables['node'];
  if (isset($node->taxonomy_vocabulary_2[LANGUAGE_NONE])) {
    $branch_group_terms = $node->taxonomy_vocabulary_2[LANGUAGE_NONE];
  }
  if (isset($node->field_office[LANGUAGE_NONE])) {
    $officer_terms = $node->field_office[LANGUAGE_NONE];
  }
  if ($branch_group_terms) {
    $branch_output = '';
    foreach ($branch_group_terms as $index => $term) {
      if (isset($term['taxonomy_term'])) {
        $view = field_view_field('taxonomy_term', $term['taxonomy_term'], 'field_arms');
        if (!empty($view)) {
          $branch_output .= render($view);
        }
      }
    }
    // We used to put the branch group arms in the header, but no longer.
    // Maybe later we will put $branch_output somewhere else, more appropriate.
  }
  if ($officer_terms) {
    $officer_output = '';
    foreach ($officer_terms as $index => $term) {
      if (isset($term['taxonomy_term'])) {
        $view = field_view_field('taxonomy_term', $term['taxonomy_term'], 'field_badge');
        if (!empty($view)) {
          $officer_output .= render($view);
        }
        if (empty($office_title)) {
          $office_title = ' the ';
        }
        else {
          $office_title .= ' and ';
        }
        $office_title .= $term['taxonomy_term']->name;
      }
    }
    if (!empty($officer_output)) {
      $output .= "<div class='officer-badge'>$officer_output</div>";
    }
  }
  if (!empty($output)) {
    $variables['title_prefix']['#markup'] = "
<div class='officer-badges'>
  $output
</div>";
  }
  $uri = request_uri();
  $variables['title_suffix']['#markup'] = "<a href='$uri/contact' class='link-contact clearfix'>Contact $office_title</a>";
}

function wk_preprocess_page__cal_event(&$variables) {
  // Inelegant, but we need to filter out "edit" page (and others) somehow.
  $value = arg(2);
  if (empty($value)) {
    $node = $variables['node'];
    // Output device arms before the page title
    $output = '';
    foreach ($node->taxonomy_vocabulary_2[LANGUAGE_NONE] as $index => $term) {
      if (isset($term['taxonomy_term'])) {
        $view = field_view_field('taxonomy_term', $term['taxonomy_term'], 'field_arms');
        if (!empty($view)) {
          $output .= render($view);
        }
      }
    }
    if (!empty($output)) {
      $variables['title_prefix']['#markup'] = "
  <div class='calendar-event-arms'>
    <div class='left-arms'>$output</div>
    <div class='right-arms'>$output</div>
  </div>";
    }
    // Output additional information about the event below the page title
    $cal_event_location_long_summary_markup = '';
    $cal_event_date = wk_node_field_date_render_array($node);
    $variables['cal_event_date'] = $cal_event_date;
    $variables['cal_event_branch'] = field_view_field('node', $node, 'taxonomy_vocabulary_2', 'default'); // $node->taxonomy_vocabulary_2;
    if (isset($node->field_event_site[LANGUAGE_NONE][0]['node']) && isset($node->field_event_site[LANGUAGE_NONE][0]['node']->field_location[LANGUAGE_NONE][0])) {
      $city = $node->field_event_site[LANGUAGE_NONE][0]['node']->field_location[LANGUAGE_NONE][0]['city'];
      $province = $node->field_event_site[LANGUAGE_NONE][0]['node']->field_location[LANGUAGE_NONE][0]['province'];
      $province_name = $node->field_event_site[LANGUAGE_NONE][0]['node']->field_location[LANGUAGE_NONE][0]['province_name'];
      if (!empty($city) && !empty($province)) {
        $variables['cal_event_location_summary'] = '(' . $city . ', ' . $province . ')';
        $variables['cal_event_location_long_summary'] =  $city . ', ' . $province_name;
        $cal_event_location_long_summary_markup = '<div class="cal-event-location-long-summary">' . $variables['cal_event_location_long_summary'] . '</div>';
      }
    }
    $variables['title_suffix']['#markup'] = '
    <div class="event-info">
      ' . render($cal_event_date) . $cal_event_location_long_summary_markup . render($variables['cal_event_branch']) . '
    </div>
  ';
  }
}

function _wk_render_event_list($event_list) {
  $result = "";
  $link_options = array();
  foreach ($event_list as $nid => $node) {
    $link_content = $node->title;
    $term_info = reset($node->taxonomy_vocabulary_2[$node->language]);
    if ($term_info) {
      $term = false;
      if (isset($term_info['taxonomy_term'])) {
        $term = $term_info['taxonomy_term'];
      }
      elseif (isset($term_info['tid'])) {
        $term = taxonomy_term_load($term_info['tid']);
      }
      if ($term) {
        $e = entity_metadata_wrapper("taxonomy_term", $term);
        $img_info = $e->field_arms->value();
        if ($img_info) {
          $image_attributes = array('alt' => $term->name);
          $format_string = 'd F Y';
          $dv = $node->field_date[$node->language][0];
          $conflict_dates = _wk_format_date_range($dv, $format_string);
          $title = $term->name . ' - ' . $node->title . ', ' . $conflict_dates;
          $link_content = theme_image(array("path" => $img_info['uri'], "title" => $title, "attributes" => $image_attributes));
          $link_options['html'] = true;
          $link_options['attributes']['class'] = array('conflicting-event');
        }
      }
    }

    $result .= l($link_content, 'node/' . $node->nid, $link_options) . ' ';
  }
  return $result;
}

/**
 * Drupal trims usernames to prevent the layout of certain
 * views from wrapping awkwardly.  Long names are very common
 * in the West, though, and trimming them looks bad.  This
 * hook puts them back to their full width; we'll just have
 * to fix any layout problems this may cause as they come up.
 */
function wk_process_username(&$variables) {
  $variables['name'] = check_plain($variables['name_raw']);
}

/**
 * Add a hook suggestion for embedded content for the "officers" content type.
 *
 * http://drupal.stackexchange.com/questions/27025/how-to-provide-template-for-particular-view-mode
 */
function wk_preprocess_node(&$variables) {
  switch($variables['view_mode']) {
    case 'toc_entry':
      $variables['theme_hook_suggestions'][] = 'node__' . $variables['type'] . '__' . $variables['view_mode'];
      break;
  }

  if (isset($variables['node'])) {
    $fn = 'wk_preprocess_node__' . $variables['node']->type;
    if (function_exists($fn)) {
      $fn($variables);
    }
  }
}

function wk_preprocess_node__officers(&$variables) {
  hide($variables['content']['field_office']);
  hide($variables['content']['taxonomy_vocabulary_2']);
}



function wk_preprocess_node__cal_event(&$variables) {
  if ($variables['teaser']) {
    $node = $variables['node'];
    $variables['content']['body'][0]['#markup'] = '<div class="teaser-date">' . wk_render_node_field_date($node) . '</div>' . text_summary($variables['content']['body'][0]['#markup'], NULL, 200);
    if (isset($node->taxonomy_vocabulary_2[LANGUAGE_NONE])) {
      $branch_group_terms = $node->taxonomy_vocabulary_2[LANGUAGE_NONE];
    }
    if ($branch_group_terms) {
      $branch_output = '';
      foreach ($branch_group_terms as $index => $term) {
        if (isset($term['tid'])) {
          $t = taxonomy_term_load($term['tid']);
          $view = field_view_field("taxonomy_term", $t, "field_arms");
          if (!empty($view)) {
            $branch_output .= render($view);
          }
        }
      }
      if (!empty($branch_output)) {
        $variables['title'] = "<div class='cal-event-branch'>$branch_output</div>" . $variables['title'];
      }
    }
  }
}

function wk_taxonomy_tree_remove_unnecessary(&$element, $limit_branches = array()) {
  $has_selectable_elements = FALSE;
  foreach ($element as $tid => $data) {
    if (($tid[0] != '#') && is_numeric($tid)) {
      $is_selectable = array_key_exists($tid, $limit_branches);
      if (array_key_exists($tid . '-children', $element[$tid])) {
        $is_selectable |= wk_taxonomy_tree_remove_unnecessary($element[$tid][$tid . '-children'], $limit_branches);
        if ($is_selectable) {
          $element[$tid][$tid . '-children']['#start_minimized'] = FALSE;
          $element[$tid][$tid . '-children']['#level_start_minimized'] = FALSE;
        }
      }
      if (!$is_selectable) {
        $element[$tid]['#access'] = FALSE;
      }
      else {
        $element[$tid]['#level_start_minimized'] = TRUE;
      }
      $has_selectable_elements |= $is_selectable;
    }
  }
  return $has_selectable_elements;
}

function wk_taxonomy_tree_initial_minimized_state(&$element) {
  $has_selected_elements = FALSE;
  foreach ($element as $tid => $data) {
    if (($tid[0] != '#') && is_numeric($tid)) {
      $is_selected = $element[$tid][$tid]['#value'];
      if (array_key_exists($tid . '-children', $element[$tid])) {
        $is_selected |= wk_taxonomy_tree_initial_minimized_state($element[$tid][$tid . '-children']);
        if (!$is_selected) {
          $element[$tid][$tid . '-children']['#start_minimized'] = TRUE;
          $element[$tid][$tid . '-children']['#level_start_minimized'] = TRUE;
        }
      }
      if (!$is_selected) {
        $element[$tid]['#level_start_minimized'] = TRUE;
      }
      $has_selected_elements |= $is_selected;
    }
  }
  return $has_selected_elements;
}

function wk_taxonomy_tree_form_element_alter(&$element) {
  $has_selected_elements = FALSE;
  foreach ($element as $tid => $data) {
    if (($tid[0] != '#') && is_numeric($tid)) {
      $is_selected = FALSE;
      wk_taxonomy_tree_form_element_term_alter($element[$tid][$tid], $tid);
      $is_selected = $element[$tid][$tid]['#value'];
      if (array_key_exists($tid . '-children', $element[$tid])) {
        $is_selected |= wk_taxonomy_tree_form_element_alter($element[$tid][$tid . '-children']);
        if (!$is_selected) {
          $element[$tid][$tid . '-children']['#start_minimized'] = TRUE;
          $element[$tid][$tid . '-children']['#level_start_minimized'] = TRUE;
        }
      }
      if (!$is_selected) {
        $element[$tid]['#level_start_minimized'] = TRUE;
      }
      $has_selected_elements |= $is_selected;
    }
  }
  return $has_selected_elements;
}

/**
 * Alter the data built by term_reference_tree.widget.inc.
 * @see: _term_reference_tree_build_item()
 */
function wk_taxonomy_tree_form_element_term_alter(&$element, $tid) {
  $term = taxonomy_term_load($tid);
  $term_render_array = taxonomy_term_view($term, 'term_with_icon');
  // Probably better to just do this:
  //   $element['#title'] = drupal_render($term_render_array);
  // We would need to re-order the title and remove the link from it, though.
  $label_prefix = '';
  $suffix = '';
  foreach ($term_render_array as $key => $child) {
    if ($key[0] != '#') {
      if (array_key_exists('#field_type', $child) && ($child['#field_type'] == 'image')) {
        $label_prefix .= drupal_render($child);
      }
      else {
        $suffix .= strip_tags(drupal_render($child), '<div>');
      }
    }
  }
  $label_key = $element['#type'] == 'checkbox_tree_label' ? '#value' : '#title';
  $element[$label_key] = $label_prefix . $element[$label_key] . $suffix;
}

function wk_term_with_icon_form_element_after_build($form_element, &$form_state) {
  // This is set in wk_form_alter__cal_event_node_form
  $limit_branches = isset($form_element['#entity']->limit_branches) ? $form_element['#entity']->limit_branches : array();
  wk_taxonomy_tree_form_element_alter($form_element[0]);
  // Reorganize the tree under the term "The Society for Creative Anachronism"
  if (array_key_exists(SOCIETY_TID, $form_element[0]) && array_key_exists(KINGDOM_OF_THE_WEST_TID, $form_element[0][SOCIETY_TID][SOCIETY_TID . '-children'][KINGDOM_OF_THE_WEST_TID])) {
    $corpora_element = $form_element[0][SOCIETY_TID];
    $corpora_element['#term-name'] = t("Society for Creative Anachronism - Other Kingdoms");
    $label_key = $corpora_element[SOCIETY_TID]['#type'] == 'checkbox_tree_label' ? '#value' : '#title';
    $corpora_element[SOCIETY_TID][$label_key] = $corpora_element['#term-name'];
    unset($form_element[0][SOCIETY_TID]);
    $form_element[0][KINGDOM_OF_THE_WEST_TID] = $corpora_element[SOCIETY_TID . '-children'][KINGDOM_OF_THE_WEST_TID];
    unset($corpora_element[SOCIETY_TID . '-children'][KINGDOM_OF_THE_WEST_TID]);
    $form_element[0][SOCIETY_TID] = $corpora_element;
  }
  if (!empty($limit_branches)) {
    wk_taxonomy_tree_remove_unnecessary($form_element[0], $limit_branches);
  }
  else {
    $has_selected = wk_taxonomy_tree_initial_minimized_state($form_element[0]);
    if (!$has_selected) {
      foreach ($form_element[0] as $tid => $data) {
        if (($tid[0] != '#') && is_numeric($tid)) {
          $form_element[0][$tid]['#level_start_minimized'] = FALSE;
          $form_element[0][$tid][$tid . '-children']['#start_minimized'] = FALSE;
          $form_element[0][$tid][$tid . '-children']['#level_start_minimized'] = FALSE;
          break;
        }
      }
    }
  }
  return $form_element;
}

function wk_form_alter_taxonomy_tree_with_icon_fields(&$element) {
  if (is_array($element)) {
    foreach ($element as $key => $data) {
      if ($key[0] != '#') {
        if (!is_numeric($key) && in_array($key, array('taxonomy_vocabulary_2', 'field_office'))) {
          $language = $element[$key]['#language'];
          if ((isset($element[$key][$language])) && ($element[$key][$language]['#type'] == 'checkbox_tree')) {
            $element[$key]['#attributes']['class'][] = 'term-with-icon-variant';
            $element[$key][$language]['#after_build'][] = 'wk_term_with_icon_form_element_after_build';
          }
        }
        else {
          wk_form_alter_taxonomy_tree_with_icon_fields($element[$key]);
        }
      }
    }
  }
}

// Make a calendar date request to hold the specified calendar event
// again during the following year.  Note that this code is only used
// when the Seneschal or Calendar deputy begins the calendar planning
// process for the next year.  At that time, date requests for all of
// the "carryover" events are created by repeatedly calling this function.
function wk_create_calendar_date_request($node, $additional_delta = 0) {
  // Just ignore this event if we have already made
  // a date request to re-hold it next year.
  $date_request_info = _wk_find_date_request_for_event($node->nid);
  if (empty($date_request_info)) {
    global $user;

    // Create an entity and set the time and user who created it
    $date_request_entity = entityform_create(array("type" => "calendar_date_request"));
    $date_request_entity->uid = $user->uid;
    $date_request_entity->changed = time();

    // The rest of our manipulations will be with an entity wrapper
    $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
    $date_request->created = time();
    $date_request->field_event_name->set($node->title);
    $date_request->field_placeholder_event_descript->set(t("More information will be provided as it becomes available."));
    $date_request->field_repeat_of_event->set($node->nid);
    $date_request->field_society_name->set($user->name);
    $date_request->field_email_address->set($user->mail);

    $v = $node->taxonomy_vocabulary_2[$node->language];
    if (!empty($v)) {
      $branch_tids = array();
      foreach ($v as $index => $info) {
        $branch_tids[] = $info['tid'];
      }
      $date_request->taxonomy_vocabulary_2->set($branch_tids);
    }

    $dv = $node->field_date[$node->language][0];
    $start_date = new DateTime($dv['value'], new DateTimeZone($dv['timezone']));
    $start_date->setTime(12,0,0);
    $end_date = new DateTime($dv['value2'], new DateTimeZone($dv['timezone']));
    $end_date->setTime(12,0,0);
    $duration = $start_date->diff($end_date);

    // Add one year, and then find the nearest
    // date that starts on the same day of the week
    // as the original event.
    $original_dow = $start_date->format("w");
    $start_date->modify("+1 year");
    $delta_dow = ($original_dow - $start_date->format("w")) % 7;
    $days_interval = new DateInterval( "P" . abs($delta_dow) . "D" );
    if ($delta_dow < 0) {
      $days_interval->invert = 1;
    }
    $start_date->add($days_interval);
    if ($additional_delta) {
      $start_date->modify("$additional_delta weeks");
    }
    // Calculate a new end date at the same duration
    // as the original event
    $end_date = new DateTime($start_date->format(W3C_Noon), $start_date->getTimezone());
    $end_date->add($duration);

    $v = $date_request->field_first_choice_date->value();
    $v['value'] = $start_date->format(W3C_Noon);
    $v['value2'] = $end_date->format(W3C_Noon);
    $date_request->field_first_choice_date->set($v);

    // Make the first alternate the week after
    $alternate = new DateTime($start_date->format("Y-m-d H:i:s"), $start_date->getTimezone());
    $alternate->modify("+1 week");

    $alternate_formatted = $alternate->format('Y-m-d');
    $date_request->field_alternate_date->set(strtotime($alternate_formatted . 'T12:00:00'));

    // Make the second alternate the week before
    $second_alternate = new DateTime($start_date->format("Y-m-d H:i:s"), $start_date->getTimezone());
    $second_alternate->modify("-1 week");

    $second_alternate_formatted = $second_alternate->format('Y-m-d');
    $date_request->field_second_alternate_date->set(strtotime($second_alternate_formatted . 'T12:00:00'));

    $date_request->save();
  }
}

function wk_form_alter__calendar_date_request_entityform_edit_form(&$form, &$form_state) {
  array_unshift($form['#validate'], '_wk_form_validate_branch_groups_must_be_siblings');
  array_unshift($form['#validate'], '_wk_form_validate_calendar_must_be_open_for_date');
  $form_state['#branch_group_msg'] = t("For example, if the event is a War between the Principality of the Mists, and the Principality of Cynagua, then both the Mists and Cynagua should be selected. In most other cases, only one branch group should be selected here.");
  global $user;
  $menu = menu_get_item();
  //dpm($menu);
  $nid = FALSE;
  $group_tid = FALSE;
  if (count($menu['page_arguments']) > 2) {
    if ((count($menu['page_arguments']) > 3) && ($menu['page_arguments'][2] == 'group')) {
      $group_from_menu = $menu['page_arguments'][3];
      $terms = taxonomy_get_tree(2);
      foreach ($terms as $tinfo) {
        $term = taxonomy_term_load($tinfo->tid);
        $short_name = _wk_term_short_name($term);
        $machine_name = _wk_to_machine_name($short_name);
        if (strtolower($group_from_menu) == $machine_name) {
          $group_tid = $term->tid;
        }
      }
    }
    else {
      $nid = $menu['page_arguments'][2];
    }
  }
  // If there was no group or nid specified on the URL,
  // then set the group if the currently logged-in user
  // is a seneschal.
  if (!$group_tid && !$nid) {
    $branches = _wk_is_seneschal();
    if (!empty($branches)) {
      $group_tid = $branches[0];
      if (isset($form['field_society_name']) && empty($form['field_society_name'][LANGUAGE_NONE][0]['value']['#default_value'])) {
        $form['field_society_name'][LANGUAGE_NONE][0]['value']['#default_value'] = $user->name;
        hide($form['field_society_name']);
      }
      if (isset($form['field_email_address']) && empty($form['field_email_address'][LANGUAGE_NONE][0]['value']['#default_value'])) {
        $form['field_email_address'][LANGUAGE_NONE][0]['value']['#default_value'] = $user->mail;
        hide($form['field_email_address']);
      }
    }
  }
  if ($nid) {
    $node = node_load($nid);
    $additional_delta = 0;
    if (count($menu['page_arguments']) > 3) {
      $additional_delta = $menu['page_arguments'][3];
    }
    // TODO: Error checking and error display
    if ($node) {
      $group_tid = $node->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['tid'];
      //dpm($node);
      // Copy the title
      $form['field_event_name'][LANGUAGE_NONE][0]['value']['#default_value'] = $node->title;
      $form['field_repeat_of_event'][LANGUAGE_NONE][0]['nid']['#default_value'] = $node->nid;
      // Copy the branch group or branch groups
      $group_ids = array();
      foreach ($node->taxonomy_vocabulary_2[LANGUAGE_NONE] as $index => $info) {
        $tid = $info['tid'];
        $group_ids[$tid] = $tid;
      }
      $form['taxonomy_vocabulary_2'][LANGUAGE_NONE]['#default_value'] = $group_ids;
      // Find the start and end date of the original event
      $dv = $node->field_date[LANGUAGE_NONE][0];
      $start_date = new DateTime($dv['value'], new DateTimeZone($dv['timezone']));
      $start_date->setTime(12,0,0);
      $end_date = new DateTime($dv['value2'], new DateTimeZone($dv['timezone']));
      $end_date->setTime(12,0,0);
      $duration = $start_date->diff($end_date);
      $previous_event_date = $start_date->format("d F, Y");
      $previous_event_title = l($node->title, 'node/' . $node->nid);

      // Add one year, and then find the nearest
      // date that starts on the same day of the week
      // as the original event.
      $original_dow = $start_date->format("w");
      $start_date->modify("+1 year");
      $delta_dow = ($original_dow - $start_date->format("w")) % 7;
      $days_interval = new DateInterval( "P" . abs($delta_dow) . "D" );
      if ($delta_dow < 0) {
        $days_interval->invert = 1;
      }
      $start_date->add($days_interval);
      if ($additional_delta) {
        $start_date->modify("$additional_delta weeks");
      }
      // Calculate a new end date at the same duration
      // as the original event
      $end_date = new DateTime($start_date->format("Y-m-d H:i:s"), $start_date->getTimezone());
      $end_date->add($duration);
      $form['field_first_choice_date'][LANGUAGE_NONE][0]['#default_value'] =  $dv;
      $form['field_first_choice_date'][LANGUAGE_NONE][0]['#default_value']['value'] = $start_date->format("Y-m-d H:i:s");
      $form['field_first_choice_date'][LANGUAGE_NONE][0]['#default_value']['value2'] = $end_date->format("Y-m-d H:i:s");
      $nextyear = $start_date->format("Y");

      // Make the first alternate the week after
      $alternate = new DateTime($start_date->format("Y-m-d H:i:s"), $start_date->getTimezone());
      $alternate->modify("+1 week");
      $form['field_alternate_date'][LANGUAGE_NONE][0]['#default_value']['value'] = $alternate->format("Y-m-d H:i:s");
      // Make the second alternate the week before
      $second_alternate = new DateTime($start_date->format("Y-m-d H:i:s"), $start_date->getTimezone());
      $second_alternate->modify("-1 week");
      $form['field_second_alternate_date'][LANGUAGE_NONE][0]['#default_value']['value'] = $second_alternate->format("Y-m-d H:i:s");
      // Inform the user that this form is related to an existing
      // event description node.
      drupal_set_message(t("Submit a calendar date request below to re-hold the event !previous from !prevdate again in !nextyear. <a href='/calendar-date-request'>Cancel</a>", array(
          '!previous' => $previous_event_title,
          '!prevdate' => $previous_event_date,
          '!nextyear' => $nextyear,
          '!cancelurl' => '/calendar-date-request')));
    }
  }
  if ($group_tid) {
    _wk_pre_select_group_in_form($form, $form_state, $group_tid);
    // TODO: look up seneschal for this branch group
  }
}

function _wk_form_validate_calendar_must_be_open_for_date($form, &$form_state) {
  $current_date = date("Y-m-d") . ' 12:00:00';
  $open_for_all_year = wk_calendar_year_open_for_all_events();
  $earliest_date_epoch = _wk_earliest_event_request_data();
  $earliest_date = _wk_format_date($earliest_date_epoch, "Y-m-d") . ' 00:00:00';
  $year_of_calendar_request = FALSE;

  $date_field_name_map = array(
    'field_first_choice_date' => 'first choice date',
    'field_alternate_date' => 'second choice date',
    'field_second_alternate_date' => 'third choice date',
  );

  $at_least_one_valid = FALSE;
  $duration = FALSE;
  foreach ($date_field_name_map as $date_field => $field_name) {
    $dv = $form_state['values'][$date_field][LANGUAGE_NONE][0];
    $requested_date = $dv['value'];
    $requested_timezone = $dv['timezone'];
    if (!empty($requested_date)) {

      $start_date = new DateTime($requested_date, new DateTimeZone($requested_timezone));
      $start_date->setTime(12,0,0);

      if ($current_date > $requested_date) {
        return form_set_error($date_field, t("Your !choice, !when, has already passed.  Please only select dates that are in the future.", array('!choice' => $field_name, '!when' => $start_date->format("F j, Y"))));
      }

      if ($requested_date < $earliest_date) {
        return form_set_error($date_field, t("It is too late to request calendar event dates on !when.  The earliest available date for events is !earliest, as it is necessary to allow time for events to be published in The Page.  Please select a later date.", array('!choice' => $field_name, '!when' => $start_date->format("F j, Y"), '!earliest' => _wk_format_date($earliest_date_epoch, "F j, Y"))));
      }

      // For the first date request, also check the duration.  If the
      // user entered an event that is too long, it could indicate a typo.
      if (!$duration) {
        $end_date = new DateTime($dv['value2'], new DateTimeZone($requested_timezone));
        $end_date->setTime(12,0,0);
        $duration = $start_date->diff($end_date);

        // For now we allow up to 20-day events; that's longer than
        // anyone should need.
        if ($duration->days > 20) {
          return form_set_error($date_field, t("Your !choice, !when, is !dur days long.  Perhaps you made a mistake with the end date?  Most events are one to three days.", array('!choice' => $field_name, '!when' => $start_date->format("F j, Y"), '!dur' => $duration->days)));
        }
      }

      // Next, check to see if the calendar is open yet for the
      // requested date.  If the requested year == the year that is
      // open for all events, then no further checking is required.
      // We'll remember that we did this, and only do it once per
      // validation, provided that all dates that are requested are
      // made in the same calendar year.  If not, that will also be
      // a validation error.
      $requested_year = substr($requested_date, 0, 4);
      if (!$year_of_calendar_request) {
        $year_of_calendar_request = $requested_year;

        if ($requested_year > $open_for_all_year) {
          // Is it way too far in the future?  Then bail.
          if ($requested_year - $open_for_all_year > 1) {
            return form_set_error($date_field, t("Your !choice, !when, is too far in the future; request for this year will not be considered until sometime in mid-!yearbefore.", array('!choice' => $field_name, '!when' => $start_date->format("F j, Y"), '!yearbefore' => $requested_year - 1)));
          }

          $next_years_status = wk_calendar_status_for_next_year();
          $number_of_events_allowed = 0;
          switch ($next_years_status) {
            case CALENDAR_STATUS_CLOSED:
            case CALENDAR_STATUS_PREPARING:
              break;

            case CALENDAR_STATUS_ONE_EVENT:
              $number_of_events_allowed = 1;
              break;

            case CALENDAR_STATUS_TWO_EVENTS:
              $number_of_events_allowed = 2;
              break;
          }
          // No events allowed?  Exit with an error.
          if (!$number_of_events_allowed) {
            return form_set_error($date_field, t("The calendar is not yet open for events in !nextyear.  You may only request dates for events in !thisyear.", array('!nextyear' => $requested_year, '!thisyear' => $open_for_all_year)));
          }

          // Check to see how many events have already been requested for this branch group.
          // If they are already at their limit, then bail. (c.f. wk_calendar_events_for_one_branch)

          // TODO: Multiple groups selected?
          $branch_group = $form_state['values']['taxonomy_vocabulary_2'][LANGUAGE_NONE][0]['tid'];

          // Find all of the events that have been approved in the requested year already
          $approved_event_nids = _wk_get_calendar_event_nids($requested_year, $branch_group);

          // TODO: Also find event requests that have not been approved yet
          $requested_event_eids = _wk_date_requests_for_year($requested_year, $branch_group);

          $items = array();

          // Make a list of all of the event nodes that have already been
          // approved for this branch.
          $events = wk_load_nodes($approved_event_nids);
          foreach ($events as $node) {
            $url = 'node/' . $node->nid;
            $items[] = t('<b>Approved:</b>') . ' ' . l($node->title, $url);
          }

          // Make a list of all of the request entities that are pending
          // approval for this branch.
          foreach ($requested_event_eids as $id => $info) {
            $date_request_entity = entityform_load($id);
            $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
            $approved_event_node = $date_request->field_approved_event->value();
            if (empty($approved_event_node)) {
              $title = $date_request->field_event_name->value();
              $url = 'entityform/' . $id;
              $items[] = t('<i>Pending:</i>') . ' ' . l($title, $url);
            }
          }

          $total = count($items);
          if ($total >= $number_of_events_allowed) {

            // Test to see if the 'additional information' field contains "I understand".
            $additional_information = $form_state['values']['field_additional_information'][LANGUAGE_NONE][0]['value'];

            if (stristr($additional_information, "understand") === FALSE) {
              return form_set_error('field_additional_information', t("Currently, the calendar is only open for !max event!plural per group for !year; however, you have already made !count requests:<br><ul><li>!events</li></ul><br>If you need to make a calendar date request anyway, write <b>I understand</b> in the <i>additional information</i> field, and <i>explain</i> the reason you are submitting again.  Exceptions to the event limit will not be made.<br><br><b>Example valid reason:</b> <i>I understand that the calendar is only open for one event next year, but my last submission was in error. Please use this one instead.</i>.", array('!max' => $number_of_events_allowed, '!plural' => (($number_of_events_allowed == 1) ? '' : 's'), '!year' => $requested_year, '!count' => $total, '!events' => implode('</li><li>', $items))));
            }
            /*
                TODO: we should probably warn the user even if the advisory phrase was used;
                however, drupal_set_message cannot be used in a form validate function, so we'll
                need to do something else.

            else {
              drupal_set_message(t("Currently, the calendar is only open for !max event!plural per group for !year; however, you have already made !count requests:<ul><li>!events</li><ul>.", array('!max' => $number_of_events_allowed, '!plural' => (($number_of_events_allowed == 1) ? '' : 's'), '!year' => $requested_year, '!count' => $total, '!events' => implode('</li><li>', $items))), 'warning');
            }
            */
          }
        }
      }
      // Fail if one of the events is in a different year
      elseif ($year_of_calendar_request != $requested_year) {
        return form_set_error($date_field, t("Your !choice, !request_year, is in a different year than your other requested date.  The calendar date request process is organized by year; please ensure that all dates in the same request are for the same year.", array('!choice' => $field_name, '!request_year' => $requested_year)));
      }

      $at_least_one_valid = TRUE;
    }
  }

  if (!$at_least_one_valid) {
    return form_set_error('field_first_choice_date', t("You must select a date for your event."));
  }
}



/*

function wk_calendar_events_for_one_branch($form, &$form_state, $event_limit = UNLIMITED, $branch_groups = array()) {
  // Determine if current user is the Seneschal of a group.
  if (empty($branch_groups)) {
    $branch_groups = _wk_is_seneschal();
  }
  foreach ($branch_groups as $branch_group) {
    $branch_info = taxonomy_term_load($branch_group);
    $year = wk_calendar_year_of_preparation();
    $event_nids = _wk_get_calendar_event_nids($year - 1, $branch_group);
    $events = wk_load_nodes($event_nids);
    if (!empty($events)) {
      $selectable_items = array();
      $unselectable_items = array();
      $existing_date_request_count = 0;
      foreach ($events as $nid => $node) {
        // TODO: what if the group requested an event not held last year?  We still need
        // to record that as their selection.
        $date_request_info = _wk_find_date_request_for_event($nid);

*/

function _wk_form_validate_branch_groups_must_be_siblings($form, &$form_state) {
  $groups = array();
  foreach($form_state['values']['taxonomy_vocabulary_2'][LANGUAGE_NONE] as $info) {
    $groups[$info['tid']] = array('tid' => $info['tid']);
  }
  $branch_group_tree = taxonomy_get_tree(2);
  foreach($branch_group_tree as $tinfo) {
    if (array_key_exists($tinfo->tid, $groups)) {
      $groups[$tinfo->tid] = $tinfo;
    }
  }
  $parents = array();
  $saw_parent_and_child = FALSE;
  foreach ($groups as $tid => $ginfo) {
    $parent_id = $ginfo->parents[0];
    $parents[] = $parent_id;
    if (array_key_exists($parent_id, $groups)) {
      $saw_parent_and_child = TRUE;
    }
  }
  if ($saw_parent_and_child && (count($parents) == 2)) {
    return form_set_error('taxonomy_vocabulary_2', t("It is not permitted to select both a branch group and its parent group on this form.  Please select only one of these, and uncheck the other."));
  }
  if (count($parents) > 1) {
    return form_set_error('taxonomy_vocabulary_2', t("Only sibling branch groups may be selected on this form. !example", array('!example' => isset($form_state['#branch_group_msg']) ? $form_state['#branch_group_msg'] : '')));
  }
}

function _wk_form_validate_exactly_one_branch_group($form, &$form_state) {
  $count = count($form_state['values']['taxonomy_vocabulary_2'][LANGUAGE_NONE]);
  if ($count > 1) {
    return form_set_error('taxonomy_vocabulary_2', t("You may only select one branch group on this form."));
  }
}

function _wk_form_validate_meetings_are_repeating($form, &$form_state) {
  $event_type = $form['field_event_type'][LANGUAGE_NONE][0]['#value'];
  $repeating = $form['field_date'][LANGUAGE_NONE][0]['show_repeat_settings']['#value'];
  $repeat_rule = $form['field_date'][LANGUAGE_NONE][0]['#value']['rrule'];

  if ($repeating) {
    if (!$event_type) {
      form_set_error('field_event_type', t("The event is repeating.  Perhaps you intended to make it a meting or practice?"));
    }
  }
  else {
    if ($event_type == 1) {
      form_set_error('field_event_type', t("The event type is 'meeting or practice', but it does not repeat.  Meetings and practices must repeat regularly; otherwise, they are considered events, and must be scheduled through the Calendar Deputy."));
    }
  }
}

function _wk_form_validate_repeating_event_limit($form, &$form_state) {
  //dpm($form['field_date'][LANGUAGE_NONE][0]['#value']);
  //dpm($form);
  //dpm($form_state);
  $repeat_rule = $form['field_date'][LANGUAGE_NONE][0]['#value']['rrule'];
  if (isset($repeat_rule)) {
    // Check the COUNT of the number of repeats
    if ($repeat_rule['range_of_repeat'] == 'COUNT') {
      // For MONTHLY events, you can have 26 repeats (about a year at twice
      // a month, or two years at once a month).  For WEEKLY events, you can have
      // 52 repeats.
      $weekly = ($repeat_rule['FREQ'] == 'WEEKLY');
      $repeat_limit = $weekly ? 52 : 26;
      $repeat_type = $weekly ? t('weekly') : t('monthly');
      if ($repeat_rule['count_child'] > $repeat_limit) {
        return form_set_error('field_date][und][0][rrule][count_child', t("An event that repeats !repeat_type is limited to a maximum of !limit repeats.", array('!limit' => $repeat_limit, '!repeat_type' => $repeat_type)));
      }
    }
    else {
      // When the limit is provided as a date, the end date can be up to one
      // year in the future, but no more.  We'll allow a year and a day,
      // on a leap year (even on non-leap-years), and call that close enough.
      $date_limit = $repeat_rule['until_child']['datetime'];
      $year = $date_limit['year'];
      $month = $date_limit['month'];
      $day = $date_limit['day'];
      $datestring = "$year-$month-$day 12:00:00";
      $epoch = strtotime($datestring);
      $now = time();
      $duration = ($epoch - time()) / ONE_DAY;
      if ($duration > 367) {
        return form_set_error('field_date][und][0][rrule][until_child', t("An event that repeats until a certain date is limited to a maximum of one year of repeats."));
      }
    }
  }
}

function _wk_form_validate_user_may_create_events_for_branch($form, &$form_state) {
  $branch_officer = _wk_is_branch_web_admin();
  // This should never happen, but put in this check just in case.
  // n.b. this validator should only be added for new nodes.
  if (empty($branch_officer)) {
    return form_set_error('taxonomy_vocabulary_2', t("You have not been granted permission to create calendar events.  Only branch group Seneschals and Web Ministers may do this."));
  }
  foreach ($form_state['values']['taxonomy_vocabulary_2'][LANGUAGE_NONE] as $selected_branch) {
    if (!array_key_exists($selected_branch['tid'], $branch_officer)) {
      // n.b. validation should never fail here unless $branch_officer contains
      // multiple branches.  In instances where the user is a Seneschal or Web Minister
      // for only one branch group, then the branch group field (taxonomy_vocabulary_2)
      // is pre-filled with a valid value, and cannot be edited.
      foreach ($branch_officer as $tid) {
        $term = taxonomy_term_load($tid);
        $group_names[] = check_plain($term->name);
      }
      return form_set_error('taxonomy_vocabulary_2', t("You may only create calendar events for the following groups:<ul><li>!group_list</li></ul>", array('!group_list' => implode("</li><li>", $group_names))));
    }
  }
}

function wk_form_alter__regnum_change_entityform_edit_form(&$form, &$form_state) {
  $office_label = '';
  $office_tid = FALSE;
  $group_tid = FALSE;
  $menu = menu_get_item();
  $volunteer = (count($menu['page_arguments']) > 4) ? $menu['page_arguments'][4] : '';
  if (count($menu['page_arguments']) > 2) {
    $group_from_menu = $menu['page_arguments'][2];
    $terms = taxonomy_get_tree(2);
    foreach ($terms as $tinfo) {
      $term = taxonomy_term_load($tinfo->tid);
      $short_name = _wk_term_short_name($term);
      $machine_name = _wk_to_machine_name($short_name);
      if ((strtolower($group_from_menu) == $machine_name) || ($group_from_menu == $term->tid)) {
	      $group_tid = $term->tid;
      }
    }
  }
  if (count($menu['page_arguments']) > 3) {
    $office_from_menu = $menu['page_arguments'][3];
    // Special checking!
    if (($office_from_menu == 'consort') || ($office_from_menu == 'head-of-court')) {
      $volunteer = ucfirst(str_replace('-', ' ', $office_from_menu));
      $office_from_menu = 'heirs'; // TODO: This should be 'regent' if investiture has already happened.
      $office_label = $volunteer;
    }
    $terms = taxonomy_get_tree(3);
    foreach ($terms as $tinfo) {
      $term = taxonomy_term_load($tinfo->tid);
      $short_name = _wk_term_short_name($term);
      $machine_name = _wk_to_machine_name($short_name);
      if ((strtolower($office_from_menu) == $machine_name) || ($office_from_menu == $term->tid)) {
	      $office_tid = $term->tid;
      }
    }
  }

/*
  // If there was no branch, office or volunteer selection, then
  // go to the selection page.
  if (!$office_tid && !$group_tid && empty($volunteer)) {
    drupal_goto('/regnum/select');
  }
*/

  // If the office is pre-filled, then make the office selection
  // field uneditable.
  if ($office_tid) {
    $form['field_office'][LANGUAGE_NONE]['#prefix'] = '<div class="prefilled-taxonomy-tree">';
    $form['field_office'][LANGUAGE_NONE]['#sufix'] = '</div>';
    $form['field_office'][LANGUAGE_NONE]['#default_value'] = array($office_tid => $office_tid);

    $term = taxonomy_term_load($office_tid);
    if (!$office_label) {
      $office_label = $term->name;
    }
    $icon = '';
    $view = field_view_field('taxonomy_term', $term, 'field_badge');
    if (!empty($view)) {
      $view['#label_display'] = 'hidden';
      $icon = render($view);
    }
    $form['field_office']['#prefix'] = '<div id="entityform_regnum_change_form_group_office" class="prefilled-taxonomy-icon"><b>' . $office_label . '</b>' . $icon . '</div>';
  }

  // If the group is pre-filled, then make the group selection
  // field uneditable.
  if ($group_tid) {
    _wk_pre_select_group_in_form($form, $form_state, $group_tid);
  }

  if ($volunteer) {
    if ($volunteer == 'deputy') {
      drupal_set_title('Volunteer');
      $form['#prefix'] = '<p>' . t("Thank you for volunteering!  Please provide us with some personal information, so that we can create an account for you on this site.") . '</p>';
    }
    // hide($form['field_deputy']) does not work well with setting default
    // value; use #access instead.
    $form['field_deputy'][LANGUAGE_NONE]['#default_value'] = true;
    $form['field_deputy']['#access'] = false;

    hide($form['field_type_of_deputy']);
    hide($form['field_purpose_of_change']);
    hide($form['field_institutional_memory_email']);
    hide($form['field_signed_warrant']);
    hide($form['field_effective_date']);
    // 'hide' does not work on date fields.
    // See: https://www.drupal.org/node/1419286#comment-11164431
    $form['field_effective_date']['#access'] = false;
  }

  array_unshift($form['#validate'], '_wk_form_validate_exactly_one_branch_group');
}

/**
 * Restrict the kinds of changes that can be made to calendar event nodes
 * by certain semi-priviledged users (branch group Seneschals and Webministers).
 *
 * @see wk_node_access(), which allows users the ability to create/edit these.
 */
function wk_form_alter__cal_event_node_form(&$form, &$form_state) {
  global $user;
  $make_meeting_practice_adjustments = FALSE;

  // Events must not repeat.  Meetings / practices must repeat.
  array_unshift($form['#validate'], '_wk_form_validate_meetings_are_repeating');

  // Limit date repeats for all users.
  array_unshift($form['#validate'], '_wk_form_validate_repeating_event_limit');

  // The Kingdom Webminister and the Kingdom Seneschal / Calendar deputy
  // have full ability to edit calendar event nodes.  Other users (branch
  // group Seneschals and Web Ministers) have limited editing ability over
  // groups in their branch group only.
  $event_admin = wk_user_access_or_group_member('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID));

  if (!$event_admin) {
    $new_event_form = ($form['nid']['#value'] == NULL);
    $group_tid = FALSE;

    if ($new_event_form) {
      //
      // Semi-priviledged users can only create meetings and practices; they
      // cannot create events.
      //
      hide($form['field_event_type']);
      $form['field_event_type'][LANGUAGE_NONE]['#default_value'] = 1;
      $make_meeting_practice_adjustments = TRUE;

      // Get a list of branch groups the user is seneschal or webminister for.
      $branch_officer = _wk_is_branch_web_admin($account);
      // $branch_officer should never be empty; if $event_admin is FALSE,
      // and $branch_officer is empty, then the user should not have permission
      // to edit this form.
      if (empty($branch_officer)) {
        // TODO: maybe limit per the current domain access domain?
        hide($form['taxonomy_vocabulary_2'][LANGUAGE_NONE]);
        $form['taxonomy_vocabulary_2'][LANGUAGE_NONE]['#prefix'] = t("<b>Access denied.</b>  This should not happen; please inform the Kingdom Webminister.");
      }
      elseif (count($branch_officer) == 1) {
        $group_tid = reset($branch_officer);
      }
      else {
        // Limit the displayed items to those listed in '$branch_officer'
        // (and parents thereof)
        $form['taxonomy_vocabulary_2'][LANGUAGE_NONE]['#entity']->limit_branches = $branch_officer;
      }
      // Insure that the user does not select a disallowed branch group
      array_unshift($form['#validate'], '_wk_form_validate_user_may_create_events_for_branch');
    }
    else {
      //
      // Semi-priviledged users can edit events and meetings / practices,
      // but they cannot change their type.
      //
      hide($form['field_event_type']);
      $event_type = $form['field_event_type'][LANGUAGE_NONE]['#default_value'];

      // Also, the branch group for the event cannot be changed
      // TODO: It would be nice if we could show multiple devices here
      // (e.g. for Mists / Cynagua war, et. al.)
      $group_tid = reset($form['taxonomy_vocabulary_2'][LANGUAGE_NONE]['#default_value']);

      // We'll do different modfications for editing events vs editing
      // meeting / practices.
      if ($event_type == 0) {
        // The date that events are held on cannot be changed by semi-priviledged users.
        $event_date = $form['field_date'][LANGUAGE_NONE][0]['#default_value'];
        // $date_display = _wk_format_date($event_date, 'Y F d');
        $date_display = wk_render_node_field_date($form['#node']);
        $form['field_date']['#prefix'] = t("<b>Event Date:</b> !date", array('!date' => $date_display));
        hide($form['field_date'][LANGUAGE_NONE]);
      }
      else {
        // Allow limited control over meeting / practice date selection
        $make_meeting_practice_adjustments = TRUE;
      }
    }

    // Don't let folks mess with the timezone
    hide($form['field_date'][LANGUAGE_NONE][0]['timezone']);

    if ($make_meeting_practice_adjustments) {
      // We do not use the event site fields for meetings / practices.
      hide($form['field_event_site']);
      // Meetings / practices must repeat; otherwise, they are events.
      $form['field_date'][LANGUAGE_NONE][0]['show_repeat_settings']['#default_value'] = 1;
      //hide($form['field_date'][LANGUAGE_NONE][0]['show_repeat_settings']);

      // Can we un-check and hide field_date[und][0][show_todate]?
      // n.b. the two lines below do not work, as this element is created by the
      // field_date widget later.
      $form['field_date'][LANGUAGE_NONE][0]['show_todate']['#default_value'] = 0;
      hide($form['field_date'][LANGUAGE_NONE][0]['show_todate']);

      // Don't bother with the metadata fields for meeting / practices
      hide($form['field_event_hours']);
      hide($form['field_event_schedule']);
      hide($form['field_site_fee']);
      hide($form['field_feast_fee']);
      hide($form['field_directions']);
    }

    // If the branch group is not editable, then pre-select the one group
    // that is required for this event or meeting / practice.
    if ($group_tid) {
      _wk_pre_select_group_in_form($form, $form_state, $group_tid);
    }
  }
}

/**
 * Make the branch group field uneditable in a form.
 */
function _wk_pre_select_group_in_form(&$form, &$form_state, $group_tid) {
  $form['taxonomy_vocabulary_2'][LANGUAGE_NONE]['#default_value'] = array($group_tid => $group_tid);
  $form['taxonomy_vocabulary_2']['#default_value'] = $group_tid;
  $term = taxonomy_term_load($group_tid);
  $icon = '';
  $view = field_view_field('taxonomy_term', $term, 'field_arms');
  if (!empty($view)) {
    $view['#label_display'] = 'hidden';
    $icon = render($view);
  }
  $form['taxonomy_vocabulary_2']['#prefix'] = '<div id="edit-taxonomy-vocabulary-2" class="prefilled-taxonomy-icon"><b>' . $term->name . '</b>' . $icon . '</div>';

  //
  // Hide the field.
  //
  // Here's the trick.
  //
  // (1) If we use hide($form['taxonomy_vocabulary_2'][LANGUAGE_NONE]),
  // then the field disappears from the form, and its value is not submitted.
  // This is no good, because we need to set the $group_tid per the code above.
  //
  // (2) If we use $form['taxonomy_vocabulary_2']['#access'] = FALSE;,
  // then the submit handler works great, but Drupal will hide the
  // HTML we put into ['taxonomy_vocabulary_2']['#prefix'].  This could
  // work out for us, but we'd then need to put this info into a different
  // form element, and make sure that it is positioned correctly.  Putting
  // it in ['taxonomy_vocabulary_2'] means that our replacement will go
  // wherever the taxonomy_vocabulary_2 was placed.
  //
  // The answer, then, is to remove the access to the sub-control of
  // taxonomy_vocabulary_2 in LANGUAGE_NONE.  This correctly hides the
  // main control, allows the submit handler to work correctly, and
  // still shows our custom HTML badge.
  //
  $form['taxonomy_vocabulary_2'][LANGUAGE_NONE]['#access'] = FALSE;
}

/**
 * Implements hook_form_alter
 */
function wk_form_alter(&$form, &$form_state) {
  $fn = 'wk_form_alter__' . strtr($form['#id'], '-', '_');
  if (function_exists($fn)) {
    $fn($form, $form_state);
  }

  // Search for occurances of checkbox_tree fields that we want to alter.
  wk_form_alter_taxonomy_tree_with_icon_fields($form);

  if (($form['#form_id'] == 'contact_personal_form') || ($form['#form_id'] == 'og_contact_mail_page') || ($form['#form_id'] == 'contact_site_form')) {
    if (!empty($form['mail']['#default_value'])) {
      $form['mail']['#type'] = 'hidden';
      $form['name']['#type'] = 'hidden';
      $form['to']['#type'] = 'hidden';
      $form['#validate'][] = '_wk_form_validate_email_not_changed';
    }
  }

  if (!empty($form['#node_edit_form'])) {
    // This next block is copied from the 'revisioning' module, which for some reason
    // only shows these radios for users with 'administer nodes'.  We allow it for
    // any user who can publish the node.
    $node = &$form['#node'];
    $is_moderated_content = isset($node->revision_moderation)
      ? $node->revision_moderation
      : revisioning_content_is_moderated($form['type']['#value'], $node);
    if (revisioning_user_node_access('publish revisions', $node) || revisioning_user_node_access('edit revisions', $node)) {
      // Expand and move this vertical tab to top, so that it's in user's face
      if (isset($form['menu'])) {
        $form['menu']['#collapsed'] = TRUE;
      }
      $form['revision_information']['#collapsed'] = FALSE;
      $form['revision_information']['#weight'] = -3;

      $options = array();
      if (isset($node->nid)) {
        $options[NO_REVISION] = t('Modify current revision, no moderation');
      }
      $options[NEW_REVISION_NO_MODERATTION]  = t('Create new revision, no moderation');
      $options[NEW_REVISION_WITH_MODERATION] = t('Create new revision and moderate');

      // This radio selection will appear in hook_node_presave as $node->revision_operation
      $form['revision_information']['revision_operation'] = array(
        '#title' => t('Revision creation and moderation options'),
        '#description' => t('Moderation means that the new revision is not publicly visible until approved by someone with the appropriate permissions.'),
        '#type' => 'radios',
        '#options' => $options,
        '#default_value' => isset($node->nid)
          ? (int)$node->revision + (int)$is_moderated_content
          : ($is_moderated_content ? NEW_REVISION_WITH_MODERATION : NEW_REVISION_NO_MODERATTION)
      );
      unset($form['revision_information']['revision']);

      // Add javascript to show/hide the "Published" checkbox if the user
      // presses one of the first two radio buttons. Also updates summary tabs.
      $js_file = drupal_get_path('module', 'revisioning') . '/revision-radios.js';
      drupal_add_js($js_file, array('weight' => 1)); // after node.js
      // If preference specifies that "no moderation" is the default, then change the control default value
      if (variable_get('wk_no_moderation_by_default', TRUE)) {
        $form['revision_information']['revision_operation']['#default_value'] = NEW_REVISION_NO_MODERATTION;
      }
    }
  }

}

function wk_form_alter__domain_overview_form(&$form, &$form_state) {
  global $user;
  //dpm($form);
  //dpm($form_state);
  //dpm($form_state['node']);
  //dpm(current_path());
  if (!user_access('administer domains')) {
    $no_domains = TRUE;
    foreach ($form['domain'] as $key => $info) {
      if (is_array($info) && array_key_exists('values', $info)) {
        $domain = $info['values']['#value'];
        if (!array_key_exists($domain['domain_id'], $user->domain_user)) {
          unset($form['domain'][$key]);
          unset($form['domain_actions'][$key]);
          unset($form['default_domain']['#options'][$key]);
        }
        else {
          $no_domains = FALSE;
        }
      }
    }
    // If the user cannot change the default domain,
    // clear the submit button.
    unset ($form['submit']);
    if ($no_domains) {
      $form['top']['#markup'] = t('You have no domains that you can edit.');
    }
  }
}

function wk_form_alter__domain_form(&$form, &$form_state) {
  if (!user_access('administer domains')) {
    foreach ($form as $key => $info) {
      if (is_array($info) && (array_key_exists('#type', $info))) {
        $form[$key]['#disabled'] = TRUE;
      }
    }
  }
}

function wk_form_alter__domain_theme_form(&$form, &$form_state) {
  if (!user_access('administer domains') && !user_access('administer themes for assigned domains')) {
    $form['submit']['#disabled'] = TRUE;
    $form['intro'] = array('#markup' => t('You do not have permission to change the theme for this domain, but you may configure the theme settings for the selected theme.'));
    foreach ($form['theme'] as $id => $info) {
      if (isset($info['#type']) && ($info['#type'] == 'radio')) {
        if (!$form['theme'][$id]['#default_value']) {
          unset($form['theme'][$id]);
        }
        else {
          $form['theme'][$id]['#disabled'] = TRUE;
        }
      }
    }
  }
}

/**
 * Implementation of hook_block_info().
 */
function wk_block_info() {
  $blocks['wk_related_sites'] = array(
    'info' => t('Related Sites'),
    'cache' => DRUPAL_NO_CACHE,
  );
  $blocks['wk_office_volunteer'] = array(
    'info' => t('Volunteer'),
    'cache' => DRUPAL_NO_CACHE,
  );
  return $blocks;
}

/*
  $site_label = wk_branch_site_label($branch_term);
  $description = strip_tags($branch_term['description']);
  $site_label .= " <span class='site-label-location'>$description</span>";
*/

/**
 * Implementation of hook_block_view().
 */
function wk_block_view($delta = '') {
  global $user;
  $block = array();

  switch ($delta) {
    case 'wk_related_sites':
      $content = '';
      $parent_terms = regnum_domain_parent_term_list();
      if (!empty($parent_terms)) {
        $parent_term_list = wk_branch_site_label_list(array_reverse($parent_terms), array("class" => "site-arms"));
        $parent_list_html = theme_item_list(array('items' => $parent_term_list, 'title' => NULL, 'type' => 'ul', 'attributes' => array()));
        $content = "<span id='parent-sites'>$parent_list_html</span>";
      }
      $site_branch_term = regnum_domain_taxonomy_term();
      $children_terms =  taxonomy_get_children($site_branch_term->tid);
      if (!empty($children_terms)) {
        $children_terms_list = wk_branch_site_label_list($children_terms, array("class" => "site-arms"));
        $children_list_html = theme_item_list(array('items' => $children_terms_list, 'title' => FALSE, 'type' => 'ul', 'attributes' => array()));
        $content .= "<span id='parent-sites'>$children_list_html</span>";
      }
      $block['subject'] = t('Related Sites');
      $block['content'] = $content;
      break;

    case 'wk_office_volunteer':
      $node = menu_get_object();
      if (is_object($node) && isset($node->type) && ($node->type == 'officers')) {
        $text = t("We are always looking for new, enthusiastic volunteers who want to learn more and help out.  If you are interested in the activies of this office, please drop us a line--we'd love to hear from you!");
        if (isset($node->field_volunteer[LANGUAGE_NONE][0])) {
          $text = trim($node->field_volunteer[LANGUAGE_NONE][0]['value']);
        }

        $branch_tid = $node->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['tid'];
        $office_tid = $node->field_office[LANGUAGE_NONE][0]['tid'];

        if (  !empty($text) &&
              ($text != 'n/a') &&
              ($text != 'na') &&
              ($office_tid != HEIRS_TID) &&
              ($office_tid != REGENT_TID) ) {
          $branch_term = taxonomy_term_load($branch_tid);

          $office_term = taxonomy_term_load($office_tid);

          $branch_shortname = strtolower(_wk_term_short_name($branch_term));
          $office_shortname = strtolower(_wk_term_short_name($office_term));

          $block['content'] = drupal_get_form('wk_simple_redirect_button_form', t("Volunteer"), "regnum/$branch_shortname/$office_shortname/volunteer", $text);
        }
      }
      break;

  }
  return $block;
}

function wk_simple_redirect_button_form($form, &$form_state, $label, $url, $text = FALSE) {
  if ($text) {
    $form['description'] = array(
      '#type' => 'item',
      '#markup' => $text,
    );
  }
  $form['url'] = array(
    '#type' => 'hidden',
    '#value' => $url,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => $label,
  );
  return $form;
}

function wk_simple_redirect_button_form_submit($form, &$form_state) {
  $url = $form_state['values']['url'];
  drupal_goto($url);
}

function wk_get_heirs_node($nid) {
  return _wk_get_heirs_or_regent_node($nid, HEIRS_TID, REGENT_TID);
}

function wk_get_royals_node($nid) {
  return _wk_get_heirs_or_regent_node($nid, REGENT_TID, HEIRS_TID);
}

function _wk_get_heirs_or_regent_node($nid, $desired, $other) {
  $node = node_load($nid);

  $branch_tid = $node->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['tid'];
  $office_tid = $node->field_office[LANGUAGE_NONE][0]['tid'];

  if ($office_tid == $desired) {
    return $node;
  }

  if ($office_tid == $other) {
    return _wk_get_officer_node($branch_tid, $desired);
  }

  return FALSE;
}

function wk_officer_promote_form($form, &$form_state, $nid) {
  $node = wk_get_heirs_node($nid);

  if ($node) {
    return wk_officer_promote_heirs($form, $form_state, $node);
  }
  else {
    return wk_officer_promote($form, $form_state, $nid);
  }
}

function wk_officer_promote($form, &$form_state, $nid) {
  $node = node_load($nid);
  $primary_officer = user_load($node->uid);
  $primary_officer_title = FALSE;

  // @see wk_officer_promote_heirs()
  $query = new EntityFieldQuery();
  $query
    ->entityCondition("entity_type", "og_membership", "=")
    ->propertyCondition("gid", $node->nid, "=");
  $result = $query->execute();

  $deputies = array();
  foreach ($result['og_membership'] as $mid => $info) {
    $minfo = og_membership_load($mid);
    $membership_title = $minfo->field_type_of_deputy[LANGUAGE_NONE][0]['value'];
    $membership_weight = $minfo->field_weight[LANGUAGE_NONE][0]['value'];
    $uid = $minfo->etid;
    if ($uid == $node->uid) {
      $primary_officer_title = $membership_title;
    }
    else {
      $member = user_load($uid);
      if ($member) {
        $deputies[$uid] = array(
          'uid' => $uid,
          'weight' => $membership_weight,
          'name' => $member->name,
          'title' => $membership_title,
        );
      }
    }
  }
  /*
  dpm($deputies);
  // Sort the user list by weight.
  usort($deputies, function ($a, $b) {
    return $a['weight'] - $b['weight'];
  });
  dpm($deputies);
  */

  // Drupal radio buttons are sorted by key, so we
  // will concatinate the deputy's weight with their
  // uid to create a unique value that will be appropriately
  // sorted.
  $names = array();
  foreach ($deputies as $key => $uinfo) {
    $names[$uinfo['weight'] . '.' . $uinfo['uid']] = $uinfo['name'] . ', ' . $uinfo['title'];
  }

  if (!empty($names)) {
    ksort($names);
    $form['deputies'] = array(
      '#title' => t('Current Deputies'),
      '#description' => t('Select the new person who has assumed this office.'),
      '#type' => 'radios',
      '#options' => $names,
      '#default_value' => reset(array_keys($names)),
    );

    if ($primary_officer) {
      $form['retain'] = array(
        '#type' => 'checkbox',
        '#checked' => FALSE,
        '#default_value' => $primary_officer->uid,
        '#title' => t("Retain %officer as a Deputy", array('%officer' => $primary_officer->name)),
      );
    }
    if ($primary_officer_title) {
      $form['primary_officer_title'] = array(
        '#type' => 'hidden',
        '#value' => $primary_officer_title,
      );
    }
    $form['nid'] = array(
      '#type' => 'hidden',
      '#value' => $nid,
    );
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Promote'),
    );
  }

  return $form;
}

function wk_officer_promote_heirs($form, &$form_state, $node) {
  // Get a list of all of the members of the group.
  // We use an EntityFieldQuery to find all of the membership
  // objects, because we want access to the membership
  // title and weight.  If we only wanted the user ids,
  // we could use og_get_group_members_properties().
  // @see wk_officer_promote_form_submit()
  $query = new EntityFieldQuery();
  $query
    ->entityCondition("entity_type", "og_membership", "=")
    ->propertyCondition("gid", $node->nid, "=");
  $result = $query->execute();

  foreach ($result['og_membership'] as $mid => $info) {
    $minfo = og_membership_load($mid);
    $membership_title = $minfo->field_type_of_deputy[LANGUAGE_NONE][0]['value'];
    $membership_weight = $minfo->field_weight[LANGUAGE_NONE][0]['value'];
    $uid = $minfo->etid;

    $new_title = $membership_title;

    $replacements = array(
      'Crown Princess' => 'Queen of the West',
      'Crown Prince' => 'King of the West',
      'Lord of the Swan' => 'Prince of Cynagua',
      'Lady of the Swan' => 'Princess of Cynagua',
      'Lord of the Mists' => 'Prince of the Mists',
      'Lady of the Mists' => 'Princess of the Mists',
    );

    $new_title = str_replace(array_keys($replacements), array_values($replacements), $new_title);

    $member = user_load($uid);
    $form['title-' . $uid] = array(
      '#type' => 'textfield',
      '#title' => $member->name . ', ' . $membership_title,
      '#default_value' => $new_title,
      '#size' => 60,
      '#maxlength' => 128,
      '#required' => TRUE,
      '#weight' => $membership_weight,
    );
    $form['weight-' . $uid] = array(
      '#type' => 'hidden',
      '#value' => $membership_weight,
    );
  }
  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $node->nid,
  );
  if (count($result['og_membership']) > 0) {
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Promote'),
    );
  }
  else {
    drupal_set_message(t("No heirs to promote!  Maybe someone should hold a tournament!"), 'warning');
  }
  return $form;
}

function wk_officer_promote_form_submit($form, &$form_state) {
  $nid = $form_state['values']['nid'];
  $heirs_node = wk_get_heirs_node($nid);

  $node = wk_get_heirs_node($nid);
  if ($heirs_node) {
    return wk_officer_promote_heirs_submit($form, $form_state, $heirs_node);
  }
  else {
    return wk_officer_promote_submit($form, $form_state);
  }
}

function wk_officer_promote_submit($form, &$form_state) {
  $nid = $form_state['values']['nid'];
  $primary_officer_title = $form_state['values']['primary_officer_title'];
  $retain = $form_state['values']['retain'];
  $new_officer_parts = explode('.', $form_state['values']['deputies']);

  $officer_uid = array_pop($new_officer_parts);

  // dpm($retain);
  // dpm($officer_uid);

  $new_officer = user_load($officer_uid);
  $officer_node = node_load($nid);


  regnum_assign_user_to_officer_node($new_officer, $officer_node, $primary_officer_title, FALSE, $retain);

}

function wk_officer_promote_heirs_submit($form, &$form_state, $heirs_node) {
  $nid = $form_state['values']['nid'];
  $regent_node = wk_get_royals_node($nid);

  // Get a list of all of the UIDs of the group
  // members.  If we also wanted the membership
  // title and weight, we could use a EntityFieldQuery
  // instead.  @see wk_officer_promote_form()
  $regent_uids = og_get_group_members_properties($regent_node, array(), 'members', 'node');

  // Build a list and sort it, so that
  // we handle the regent (weight -10) first
  $user_list = array();
  foreach ($form_state as $key => $info) {
    if (substr($key, 0, 6) == 'title-') {
      $uid = substr($key, 6);
      $title = $info['#value'];
      $weight = $form_state['values']['weight-' . $uid];

      $user_list[] = array(
        'uid' => $uid,
        'weight' => $weight,
        'title' => $title);
    }
  }

  // Sort the user list by weight.
  usort($user_list, function ($a, $b) {
    return $a['weight'] - $b['weight'];
  });

  // The first user will be the Regent
  $asDeputy = FALSE;
  foreach ($user_list as $key => $uinfo) {
    $uid = $uinfo['uid'];
    $user = user_load($uid);

    $retain = FALSE;
    regnum_assign_user_to_officer_node($user, $regent_node, $uinfo['title'], $asDeputy, $retain, $uinfo['weight']);

    // Once the user has been moved to the
    // regent office, remove them from the
    // heirs office.
    regnum_remove_user_from_office($heirs_node, $uid);
    // All the rest will be "deputies" (consort or head of court).
    $asDeputy = TRUE;
  }

  // Remove all of the former regents from the group.
  foreach ($regent_uids as $uid) {
    regnum_remove_user_from_office($regent_node, $uid);
  }
}

function wk_reject_date_request($form, &$form_state, $id) {
  $date_request = new EntityDrupalWrapper('entityform', $id);
  $title = $date_request->field_event_name->value();
  $text = t("Would you really like to delete the event request %title?  It will be permanently removed from the system.  The original requestor will not be notified.", array('%title' => $title));
  $form['description'] = array(
    '#type' => 'item',
    '#markup' => $text,
  );
  $form['request-id'] = array(
    '#type' => 'hidden',
    '#value' => $id,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Delete',
  );
  return $form;
}

function wk_reject_date_request_submit($form, &$form_state) {
  $id = $form_state['values']['request-id'];
  $date_request = new EntityDrupalWrapper('entityform', $id);
  $date_request->delete();
  drupal_goto('approve-date-requests');
}

/**
 * Don't allow users to change their personal email address
 * on contact forms.  This validate function will only be set
 * if the user was logged in; anonymous users get to put whatever
 * they want here.
 */
function _wk_form_validate_email_not_changed($form, &$form_state) {
  global $user;
  if ($form_state['values']['mail'] != $user->mail) {
    form_error($form, t('You may not change your email address on the contact form.'));
  }
}

/**
 * Implements hook_block_view_alter
 */
function wk_block_view_alter(&$data, $block) {
  // The officers list block 1 is a view that shows
  // the list of officers in a given office.  The view
  // is configured to show on nodes in a group; however,
  // we only want it to display on the top-level group
  // node.  Therefore, we test explicitly for node type
  // of 'officers', and remove the block for all other
  // node types.
  if (($block->delta == "officers_list-block_1") || ($block->delta == 'wk_office_volunteer')) {
    $node = menu_get_object();
    $menu = menu_get_item();
    if (($node && $node->type != 'officers') || ($menu && $menu['path'] != 'node/%')) {
      $data['content'] = FALSE;
    }
  }
  /*
  // Example from drupal.org documentation:
  // Add a theme wrapper function defined by the current module to all blocks
  // provided by the "somemodule" module.
  if (is_array($data['content']) && $block->module == 'somemodule') {
    $data['content']['#theme_wrappers'][] = 'mymodule_special_block';
  }
  */
}

/*
// not working; leaving here to try again later
function wk_admin_menu_output_alter(&$content) {
  $node = menu_get_object();
  if ($node) {
    $content['menu']['node/add']['node/add/page']['#options']['query'] = array('og_group_ref' => $node->nid);
  }
  //var_export($content);
}
*/

/**
 * Implement hook_domain_conf()
 */
function wk_domain_conf() {
  $form['wk'] = array(
    '#type' => 'fieldset',
    '#title' => t('Copyright'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['wk']['wk_copyright_base_year'] = array(
    '#type' => 'textfield',
    '#title' => t('Site copyright base year'),
    '#default_value' => variable_get('wk_copyright_base_year', ''),
    '#size' => 30,
    '#maxlength' => 255,
    '#description' => t('The first year that material was placed on this site. The token [site:copyright] will result in a range of years spanning from the base year to the current year (e.g. 2010-2013).')
  );
  return $form;
}

/**
 * Implements hook_permission().
 */
function wk_permission() {
  $permissions = array(
    'promote officers' => array(
      'title' => t('Promote officers in any branch group'),
    ),
    'approve calendar requests' => array(
      'title' => t('Approve calendar date requests'),
    ),
    'configure calendar requests' => array(
      'title' => t('Configure settings for calendar date requests'),
    ),
    'administer site configuration for assigned domains' => array(
      'title' => t('Administer site configuration for assigned domains'),
      'restrict access' => TRUE,
    ),
    'administer menu for assigned domains' => array(
      'title' => t('Administer menu for assigned domains'),
    ),
    'administer themes for assigned domains' => array(
      'title' => t('Administer themes for assigned domains'),
      'description' => t('Select the theme for assigned domains, and adjust theme configuration.'),
    ),
    'administer theme configuration for assigned domains' => array(
      'title' => t('Administer theme configuration for assigned domains'),
      'description' => t("Allow a user who cannot change the domain theme to configure the selected theme's configuration."),
    ),
    'view/request own organization email' => array(
      'title' => t('View and request your own Organization email'),
      'description' => t("Allow users to see their own Organization email, or make a request to create one."),
    ),
    'view/request organization email for any user' => array(
      'title' => t('View and request Organization email for any user'),
      'description' => t("See the Organization email for any user, and make a request to create on on behalf of any user."),
    ),
  );
  return $permissions;
}

/**
 * Implements hook_menu
 */
function wk_menu() {
  $items = array();

  $items['officers/%'] = array(
    'title' => 'Officer List',
    'description' => 'Show all of the officers for a specified branch group.',
    'page callback' => 'wk_officer_list',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  // TODO: better permissions (
  //   - allow Principality Seneschals to promote Prince and Princess
  //   - don't re-use 'approve calendar requests'
  $items['node/%/promote'] = array(
    'title' => 'Promote',
    'description' => 'After Coronation / Investiture, make the Heirs the new Royals.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_officer_promote_form', 1),
    'access callback' => 'wk_user_access_or_officer_in_nodes_branch',
    'access arguments' => array('promote officers', 1, array(WEBMINISTER_TID, SENESCHAL_TID), 'officers'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 18,
  );
  // TODO: make separate permissions
  $items['approve-email-requests'] = array(
    'title' => 'Approve Email Address Requests',
    'description' => 'Approve or deny all submitted email address requests.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_email_request_approval_form'),
    'access callback' => 'wk_user_access_or_group_member',
    'access arguments' => array('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID)),
  );
  $items['approve-date-requests'] = array(
    'title' => 'Approve Calendar Date Requests',
    'description' => 'Approve or deny all submitted calendar date requests.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_date_request_multiple_approval_form'),
    'access callback' => 'wk_user_access_or_group_member',
    'access arguments' => array('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID)),
  );
  $items['approved-date-requests'] = array(
    'title' => 'Approved Calendar Date Requests',
    'description' => 'Show approved calendar date requests.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_approved_date_requests'),
    'access callback' => 'wk_user_access_or_group_member',
    'access arguments' => array('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID)),
  );
  $items['approve-date-request/%'] = array(
    'title' => 'Approve Calendar Date Request',
    'description' => 'Approve or deny a specific submitted calendar date request.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_date_request_approval_form', 1),
    'access callback' => 'wk_user_access_or_group_member',
    'access arguments' => array('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID)),
  );
  $items['approve-date-request/%/%'] = array(
    'title' => 'Approve Calendar Date Request for a specific date',
    'description' => 'Approve a specific submitted calendar date requests on one of the submitted days.',
    'page callback' => 'wk_approve_date_request_on_date',
    'page arguments' => array(1, 2),
    'access callback' => 'wk_user_access_or_group_member',
    'access arguments' => array('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID)),
  );
  $items['reject-date-request/%'] = array(
    'title' => 'Reject Calendar Date Request',
    'description' => 'Reject a specific submitted calendar date request.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_reject_date_request', 1),
    'access callback' => 'wk_user_access_or_group_member',
    'access arguments' => array('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID)),
  );
  $items['calendar-status'] = array(
    'title' => 'Calendar Status',
    'description' => 'Show whether the calendar is open for new date requests',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_calendar_status'),
    'access callback' => TRUE,
  );
  $items['calendar-status/%'] = array(
    'title' => 'Calendar Status',
    'description' => 'Show whether the calendar is open for new date requests',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_calendar_status', 1),
    'access callback' => TRUE,
  );
  $items['admin/config/calendar-requests'] = array(
    'title' => 'Calendar Status Settings',
    'description' => 'Configure calendar date request settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_calendar_request_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('configure calendar requests'),
  );
  $items['users/%/mail/reset'] = array(
    'title' => 'Organization email password reset',
    'description' => 'Reset the password used to log into your westkingdom.org Google Apps account.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_google_apps_password_reset', 1),
    'access callback' => 'wk_user_access_or_self',
    'access arguments' => array('administer users', 1),
  );
/*
  // "mail" tab on group node
  $items['node/%wk_og_group_node/mail'] = array(
    'title' => 'Mail',
    'page callback' => 'wk_og_mail_page',
    'access callback' => 'wk_can_view_mail',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 20,
  );

  // read one email message in a group
  $items['node/%wk_og_group_node/mail/%'] = array(
    'title' => 'Mail Message',
    'page callback' => 'wk_og_mail_view',
    'access callback' => 'wk_can_view_mail',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
  );
*/
  return $items;
}


/**
 * Load a node object based on a menu arg
 *
 * Menu loader function that will return a node object.
 */
function wk_og_group_node_load($arg) {
  if (!is_numeric($arg)) {
    return FALSE;
  }
  if ($node = entity_load_single('node', $arg)) {
    if (og_is_group_type('node', $node->type)) {
      return $node;
    }
  }
  return FALSE;
}

function wk_og_permission() {
  return array(
    'access og mail tab' => array(
      'title' => t('access og mail tab'),
      'description' => t('Read email archives for the group.'),
    ),
  );
}

function wk_can_view_mail($node) {
  if (og_user_access('node', $node->nid, 'access og mail tab')) {
    return TRUE;
  }
}

function wk_og_mail_view() {
  $gid = arg(1);
  $message_number = arg(3);
  $group_node = node_load($gid);
  $list_name = wk_group_email_list_name($group_node);
  drupal_set_title(t("Message !number in list '!list':", array('!number' => $message_number, '!list' => $list_name)));
  $message_content = trim(wk_get_message_content($list_name, $message_number));
  if (empty($message_content)) {
    return t("Message not found.");
  }
  return '<pre>' . check_plain($message_content) . '</pre>';
}

function wk_og_mail_page() {
  $gid = arg(1);
  $group_node = node_load($gid);
  $list_name = wk_group_email_list_name($group_node);

  $list_messages = wk_show_list_messages($list_name);
  $rows = array();
  foreach (explode("\n", $list_messages) as $one_message) {
    $message_info = explode("\t", $one_message);
    if (count($message_info) == 4) {
      $message_number = array_shift($message_info);
      // $message_info[2] =
      $rows[] = array(
        check_plain($message_info[0]),
        check_plain($message_info[1]),
        l($message_info[2], "node/$gid/mail/$message_number"),
      );
    }
  }
  if (empty($rows)) {
    return t("No messages in this forwarding list.");
  }
  else {
    $header = array(
      array('data' => t("Date"), 'field' => 'date'),
      array('data' => t("From"), 'field' => 'from'),
      array('data' => t("Subject"), 'field' => 'subject')
    );
    $table = array('header' => $header, 'rows' => $rows);
    return theme('table', $table);
  }
}

// TODO:  wk_get_coronations_and_investitures will
// return all coronations and investitures that
// have happened in the recent past.  We could periodically
// (e.g. every Sunday, maybe) call this from cron,
// and automatically promote all members of the
// corresponding 'heirs' nodes to be members of the associated
// 'royalty' node instead.
function wk_get_coronations_and_investitures() {
  define("ACTIVITY_CORONATION_INVESTITURE", 127);

  // Look for events this year that are in the past
  // (or are happening right now)
  $year = date("Y");
  $month = date("m");
  $day = date("d");
  $after_date = $year . '-01-01T00:00:00';
  $before_date = $year . '-' . $month . '-' . $day . 'T00:00:00';

  return wk_get_events_with_activities(ACTIVITY_CORONATION_INVESTITURE, $after_date, $before_date);
}

function _wk_debug_coronations_and_investitures() {
  $nids = wk_get_coronations_and_investitures();
  $result = array();
  foreach ($nids as $nid) {
    $node = node_load($nid);
    $result[$nid] = $node->title;
  }
  return $result;
}

function wk_get_events_with_activities($activity, $after_date, $before_date) {
  $query = new EntityFieldQuery();
  $query = $query->entityCondition('entity_type','node')
    ->entityCondition('bundle', array('cal_event'))
    ->fieldCondition('field_activities', 'tid', $activity, '=')
    ->fieldCondition('field_event_type', 'value', 0, '=')
    ->fieldCondition('field_date', 'value', $after_date, '>')
    ->fieldCondition('field_date', 'value', $before_date, '<')
    ->propertyCondition('status', 1);
  $entities = $query->execute();

  $nids = array();
  if (!empty($entities)) {
    $nids = array_keys($entities['node']);
  }
  return $nids;
}

function wk_calendar_request_settings($form, &$form_state) {
  $activity_tree = taxonomy_get_tree(4);
  $form += _wk_calendar_request_settings_subtree($activity_tree, 0);
  $form['save'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#submit' => array('_wk_save_calendar_request_settings'),
  );

  return $form;
}

function _wk_save_calendar_request_settings($form, &$form_state) {
  $new_settings = array();
  foreach ($form_state['values'] as $id => $value) {
    // Handle the 'k-###' and 'p-###' checkboxes
    if ($id[1] == '-') {
      if ($value) {
        $kind = $id[0];
        $tid = substr($id, 2);
        $new_settings[$kind][$tid] = $tid;
      }
    }
  }
  variable_set('wk-calendar-request-settings', $new_settings);
}

function _wk_calendar_request_settings_subtree($activity_tree, $parent, $level = 0) {
  $items = array();
  $calendar_request_settings = _wk_calendar_request_get_settings();
  foreach ($activity_tree as $index => $item) {
    if (in_array($parent, $item->parents)) {

      $items['k-' . $item->tid] = array(
        '#type' => 'checkbox',
        '#attributes' => array('class' => array('kingdom-cal-req-setting')),
        '#checked' => isset($calendar_request_settings['k'][$item->tid]),
        '#default_value' => isset($calendar_request_settings['k'][$item->tid]),
        '#prefix' => "",
        '#suffix' => "",
      );
      $items['p-' . $item->tid] = array(
        '#type' => 'checkbox',
        '#attributes' => array('class' => array('principality-cal-req-setting')),
        '#checked' => isset($calendar_request_settings['p'][$item->tid]),
        '#default_value' => isset($calendar_request_settings['p'][$item->tid]),
        '#prefix' => "",
        '#suffix' => "",
      );
      $items['x-' . $item->tid] = array(
        '#title' => str_pad('', $level * 18, '&nbsp;', STR_PAD_LEFT) . $item->name,
        '#type' => 'checkbox',
        '#attributes' => array('class' => array('other-kingdoms-cal-req-setting')),
        '#checked' => isset($calendar_request_settings['x'][$item->tid]),
        '#default_value' => isset($calendar_request_settings['x'][$item->tid]),
        '#prefix' => "",
        '#suffix' => "<div class='after-cal-req-setting'></div>",
      );
      $items += _wk_calendar_request_settings_subtree($activity_tree, $item->tid, $level + 1);
    }
  }
  return $items;
}

function _wk_calendar_request_get_settings() {
  return variable_get('wk-calendar-request-settings',
    array(
      /*
      'k' => array(141 => 141),
      'p' => array(141 => 141),
      'x' => array(141 => 141),
      */
    ));
}

function _wk_get_calendar_events_for_branch($year) {
  $start_date = $year . '-01-01T00:00:00';
  $end_date = $year + 1 . '-01-01T00:00:00';
  return _wk_get_calendar_events_for_branch_in_range($start_date, $end_date);
}

function _wk_get_calendar_events_for_branch_in_range($start_date, $end_date) {
  $nids = array();
  $query = new EntityFieldQuery();
  // TODO: group by taxonomy_vocabulary_2
  $query = $query->entityCondition('entity_type','node')
    ->entityCondition('bundle', array('cal_event'))
    ->propertyCondition('status', 1)
    ->fieldCondition('field_event_type', 'value', 0, '=')
    ->fieldCondition('field_date', 'value', $start_date, '>')
    ->fieldCondition('field_date', 'value', $end_date, '<');

  $branches = array();
  $entities = $query->execute();
  if (!empty($entities)) {
    $nids = array_keys($entities['node']);
    $nodes = wk_load_nodes($nids);
    foreach ($nodes as $nid => $node) {
      $tid = $node->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['tid'];
      if (array_key_exists($tid, $branches)) {
        ++$branches[$tid];
      }
      else {
        $branches[$tid] = 1;
      }
    }
  }
  return $branches;
}

function _wk_get_calendar_event_nids($year, $branch = FALSE) {
  $start_date = $year . '-01-01T00:00:00';
  $end_date = $year + 1 . '-01-01T00:00:00';
  return _wk_get_calendar_event_nids_in_range($start_date, $end_date, $branch);
}

function _wk_get_calendar_event_nids_in_range($start_date, $end_date, $branch = FALSE) {
  $nids = array();
  $query = new EntityFieldQuery();
  $query = $query->entityCondition('entity_type','node')
    ->entityCondition('bundle', array('cal_event'))
    ->propertyCondition('status', 1)
    ->fieldCondition('field_event_type', 'value', 0, '=')
    ->fieldCondition('field_date', 'value', $start_date, '>')
    ->fieldCondition('field_date', 'value', $end_date, '<')
    ->fieldOrderBy('field_date', 'value');
  if ($branch) {
    if (is_array($branch)) {
      $query = $query->fieldCondition('taxonomy_vocabulary_2', 'tid', $branch, 'IN');
    }
    else {
      $query = $query->fieldCondition('taxonomy_vocabulary_2', 'tid', $branch, '=');
    }
  }

  $entities = $query->execute();

  if (!empty($entities)) {
    $nids = array_keys($entities['node']);
  }
  return $nids;
}

function wk_user_access_or_officer_in_nodes_branch($permission, $nid, $office_list, $content_type = FASLE) {
  $node = node_load($nid);
  if (!$node) {
    return FALSE;
  }
  // If the content type isn't correct, this menu should never appear for this node type
  if ($content_type && ($node->type != $content_type)) {
    return FALSE;
  }
  // Similarly, if there is no branch group for this node, never show 'promote'
  if (!isset($node->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['tid'])) {
    return FALSE;
  }
  // If this menu might appear, always show it for users with the '... for all branch groups' permission
  if (user_access($permission)) {
    return TRUE;
  }
  // Otherwise, we'll look at the current user's office list, and if
  // any of these match one of the designated officers for the
  // branch that this node is for, then access is allowed.
  $branch_tid = $node->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['tid'];
  foreach ($office_list as $office_tid) {
    $branch_tid_list = _wk_is_officer($office_tid);
    if (in_array($branch_tid, $branch_tid_list)) {
      return TRUE;
    }
  }
  // Otherwise, access is not allowed.
  return FALSE;
}

function wk_user_access_or_self($permission, $uid) {
  global $user;
  if (user_access($permission)) {
    return TRUE;
  }
  return ($user->uid && ($user->uid == $uid));
}

function wk_user_access_or_group_member($permission, $group_list) {
  if (user_access($permission)) {
    return TRUE;
  }
  foreach ($group_list as $gid) {
    if (og_is_member('node', $gid)) {
      return TRUE;
    }
  }
  return FALSE;
}

// Return the list of nodes that should go on next year's
// calendar during the initial planning phase, prior to opening
// the calendar to branch groups.
function wk_events_for_next_years_calendar($year) {
  $result = array();
  $principalities = wk_children_of_branch_tids(KINGDOM_OF_THE_WEST_TID);
  $other_kingdoms = wk_children_of_branch_tids(SOCIETY_TID);
  $event_nids = _wk_get_calendar_event_nids($year, array_merge(array(KINGDOM_OF_THE_WEST_TID), $principalities, $other_kingdoms));
  return wk_load_nodes($event_nids);
}

// What year is already open for all events?
function wk_calendar_year_open_for_all_events() {
  $result = 0;

  // If there is no information about the status of the calendar, or if
  // it is out of date, then the calendar will automatically open for all
  // events on the first day of that year.  This is the "default year",
  // and we will never return a result less than this.
  $default_year = date("Y");
  // The calendar will open for all events on a certain date and time;
  // if the current date and time is past this milestone, then the calendar
  // is open for all events for the year AFTER the time and date the
  // milestone occurred in.
  $open_for_all_milestone = variable_get('calendar-open-for-all', 0);
  if ($open_for_all_milestone) {
    if (time() > $open_for_all_milestone) {
      $result = date("Y", $open_for_all_milestone) + 1;
    }
  }
  return max($default_year, $result);
}

function wk_calendar_year_of_preparation() {
  $open_year = wk_calendar_year_open_for_all_events();
  switch (wk_calendar_status_for_next_year()) {
    case CALENDAR_STATUS_CLOSED:
      return $open_year;
    case CALENDAR_STATUS_PREPARING:
    case CALENDAR_STATUS_ONE_EVENT:
    case CALENDAR_STATUS_TWO_EVENTS:
      return $open_year + 1;
  }
}

// What is the status for the calendar year that comes after
// the year returned by wk_calendar_year_open_for_all_events?
//
// CLOSED - no one can make any calendar date requests for next year.
//
// PREPARING - like closed, most groups cannot make date requests for
// next year.  During this phase, the Kingdom Seneschal and Calendar
// deputy place the required events for the Kingdom on the calendar.
//
// ONE EVENT - every branch group may request a single event.  This is
// in addition to any required events already on the calendar (i.e. for
// principalities).
//
// TWO EVENTS - like the ONE EVENT phase, but each group may request
// a second event, if desired.
//
// After the ONE EVENT phase, the calendar opens for all events -- by
// bumping wk_calendar_year_open_for_all_events() by one year, and
// reseting to CLOSED for the next year.
function wk_calendar_status_for_next_year() {
  $result = CALENDAR_STATUS_CLOSED;
  $open_for_all_year = wk_calendar_year_open_for_all_events();
  $open_for_all_milestone = variable_get('calendar-open-for-all', 0);
  $preparing_milestone = variable_get('calendar-preparing', 0);
  $open_one_event_milestone = variable_get('calendar-open-for-one', 0);
  $open_two_events_milestone = variable_get('calendar-open-for-two', 0);

  if ((date("Y", $preparing_milestone) >= $open_for_all_year) && (time() > $preparing_milestone)) {
    $result = CALENDAR_STATUS_PREPARING;
  }

  if ((date("Y", $open_one_event_milestone) >= $open_for_all_year) && (time() > $open_one_event_milestone)) {
    $result = CALENDAR_STATUS_ONE_EVENT;
  }
  if ((date("Y", $open_two_events_milestone) >= $open_for_all_year) && (time() > $open_two_events_milestone)) {
    $result = CALENDAR_STATUS_TWO_EVENTS;
  }

  return $result;
}

function wk_calendar_open_dates() {
  $result = array();
  $open_for_all_year = wk_calendar_year_open_for_all_events();
  $candidate[CALENDAR_STATUS_ONE_EVENT] = variable_get('calendar-open-for-one', 0);
  $candidate[CALENDAR_STATUS_TWO_EVENTS] = variable_get('calendar-open-for-two', 0);
  $candidate[CALENDAR_STATUS_ALL_EVENTS_NEXT_YEAR] = variable_get('calendar-open-for-all', 0);

  foreach ($candidate as $key => $milestone) {
    if ((date("Y", $milestone) >= $open_for_all_year) && (time() < $milestone)) {
      $result[$key] = $milestone;
    }
  }

  return $result;
}

function wk_delta_time($milestone, $start_time = 0) {
  $delta_message = '';
  if (!$start_time) {
    $start_time = time();
  }

  $delta_time = $milestone - $start_time;
  // Base requirements: time remaining > 0 and less than ten days
  if (($delta_time > 0) && ($delta_time < 10*ONE_DAY)) {
    $days = floor($delta_time / ONE_DAY);
    $remainder = $delta_time % ONE_DAY;
    $hours = floor($remainder / ONE_HOUR);
    $remainder = $remainder % ONE_HOUR;
    $minutes = floor($remainder / ONE_MINUTE);
    $seconds = $remainder % ONE_MINUTE;
    $delta_message = t("!days days and !hours hours", array('!days' => $days, '!hours' => $hours));
    if ($days < 2) {
      $hours = $hours + (($days * ONE_DAY) / ONE_HOUR);
      $delta_message = t("!hours hours and !minutes minutes", array('!hours' => $hours, '!minutes' => $minutes));
      if ($hours < 2) {
        $minutes = $minutes + (($hours * ONE_HOUR) / ONE_MINUTE);
        $delta_message = t("!minutes minutes and !seconds seconds", array('!minutes' => $minutes, '!seconds' => $seconds));
      }
    }
  }

  return $delta_message;
}

function _wk_earliest_event_request_data() {
  $year = date("Y");
  $month = date("m");
  $day = date("d");

  // The policy is that you must request a date prior to the
  // 15th of the month that is TWO months before your event
  // date.  This is because the event must be published in
  // the Page in order to be a recognized event, and the Page
  // submission deadline is prior to the 1st of the month
  // prior to the issue's publication date.

  $delta_month = 2 + ($day > 15);

  $month += $delta_month;
  if ($month > 12) {
    $month -= 12;
    $year++;
  }

  return strtotime("$year-$month-1 12:00:00");
}


function wk_calendar_status($form, &$form_state, $branch_group = NULL) {
  global $user;
  if (!$user->uid) {
    drupal_set_message(t("It is recommended that you <a href='!login'>log in</a> to use this form.  If you are a Seneschal without an account yet, please record your office on the <a href='!regnum'>Regnum</a> form.", array('!login' => '/user/login', '!regnum' => '/regnum')), 'warning');
  }
  $status_messages = array(
    CALENDAR_STATUS_CLOSED => t("Not open yet."),
    CALENDAR_STATUS_PREPARING => t("Preparing to open."),
    CALENDAR_STATUS_ONE_EVENT => t("Open for one event request per group."),
    CALENDAR_STATUS_TWO_EVENTS => t("Open for up to two event requests per group."),
  );
  $notice_messages = array(
    CALENDAR_STATUS_ONE_EVENT => t("open for <b>ONE EVENT</b> per group"),
    CALENDAR_STATUS_TWO_EVENTS => t("open for <b>UP TO TWO EVENTS</b> per group"),
    CALENDAR_STATUS_ALL_EVENTS_NEXT_YEAR => t("open for any number of events"),
  );
  $notice_weights = array(
    CALENDAR_STATUS_ONE_EVENT => 140,
    CALENDAR_STATUS_TWO_EVENTS => 141,
    CALENDAR_STATUS_ALL_EVENTS_NEXT_YEAR => 142,
  );
  $open_year = wk_calendar_year_open_for_all_events();
  $next_years_status = wk_calendar_status_for_next_year();
  $this_year = date("Y");
  $earliest_epoch = _wk_earliest_event_request_data();
  $earliest_date = _wk_format_date($earliest_epoch, 'D, d F Y');
  $form['status-summary'] = array(
    '#markup' => t('<p><b>Calendar status for !open_year:</b> Open for all events; however, it is <i>too late</i> to request any date prior to !earliest.</p>', array('!open_year' => $open_year, '!next_year' => $open_year + 1, '!msg' => $status_messages[$next_years_status], '!earliest' => $earliest_date)),
  );
  if ($open_year == $this_year) {
    $form['next-year-summary'] = array(
      '#markup' => t('<p><b>Calendar status for !next_year:</b> !msg</p>', array('!open_year' => $open_year, '!next_year' => $open_year + 1, '!msg' => $status_messages[$next_years_status])),
    );
  }
  $open_dates = wk_calendar_open_dates();
  foreach($open_dates as $key => $milestone) {
    if (array_key_exists($key, $notice_messages)) {
      $delta_message = wk_delta_time($milestone);
      if (!empty($delta_message)) {
        $delta_message = t(" - in !delta_message", array('!delta_message' => $delta_message));
      }
      $formatted_milestone = _wk_format_date($milestone, 'D, d F Y \a\t H:i');
      $formatted_milestone = str_replace(array(' 00:00', ' 12:00'), array(' ' . t("Midnight"), ' ' . t("Noon")), $formatted_milestone);
      $form['notices']['notice-' . $key] = array(
        '#markup' => t('<p>The calendar will !message on !milestone !delta</p>', array('!milestone' => $formatted_milestone, '!message' => $notice_messages[$key], '!delta' => $delta_message)),
        '#weight' => $notice_weights[$key],
      );
    }
  }
  $fn = 'wk_calendar_status_' . strtolower($next_years_status);
  $form = $fn($form, $form_state, isset($branch_group) ? array($branch_group) : NULL);

  if(wk_user_access_or_group_member('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID))) {
    $include_date_set_button = ($next_years_status == CALENDAR_STATUS_PREPARING);
    if ($include_date_set_button) {
      $action = t("Select");
      $default_date = $open_year . '-07-06 00:00:00'; // TODO: First Monday in July after July 4th.
      if (array_key_exists(CALENDAR_STATUS_ONE_EVENT, $open_dates)) {
        $default_date = date("Y-m-d H:i:s", $open_dates[CALENDAR_STATUS_ONE_EVENT]);
        $action = t("Alter");
      }
      $form['notices']['open-for-one-date'] = array(
        '#type' => 'date_text', // 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
        '#title' => t('!action date to open for one event:', array('!action' => $action)),
        '#default_value' => $default_date,
        '#date_format' => 'Y-m-d H:i',
        '#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
        // '#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
        '#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
        '#date_year_range' => '0:+1', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
        '#weight' => '150',
        '#prefix' => "<div class='clearfix'></div><div class='set-calendar-request-opening'>",
        '#suffix' => "</div>",
      );
      $form['notices']['open-for-one'] = array(
        '#type' => 'submit',
        '#value' => t('Set Open For One Date'),
        '#submit' => array('_wk_open_calendar_for_one_date_request'),
        '#weight' => 160,
      );
    }
    if ($next_years_status == CALENDAR_STATUS_ONE_EVENT) {
      $include_date_set_button = TRUE;
    }
    if ($include_date_set_button) {
      $action = t("Select");
      $default_date = $open_year . '-10-01 00:00:00';
      if (array_key_exists(CALENDAR_STATUS_TWO_EVENTS, $open_dates)) {
        $default_date = date("Y-m-d H:i:s", $open_dates[CALENDAR_STATUS_TWO_EVENTS]);
        $action = t("Alter");
      }
      $form['notices']['open-for-two-date'] = array(
        '#type' => 'date_text', // 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
        '#title' => t('!action date to open for two events:', array('!action' => $action)),
        '#default_value' => $default_date,
        '#date_format' => 'Y-m-d H:i',
        '#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
        // '#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
        '#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
        '#date_year_range' => '0:+1', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
        '#weight' => '170',
        '#prefix' => "<div class='clearfix'></div><div class='set-calendar-request-opening'>",
        '#suffix' => "</div>",
      );
      $form['notices']['open-for-two'] = array(
        '#type' => 'submit',
        '#value' => t('Set Open For Two Date'),
        '#submit' => array('_wk_open_calendar_for_two_date_request'),
        '#weight' => 180,
      );
    }
    if ($next_years_status == CALENDAR_STATUS_TWO_EVENTS) {
      $include_date_set_button = TRUE;
    }
    if ($include_date_set_button) {
      $action = t("Select");
      $default_date = $open_year + 1 . '-01-01 00:00:00';
      if (array_key_exists(CALENDAR_STATUS_ALL_EVENTS_NEXT_YEAR, $open_dates)) {
        $default_date = date("Y-m-d H:i:s", $open_dates[CALENDAR_STATUS_ALL_EVENTS_NEXT_YEAR]);
        $action = t("Alter");
      }
      $form['notices']['open-for-all-date'] = array(
        '#type' => 'date_text', // 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
        '#title' => t('!action date to open for any number of events:', array('!action' => $action)),
        '#default_value' => $default_date,
        '#date_format' => 'Y-m-d H:i',
        '#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
        // '#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
        '#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
        '#date_year_range' => '0:+1', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
        '#weight' => '190',
        '#prefix' => "<div class='clearfix'></div><div class='set-calendar-request-opening'>",
        '#suffix' => "</div>",
      );
      $form['notices']['open-for-all'] = array(
        '#type' => 'submit',
        '#value' => t('Set Open For All Date'),
        '#submit' => array('_wk_open_calendar_for_all_requests'),
        '#weight' => 200,
      );
    }
    if (empty($branch_group)) {
      $branches = _wk_get_calendar_events_for_branch($this_year);
      asort($branches);
      $branches_with_events = array();
      foreach ($branches as $tid => $count) {
        $branch_info = taxonomy_term_load($tid);
        // Hack: Ignore branches with "Kingdom" in their name that are not the West.
        // TODO: re-do this using taxonomy_get_tree(2) and use the hierarchy
        // information to decide which events to display.
        if (($tid == KINGDOM_OF_THE_WEST_TID) || (stristr($branch_info->name, "kingdom") == FALSE)) {
          $branches_with_events[] = l($branch_info->name, 'calendar-status/' . $tid) . " ($count)";
        }
      }
      $form['branches-with-events'] = array(
        '#markup' => t('<p>Branches with events in !year:</p><ul><li>!branches</li></ul>', array('!year' => $this_year, '!branches' => implode('</li><li>', array_reverse($branches_with_events)))),
      );
    }
  }
  $form['notices']['#suffix'] = "<div class='clearfix'></div>";
  return $form;
}

function wk_calendar_status_closed($form, &$form_state, $branch_groups = array()) {
  $open_year = wk_calendar_year_open_for_all_events();
  $this_year = date("Y");
  // TODO:  do not display this message until 'next_year' is nearly upon us
  // (October and later, maybe?).  For now, we will display the message
  // for the full calendar year (from January), but we will not include
  // the message for calendar years more than one full year away.
  if ($open_year == $this_year) {
    $form['notices']['closed-message'] = array(
      '#markup' => t('<p>The calendar is CLOSED for requests in !next_year.  Usually, the Seneschal and Calendar Deputy begin to prepare the calendar in April.  Once the calendar is ready, it will be opened up for ONE event request for every branch group.</p>', array('!next_year' => $open_year + 1)),
      '#weight' => 90,
    );
  }

  // Give Seneschals the chance to pick an event from last year to hold again this year.
  $form = wk_calendar_events_for_one_branch($form, $form_state, UNLIMITED, $branch_groups);

  // Add control for web administrator to begin calendar preparation
  return wk_calendar_events_for_calendar_preparation($form, $form_state);
}

function wk_calendar_status_preparing($form, &$form_state, $branch_groups = array()) {
  $open_year = wk_calendar_year_open_for_all_events();
  $form['notices']['preparing-message'] = array(
    '#markup' => t('<p>The calendar is CLOSED for requests in !next_year.  The Seneschal and Calendar Deputy are currently preparing the calendar for next year.  Once it is ready, it will be opened up for ONE event request for every branch group.</p>', array('!next_year' => $open_year + 1)),
  );
  if(wk_user_access_or_group_member('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID))) {
    $open_year = wk_calendar_year_open_for_all_events();

    $form = wk_calendar_events_for_calendar_preparation($form, $form_state);
  }
  return wk_calendar_events_for_one_branch($form, $form_state, 1, $branch_groups);
}

function wk_calendar_status_one_event($form, &$form_state, $branch_groups = array()) {
  $open_year = wk_calendar_year_open_for_all_events();
  $form['notices']['preparing-message'] = array(
    '#markup' => '<p>' . t('The calendar is open for ONE event request for each branch group in !next_year.', array('!next_year' => $open_year + 1)) . '</p>',
    '#weight' => 90,
  );
  return wk_calendar_events_for_one_branch($form, $form_state, 1, $branch_groups);
}

function wk_calendar_status_two_events($form, &$form_state, $branch_groups = array()) {
  $open_year = wk_calendar_year_open_for_all_events();
  $form['notices']['preparing-message'] = array(
    '#markup' => '<p>' . t('The calendar is open for UP TO TWO event requests for each branch group in !next_year.', array('!next_year' => $open_year + 1)) . '</p>',
    '#weight' => 90,
  );
  return wk_calendar_events_for_one_branch($form, $form_state, 2, $branch_groups);
}

function wk_calendar_events_for_one_branch($form, &$form_state, $event_limit = UNLIMITED, $branch_groups = array()) {
  // Determine if current user is the Seneschal of a group.
  if (empty($branch_groups)) {
    $branch_groups = _wk_is_seneschal();
  }
  foreach ($branch_groups as $branch_group) {
    $branch_info = taxonomy_term_load($branch_group);
    $year = wk_calendar_year_of_preparation();
    $event_nids = _wk_get_calendar_event_nids($year - 1, $branch_group);
    $events = wk_load_nodes($event_nids);
    if (!empty($events)) {
      $selectable_items = array();
      $unselectable_items = array();
      $existing_date_request_count = 0;
      foreach ($events as $nid => $node) {
        // TODO: what if the group requested an event not held last year?  We still need
        // to record that as their selection.
        $date_request_info = _wk_find_date_request_for_event($nid);
        if ($date_request_info) {
          $existing_date_request_count++;
          $list = array_keys($date_request_info);
          $entityform_id = reset($list);
          $date_request_entity = entityform_load($entityform_id);
          $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);


          // TODO: This needs to go somewhere other than the date approval page.
          $url = 'entityform/' .  $date_request->entityform_id->value() . '/edit';
          $approved_event_node = $date_request->field_approved_event->value();
          if (!empty($approved_event_node)) {
            //$approved_node = entity_metadata_wrapper('node',$approved_event_node);
            //$approved_date = $approved_node->field_date->value();
            // TODO: link to the event listing
            //$checkbox['#title'] .= ' ' . t("Approved for !when", array('!when' => l(_wk_format_date($approved_date[0], 'Y F d'), 'node/' . $approved_event_node->nid)));

            $url = 'node/' . $approved_event_node->nid;
          }
          //else {
          //  $requested_date = $date_request->field_first_choice_date->value();
          //  $checkbox['#title'] .= ' ' . t("Requested for !when", array('!when' => l(_wk_format_date($requested_date, 'Y F d'), $url)));
          //}




          $unselectable_items[$nid] = '<b>' . l($node->title, $url) . '</b>';
          //$selectable_items[$nid] = $unselectable_items[$nid];
        }
        else {
          //$unselectable_items[$nid] = '<i>' . $node->title . '</i>';
          $selectable_items[$nid] = l($node->title, 'calendar-date-request/' . $nid);
        }
      }
      // If only one event is allowed, and one or more dates have been requested,
      // then tell the Seneschal to wait until the calendar opens for all events.
      if ($existing_date_request_count >= $event_limit) {
        if ($event_limit == 1) {
          $form['already-selected-label'] = array(
            '#markup' => t('You have already requested a calendar date for an event in this calendar period.  You must wait until the calendar is opened for a second event for each group before you request another.'),
          );
        }
        else {
          $form['already-selected-label'] = array(
            '#markup' => t('You have already requested your limit of !n events in this calendar period.  You must wait until the calendar is opened for all events before you request another.', array('!n' => $event_limit)),
          );
        }
      }
      if (count($unselectable_items) > 0) {
        $form['already-selected-message'] = array(
          '#markup' => t('<p><b>!branch events already approved for the coming year:</b></p><ul><li>!events</li></ul>', array('!branch' => $branch_info->name, '!events' => implode('</li><li>', $unselectable_items), '!label' => $label, '!limit' => $limit_msg)),
        );
      }
      if (count($selectable_items) > 0) {
        $form['pick-one-message'] = array(
          '#markup' => t('<p><b>!branch events from the previous year</b> (click to request same event again next year):</b><ul><li>!events</li></ul></p>', array('!branch' => $branch_info->name, '!events' => implode('</li><li>', $selectable_items))),
        );
      }
      // Also include a link to the calendar date request form
      $form['calendar-date-request-form'] = array(
        '#markup' => t('<p>Use the !request_form to request a date for an event not shown above.</p>', array('!request_form' => l("calendar date request form", 'calendar-date-request'))),
      );
    }
  }
  return $form;
}

function wk_calendar_events_for_calendar_preparation($form, &$form_state) {
  $open_year = wk_calendar_year_open_for_all_events();
  $this_year = date("Y");
  $next_year = $this_year + 1;

  // If the calendar is open for all events this year, and closed for next year,
  // then put in the controls to begin calendar planning for next year.  The
  // alternative is that the calendar is already open for all events next year;
  // in that case, it is too early to begin preparing the calendar for the year
  // after, so leave these controls off.
  if ($next_year > $open_year) {
    $next_years_status = wk_calendar_status_for_next_year();
    $editable = wk_user_access_or_group_member('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID));
    $events_for_next_year = wk_events_for_next_years_calendar($this_year);
    $non_carryover = array();
    foreach ($events_for_next_year as $nid => $node) {
      $carryover = FALSE;
      $kingdom_or_principality = _wk_kingdom_or_principality_event($node);
      if ($kingdom_or_principality && isset($node->field_activities[$node->language])) {
        foreach ($node->field_activities[$node->language] as $index => $tid_info) {
          $tid = $tid_info['tid'];
          if (_wk_is_carryover_activity($tid, $kingdom_or_principality)) {
            $carryover = TRUE;
          }
        }
      }
      $checkbox = array(
        '#type' => 'checkbox',
        '#attributes' => array('class' => array('carryover-selection')),
        '#checked' => $carryover,
        '#default_value' => $carryover,
        '#title' => l($node->title, 'node/' . $nid),
        '#disabled' => !$editable,
        '#prefix' => "",
        '#suffix' => "",
      );
      $date_request_info = _wk_find_date_request_for_event($nid);
      if ($date_request_info) {
        $list = array_keys($date_request_info);
        $entityform_id = reset($list);
        $date_request_entity = entityform_load($entityform_id);
        $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
        $url = 'approve-date-request/' .  $date_request->entityform_id->value();
        $approved_event_node = $date_request->field_approved_event->value();
        if (!empty($approved_event_node)) {
          $approved_node = entity_metadata_wrapper('node',$approved_event_node);
          $approved_date = $approved_node->field_date->value();
          // TODO: link to the event listing
          $checkbox['#title'] .= ' ' . t("Approved for !when", array('!when' => l(_wk_format_date($approved_date[0], 'Y F d'), 'node/' . $approved_event_node->nid)));
        }
        else {
          $requested_date = $date_request->field_first_choice_date->value();
          $checkbox['#title'] .= ' ' . t("Requested for !when", array('!when' => l(_wk_format_date($requested_date, 'Y F d'), $url)));
        }
      }
      if ($carryover) {
        $form['c-' . $nid] = $checkbox;
      }
      else {
        $non_carryover['c-' . $nid] = $checkbox;
      }
    }
    $form['non-carryover'] = array(
      '#type' => 'fieldset',
      '#title' => t('Other events'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    ) + $non_carryover;
    if ($editable) {
      $form['prepare_calendar'] = array(
        '#type' => 'submit',
        '#value' => $next_years_status == CALENDAR_STATUS_PREPARING ? t('Add Events') : t('Prepare Calendar'),
        '#submit' => array('_wk_prepare_calendar'),
      );
    }
  }
  return $form;
}

function _wk_open_calendar_for_one_date_request($form, &$form_state) {
  $open_date = $form_state['values']['open-for-one-date'];
  $epoch = strtotime($open_date);
  if ($epoch < time()) {
    $epoch = time();
    drupal_set_message(t("The calendar is now open for one event per group."));
  }
  else {
    drupal_set_message(t("The calendar will be open for one event per group on !when.", array('!when' => date("Y-m-d H:i:s", $epoch))));
  }
  // TODO: send email to all Seneschals informing them that they may
  // submit one calendar date request
  variable_set('calendar-open-for-one', $epoch);
}

function _wk_open_calendar_for_two_date_request($form, &$form_state) {
  $open_date = $form_state['values']['open-for-two-date'];
  $epoch = strtotime($open_date);
  if ($epoch < time()) {
    $epoch = time();
    drupal_set_message(t("The calendar is now open for two events per group."));
  }
  else {
    drupal_set_message(t("The calendar will be open for two events per group on !when.", array('!when' => date("Y-m-d H:i:s", $epoch))));
  }
  // TODO: send email to all Seneschals informing them that they may
  // submit a second calendar date request
  variable_set('calendar-open-for-two', $epoch);
}

function _wk_open_calendar_for_all_requests($form, &$form_state) {
  $open_date = $form_state['values']['open-for-all-date'];
  $epoch = strtotime($open_date);
  if ($epoch < time()) {
    $epoch = time();
    drupal_set_message(t("The calendar is now open for any number of events."));
  }
  else {
    drupal_set_message(t("The calendar will be open for any number of events on !when.", array('!when' => date("Y-m-d H:i:s", $epoch))));
  }
  // TODO: send email to all Seneschals informing them that they may
  // submit the rest of their calendar date requests
  variable_set('calendar-open-for-all', $epoch);
}

function _wk_prepare_calendar($form, &$form_state) {
  $created_some_date_requests = FALSE;
  foreach ($form_state['values'] as $key => $value) {
    if (substr($key,0,2) == 'c-') {
      if ($value) {
        $nid = substr($key,2);
        $node = node_load($nid);
        wk_create_calendar_date_request($node);
        $created_some_date_requests = TRUE;
      }
    }
  }
  // Once some calendar date requests are created for the
  // coming year, we will consider that we have moved into
  // the PREPARING phase of the calendar date request process.
  if ($created_some_date_requests) {
    if (wk_calendar_status_for_next_year() == CALENDAR_STATUS_CLOSED) {
      variable_set('calendar-preparing', time());
    }
  }
  drupal_goto('approve-date-requests');
}

function _wk_expand_date_range_single_date($date_range, $date_to_add) {
  $result = $date_range;

  $date_epoch = _wk_format_date($date_to_add, "U");

  // Ignore bad values.
  $now = date("U");
  if ($date_epoch < $now) {
    $date_epoch = $now;
  }

  if (!isset($result['begin']) || ($result['begin'] > $date_epoch)) {
    $result['begin'] = $date_epoch;
  }

  if (!isset($result['end']) || ($result['end'] < $date_epoch)) {
    $result['end'] = $date_epoch;
  }

  return $result;
}

function _wk_expand_date_range($date_range, $date_to_add) {
  $date_range = _wk_expand_date_range_single_date($date_range, _wk_beginning_of_day($date_to_add));
  $date_range = _wk_expand_date_range_single_date($date_range, _wk_end_of_day(_wk_end_date($date_to_add)));
  return $date_range;
}

function _wk_expand_date_range_for_date_request($date_range, $date_request) {
  $date_range = _wk_expand_date_range($date_range, $date_request->field_first_choice_date->value());
  $date_range = _wk_expand_date_range($date_range, _wk_date_with_same_duration($date_request->field_alternate_date->value(), $date_request->field_first_choice_date->value()));
  $date_range = _wk_expand_date_range($date_range, _wk_date_with_same_duration($date_request->field_second_alternate_date->value(), $date_request->field_first_choice_date->value()));
  return $date_range;
}

function wk_approved_date_requests() {
  $all_ids = _wk_date_request_all_ids();
  $date_requests = array();
  $date_range = array();
  foreach ($all_ids as $id => $info) {
    $date_request_entity = entityform_load($id);
    $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
    $date_requests[$id] = $date_request_entity;
    $date_range = _wk_expand_date_range_for_date_request($date_range, $date_request);
  }
  foreach ($date_requests as $id => $date_request_entity) {
    $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
    $title = $date_request->field_event_name->value();
    $collapsed = FALSE;

    $approved_event_node = $date_request->field_approved_event->value();
    if (!empty($approved_event_node)) {
      $approved_node = entity_metadata_wrapper('node',$approved_event_node);
      $approved_date = $approved_node->field_date->value();
      $approved_epoch = _wk_format_date($approved_date[0], 'U');

      $title .= t(' - APPROVED for <a href="!url">!date</a>', array('!date' => _wk_format_date($approved_date[0], 'Y F d'), '!url' => 'node/' . $approved_event_node->nid));
      $subform = _wk_date_request_approval_form_singular($form, $form_state, $date_request_entity, $other_approved_events, TRUE);
      $form['date_request_' . $id] = array(
        '#type' => 'fieldset',
        '#title' => $title,
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
      ) + $subform;
    }
  }
  return $form;
}

function wk_email_request_approval_form($form, &$form_state) {
  $unconfirmed = wk_unconfirmed_addresses_in_domain('@westkingdom.org');
  $checkbox_options = array();

  if (empty($unconfirmed)) {
    $form['message'] = array(
      '#markup' => "No submissions at this time.",
    );
    return $form;
  }

  foreach ($unconfirmed as $eid => $info) {
    $status_label = wk_email_request_get_activity_status_label($eid);
    $checkbox_options[$eid] = l($info->name, 'user/' . $info->uid) . ' - ' . $info->email . ' ' . $status_label;
  }
  $form['requested-addresses']['approve_checkboxes'] = array(
    '#type' => 'checkboxes',
    '#options' => $checkbox_options,
    // '#default_value' => array_keys($unconfirmed),
  );
  $form['approve'] = array(
    '#type' => 'submit',
    '#value' => t('Approve Selected Email Addresses'),
    '#submit' => array('_wk_process_approve_selected_email_requests'),
  );
  $form['delete'] = array(
    '#type' => 'submit',
    '#value' => t('Delete Selected'),
    '#submit' => array('_wk_process_delete_selected_email_requests'),
  );

  return $form;
}

function _wk_process_delete_selected_email_requests($form, &$form_state) {
  foreach ($form_state['values']['approve_checkboxes'] as $eid => $selected) {
    if ($selected) {
      multiple_email_delete_email($eid);
      wk_email_request_delete_activity_status($eid);
    }
  }
}

function _wk_process_approve_selected_email_requests($form, &$form_state) {
  $unconfirmed = wk_unconfirmed_addresses_in_domain('@westkingdom.org');
  $client = wk_get_google_apps_client();
  if (empty($client->getAccessToken())) {
    drupal_set_message('Could not authenticate with Google Apps.', 'error');
    return;
  }
  $service = new Google_Service_Directory($client);

  foreach ($form_state['values']['approve_checkboxes'] as $eid => $selected) {
    if ($selected) {
      $info = multiple_email_load($eid);
      wk_create_one_requested_email_address($client, $eid, $info);
    }
  }
}

function wk_get_google_apps_client() {
  static $client = NULL;

  if (!$client) {
    $scopes = array(
        // Books is only for testing.  The rest I think we actually need.
        Google_Service_Books::BOOKS,

        Google_Service_Groupssettings::APPS_GROUPS_SETTINGS,

        Google_Service_Directory::ADMIN_DIRECTORY_GROUP,
        Google_Service_Directory::ADMIN_DIRECTORY_GROUP_READONLY,

        Google_Service_Directory::ADMIN_DIRECTORY_GROUP_MEMBER,
        Google_Service_Directory::ADMIN_DIRECTORY_GROUP_MEMBER_READONLY,

        Google_Service_Directory::ADMIN_DIRECTORY_NOTIFICATIONS,

        Google_Service_Directory::ADMIN_DIRECTORY_ORGUNIT,
        Google_Service_Directory::ADMIN_DIRECTORY_ORGUNIT_READONLY,

        Google_Service_Directory::ADMIN_DIRECTORY_USER,
        Google_Service_Directory::ADMIN_DIRECTORY_USER_READONLY,

        Google_Service_Directory::ADMIN_DIRECTORY_USER_ALIAS,
        Google_Service_Directory::ADMIN_DIRECTORY_USER_ALIAS_READONLY,

        Google_Service_Directory::ADMIN_DIRECTORY_USER_SECURITY,

        Google_Service_Directory::ADMIN_DIRECTORY_USERSCHEMA,
        Google_Service_Directory::ADMIN_DIRECTORY_USERSCHEMA_READONLY,

        Google_Service_Calendar::CALENDAR,
        Google_Service_Calendar::CALENDAR_READONLY,
      );

    //$authenticator = new ServiceAccountAuthenticator("West Kingdom Website");
    $authenticator = new ServiceAccountAuthenticator("Google Group API Test");
    $client = $authenticator->authenticate('service-account.yaml', $scopes);
  }

  return $client;
}

function wk_date_request_multiple_approval_form($form, &$form_state) {
  $all_ids = _wk_date_request_all_ids();
  $date_requests = array();
  $date_range = array();
  foreach ($all_ids as $id => $info) {
    $date_request_entity = entityform_load($id);
    $check_date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
    $approved_event_node = $check_date_request->field_approved_event->value();
    if (empty($approved_event_node)) {
      $date_request = $check_date_request;
      $date_requests[$id] = $date_request_entity;
      $date_range = _wk_expand_date_range_for_date_request($date_range, $date_request);
    }
  }
  $other_approved_event_nids = _wk_get_calendar_event_nids_in_range(_wk_format_date($date_range['begin'], W3C_NoTZ), _wk_format_date($date_range['end'], W3C_NoTZ));
  $other_approved_events = wk_load_nodes($other_approved_event_nids);
  if (count($date_requests) == 1) {
    $title = $date_request->field_event_name->value();
    $form['event-title'] = array(
      '#markup' => "<h3>$title</h3>",
    );
    $form += _wk_date_request_approval_form_singular($form, $form_state, array_shift($date_requests), $other_approved_events);
  }
  elseif (count($date_requests) > 1) {
    foreach ($date_requests as $id => $date_request_entity) {
      //dpm($date_request_entity);
      $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
      $title = $date_request->field_event_name->value();
      $collapsed = FALSE;

      $approved_event_node = $date_request->field_approved_event->value();
      if (empty($approved_event_node)) {
        $subform = _wk_date_request_approval_form_singular($form, $form_state, $date_request_entity, $other_approved_events, TRUE);
        $form['date_request_' . $id] = array(
          '#type' => 'fieldset',
          '#title' => $title,
          '#collapsible' => TRUE,
          '#collapsed' => $collapsed,
        ) + $subform;
      }
    }
    $form['approve-checked'] = array(
      '#type' => 'submit',
      '#value' => t('Approve Checked Dates'),
      '#submit' => array('_wk_process_approve_checked_date_request'),
    );
  }
  else {
    $form['message'] = array(
      '#markup' => "<p>There are no active calendar date requests at this time.</p>",
    );
  }
  return $form;
}

function wk_date_request_approval_form($form, &$form_state, $request_id) {
  $date_request_entity = entityform_load($request_id);
  $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
  $date_range = _wk_expand_date_range_for_date_request(array(), $date_request);
  $other_approved_event_nids = _wk_get_calendar_event_nids_in_range(_wk_format_date($date_range['begin'], W3C_NoTZ), _wk_format_date($date_range['end'], W3C_NoTZ));
  $other_approved_events = wk_load_nodes($other_approved_event_nids);
  $title = $date_request->field_event_name->value();
  $form['event-title'] = array(
    '#markup' => "<h3>$title</h3>",
  );
  return $form + _wk_date_request_approval_form_singular($form, $form_state, $date_request_entity, $other_approved_events);
}

function _wk_render_branch_group($terms) {
  $result = "";
  $link_options = array();
  foreach ($terms as $term) {
    $e = entity_metadata_wrapper("taxonomy_term", $term);
    $img_info = $e->field_arms->value();
    if ($img_info) {
      $image_attributes = array('alt' => $term->name);
      $title = $term->name;
      $result .= "<div class='requesting-branch-group'>" . theme_image(array("path" => $img_info['uri'], "title" => $title, "attributes" => $image_attributes)) . "<br>$title</div>";
    }
  }
  return $result;
}

function _wk_date_request_approval_form_singular($form, &$form_state, $date_request_entity, $other_approved_events, $include_checkboxes = FALSE) {
  global $user;
  $request_id = $date_request_entity->entityform_id;
  $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);

  $approved_event_node = $date_request->field_approved_event->value();
  // If not approved, then put in the approval controls
  if (empty($approved_event_node)) {
    $subform['approval-options'] = array(
      '#type' => 'fieldset',
      '#attributes' => array('class' => array('approval-fieldset')),
    );
    $checkbox_options = array();
    $format_string = 'd F Y';
    $dv_first = $date_request->field_first_choice_date->value();
    $first_choice = _wk_format_date($dv_first, $format_string);
    $first_choice_text = _wk_format_date_range($dv_first, $format_string);
    $first_choice_epoch = _wk_format_date($dv_first, 'U');
    $conflicting_events = _wk_overlapping_events($other_approved_events, $dv_first);
    $subform['approval-options']['approve_first_choice_date_' . $request_id] = array(
        '#markup' => "<div class='approve-$request_id-$first_choice_epoch'>" . l(t('Approve !d', array('!d' => $first_choice_text)), 'approve-date-request/' . $request_id . '/first_choice') . _wk_render_event_list($conflicting_events) . "</div>",
      );
    $checkbox_options[$first_choice_epoch] = $first_choice;
    $dv = _wk_date_with_same_duration($date_request->field_alternate_date->value(), $dv_first);
    $alternate_choice = _wk_format_date($dv, $format_string);
    $alternate_choice_text = _wk_format_date_range($dv, $format_string);
    $alternate_choice_epoch = _wk_format_date($dv, 'U');
    if (!empty($dv) && ($alternate_choice != $first_choice)) {
      $conflicting_events = _wk_overlapping_events($other_approved_events, $dv);
      $subform['approval-options']['approve_alternate_choice_button_' . $request_id] = array(
        '#markup' => "<div class='approve-$request_id-$alternate_choice_epoch'>" . l(t('Approve !d', array('!d' => $alternate_choice_text)), 'approve-date-request/' . $request_id . '/alternate') . _wk_render_event_list($conflicting_events) . "</div>",
      );
      $checkbox_options[$alternate_choice_epoch] = $alternate_choice;
    }
    $dv = _wk_date_with_same_duration($date_request->field_second_alternate_date->value(), $dv_first);
    $second_alternate = _wk_format_date($dv, $format_string);
    $second_alternate_text = _wk_format_date_range($dv, $format_string);
    $second_alternate_epoch = _wk_format_date($dv, 'U');
    if (!empty($dv) && ($second_alternate != $first_choice) && ($second_alternate != $alternate_choice)) {
      $conflicting_events = _wk_overlapping_events($other_approved_events, $dv);
      $subform['approval-options']['approve_second_alternate_choice_button_' . $request_id] = array(
        '#markup' => "<div class='approve-$request_id-$second_alternate_epoch'>" . l(t('Approve !d', array('!d' => $second_alternate_text)), 'approve-date-request/' . $request_id . '/second_alternate') . _wk_render_event_list($conflicting_events) . "</div>",
      );
      $checkbox_options[$second_alternate_epoch] = $second_alternate;
    }
    if ($include_checkboxes) {
      $subform['approval-options']['approve_checkboxes_' . $request_id] = array(
        '#type' => 'checkboxes',
        '#options' => $checkbox_options,
      );
      $subform['approval-options']['#post_render'] = array('_wk_approve_button_post_render');
    }
    $subform['approval-options']['reject_button_' . $request_id] = array('#markup' => "<div class='reject-$request_id'>" . l(t('Reject'), 'reject-date-request/' . $request_id) . "</div>",
      );
  }

  // Render the requesting branch group
  $subform['branch_group'] = array(
    '#markup' => _wk_render_branch_group($date_request->taxonomy_vocabulary_2->value()),
  );

  // Render the visible elements of the entityform
  $visible_elements = array(
    'info',
    'field_additional_information',
    'field_placeholder_event_descript',
  );
  $request_render_array = entityform_page_view($date_request_entity);
  foreach ($request_render_array['entityform'][$request_id] as $key => $info) {
    if (($key[0] != '#') && (!in_array($key, $visible_elements))) {
      hide($request_render_array['entityform'][$request_id][$key]);
    }
  }
  $subform['info_' . $request_id] = $request_render_array;

  // If not approved, then put in the contact and edit controls
  if (empty($approved_event_node)) {
    // If there is a Seneschal registered on this site,
    // put in a 'Contact' button that redirects to the
    // Seneschal's contact form.  Otherwise, put in
    // "mailto" link.
    $v = $date_request->taxonomy_vocabulary_2->value();
    if (!empty($v)) {
      $branch_group_tid = $v[0]->tid;
      $seneschal = _wk_get_officer($branch_group_tid, SENESCHAL_TID);
      if (count($v) > 1) {
        $alternate_branch_group_tid = $v[1]->tid;
        $alternate_seneschal = _wk_get_officer($alternate_branch_group_tid, SENESCHAL_TID);
        if ($alternate_seneschal && ($alternate_seneschal->mail == $date_request->field_email_address->value())) {
          $seneschal = $alternate_seneschal;
        }
      }

      // If we could not find the registered seneschal
      // of this branch group, then try to find any
      // user on the system who has the same email address
      // as the one entered on the form.
      if (!$seneschal) {
        $seneschal = _regnum_get_user(array('mail' => $date_request->field_email_address->value()));
      }

      // If you are the form submitter, or if you
      // are the Seneschal, then you do not need a
      // 'Contact' button.
      if (($user->mail != $date_request->field_email_address->value()) && ((!$seneschal) || ($user->mail != $seneschal->mail))) {
        if ($seneschal) {
          // A link to the contact form of a regisered user.
          $subform['contact_' . $request_id] = array(
            '#markup' => '<span class="date-request-contact">' . l('Contact  ' . $date_request->field_society_name->value(), "user/" . $seneschal->uid . "/contact") . '</span>',
          );
        }
        else {
          // A 'mailto' link pointing to whatever
          // email address was entered on the form.
          $subform['contact_' . $request_id] = array(
            '#markup' => '<span class="date-request-contact">' . l('Contact  ' . $date_request->field_society_name->value(), 'mailto://' . $date_request->field_email_address->value()) . '</span>',
          );
        }
      }
    }

    // 'Edit' link
    $subform['edit_' . $request_id] = array(
      '#markup' => '<span class="date-request-edit">' . l('Edit', "entityform/$request_id/edit") . '</span>',
    );
  }

  return $subform;
}

// no longer needed
function _wk_process_contact_date_request($form, &$form_state) {
  $id = $form_state['clicked_button']['#attributes']['date-request-id'];
  $seneschal_uid = $form_state['clicked_button']['#attributes']['seneschal-uid'];
  drupal_goto("user/$seneschal_uid/contact");
}

// no longer needed
function _wk_process_edit_date_request($form, &$form_state) {
  $id = $form_state['clicked_button']['#attributes']['date-request-id'];
  drupal_goto("entityform/$id/edit");
}

// Post-process the rendered HTML of our approval buttons and
// checkboxes to move the approval button next to the checkbox,
// repacing the checkbox's label.
function _wk_approve_button_post_render($content, $element) {
  // Find all of the submit buttons
  if (preg_match_all("#<div class='approve-([0-9]*)-([0-9]*)'>[^<]*(<a [^>]*>.*)</div>#U", $content, $match_sets, PREG_SET_ORDER)) {
    foreach ($match_sets as $matches) {
      // For each submit button found, look for a corresponding
      // checkbox.  If a match is found, then replace the checkbox
      // label with the submit button.
      $matched_html = $matches[0];
      $matched_request_id = $matches[1];
      $matched_epoch = $matches[2];
      $matched_button_html = $matches[3];

      $content = str_replace($matched_html, '', $content);
      $content = preg_replace("#<label *class=\"option\" *for=\"edit-approve-checkboxes-$matched_request_id-$matched_epoch\">[^<]*</label>#", "<label class=\"option\" for=\"edit-approve-checkboxes-$matched_request_id-$matched_epoch\">$matched_button_html</label>", $content);
    }
  }
  return $content;
}

function _wk_format_date_range($dv, $format_string = 'd M Y') {
  $result = '';
  if (!empty($dv)) {
    $start = new DateTime($dv['value'], new DateTimeZone($dv['timezone']));
    $end = new DateTime($dv['value2'], new DateTimeZone($dv['timezone']));
    // Different years?
    if ($start->format('Y') != $end->format('Y')) {
      $result = $start->format($format_string) . ' - ' . $end->format($format_string);
    }
    // Different months?
    elseif ($start->format('m') != $end->format('m')) {
      if (preg_match('/[dmM]+[^a-zA-Z]*[dmM]+/', $format_string, $matches)) {
        $adjusted_format = str_replace($matches[1], $start->format($matches[1]) . ' - ' . $matches[1], $format_string);
        $result = $end->format($adjusted_format);
      }
      else {
        $result = $start->format('d M') . ' - ' . $end->format('d M Y');
      }
    }
    // Different days?
    elseif ($start->format('d') != $end->format('d')) {
      $format_string = str_replace('d', 'd - ' . $end->format('d'), $format_string);
      $result = $start->format($format_string);
    }
    else {
      $result = $start->format($format_string);
    }
  }
  return $result;
}

function _wk_format_date($dv, $format_string = 'Y-m-d') {
  if (is_array($dv)) {
    if (!array_key_exists('value', $dv) || !array_key_exists('timezone', $dv)) {
      return "";
    }
    $d = new DateTime($dv['value'], new DateTimeZone($dv['timezone']));
    return $d->format($format_string);
  }
  else {
    return date($format_string, $dv);
  }
}

function _wk_format_end_date($dv, $format_string = 'Y-m-d')
{
  return _wk_format_date(_wk_end_date($dv), $format_string);
}

function _wk_end_date($dv) {
  if (is_array($dv) && array_key_exists('value2', $dv)) {
    $dv['value'] = $dv['value2'];
  }
  return $dv;
}

function _wk_beginning_of_day($dv) {
  if (is_array($dv)) {
    $dv['value'] = _wk_format_date($dv, Drupal_BeginningOfDay);
  }
  return $dv;
}

function _wk_end_of_day($dv) {
  if (is_array($dv)) {
    $dv['value'] = _wk_format_date($dv, Drupal_EndOfDay);
  }
  return $dv;
}

function _wk_date_with_same_duration($date_origin, $date_with_duration) {
  if (empty($date_origin)) {
    $result = $date_origin;
  }
  else {
    $result = $date_with_duration;
    $start_date = new DateTime($date_with_duration['value'], new DateTimeZone($date_with_duration['timezone']));
    $start_date->setTime(12,0,0);
    $end_date = new DateTime($date_with_duration['value2'], new DateTimeZone($date_with_duration['timezone']));
    $end_date->setTime(12,0,0);
    $duration = $start_date->diff($end_date);

    $working_date = new DateTime(_wk_format_date($date_origin, "Y-m-d") . ' 12:00:00', $start_date->getTimezone());
    $result['value'] = $working_date->format('Y-m-d') . ' 12:00:00';

    $working_date->add($duration);
    $result['value2'] = $working_date->format('Y-m-d') . ' 12:00:00';
  }

  return $result;
}

//
// Not overlapping, case 1:
//
// End date of date 1 is less than beginning date of date 2.
//
// (b1)---date 1---(e1)   (b2)---date 2---(e2)
//
// Not overlapping, case 2:
//
// End date of date 2 is less then beginning date of date 1.
//
//                        (b2)---date 2---(e2)   (b1)---date 1---(e1)
//
// Anything else is overlapping.
//
// Note also that anything that is on any part of the same day
// is considered to be overlapping; we will always compare from
// the beginning of the day of the begin date through the end of
// the day of the end date when doing comparisons, regardless of the
// actual times that the event might start and end.
//
function _wk_overlapping_dates($date_value1, $date_value2) {
  $b1 = _wk_format_date(_wk_beginning_of_day($date_value1), "U");
  $e1 = _wk_format_date(_wk_end_of_day(_wk_end_date($date_value1)), "U");
  $b2 = _wk_format_date(_wk_beginning_of_day($date_value2), "U");
  $e2 = _wk_format_date(_wk_end_of_day(_wk_end_date($date_value2)), "U");
  $not_overlapping = ($e1 < $b2) || ($e2 < $b1);
  // Ugh, the double-negative.
  return !$not_overlapping;
}

function _wk_overlapping_events($list_of_events, $date_value) {
  $result = array();

  foreach($list_of_events as $nid => $node) {
    if (_wk_overlapping_dates($node->field_date[$node->language][0], $date_value)) {
      $result[$nid] = $node;
    }
  }

  return $result;
}

// Handle 'Approved Selected Dates' button.
function _wk_process_approve_checked_date_request($form, &$form_state) {
  // Iterate over all of the checked buttons
  // Make sure that each event has at most one checked date
  $approval_list = array();
  foreach ($form_state['values'] as $key => $info) {
    if (substr($key, 0, 19) == 'approve_checkboxes_') {
      $id = substr($key, 19);
      $selected = FALSE;
      foreach ($info as $value => $state) {
        if ($state) {
          // TODO: if $selected is TRUE, that means two dates
          // were approved.  We should error out, but for now
          // we will instead assume first-selected wins.
          if (!$selected) {
            $selected = $value;
          }
        }
      }
      if ($selected) {
        $approval_list[$id] = $selected;
      }
    }
  }

  if (empty($approval_list)) {
    drupal_set_message(t("You must select at lease one date before clicking the 'Approve Checked Dates' button."), 'error');
  }
  else {
    // Call _wk_approve_selected_date_request for each selected event
    $nodes = array();
    foreach ($approval_list as $id => $selected_date) {
      $node = _wk_approve_selected_date_request($id, $selected_date);
      if ($node) {
        $nodes[$node->nid] = $node;
      }
    }
    // TODO: show summary of approved events
    // drupal_goto("calendar-date-request");
  }
}

function wk_approve_date_request_on_date($id, $selected) {
  $date_request = new EntityDrupalWrapper('entityform', $id);
  $choice = 'field_' . $selected . '_date';
  // Catch URL errors: go back to the event request approval form
  if ( !isset($date_request->$choice)) {
    drupal_goto("approve-date-request/" . $id);
  }
  else {
    $selected_date = _wk_format_date($date_request->$choice->value(), "U");
    $node = _wk_approve_selected_date_request($id, $selected_date);
    drupal_goto("node/" . $node->nid);
  }
}

// Handle 'Approve (single date)' button (no longer needed)
function _wk_process_approve_date_request($form, &$form_state) {
  $id = $form_state['clicked_button']['#attributes']['date-request-id'];
  $choice = $form_state['clicked_button']['#attributes']['date-choice'];
  $date_request = new EntityDrupalWrapper('entityform', $id);
  $selected_date = _wk_format_date($date_request->$choice->value(), "U");
  $node = _wk_approve_selected_date_request($id, $selected_date);
  drupal_goto("node/" . $node->nid);
}

function _wk_approve_selected_date_request($id, $selected_date) {
  $date_request = new EntityDrupalWrapper('entityform', $id);
  // Calculate correct event date by looking at the
  // duration of the first choice date, and adding it
  // to 'selected_date'.
  $event_date = _wk_date_with_same_duration($selected_date, $date_request->field_first_choice_date->value());

  $node = new stdClass();
  $node->type = 'cal_event';
  node_object_prepare($node);
  $node->title = $date_request->field_event_name->value();
  $node->language = LANGUAGE_NONE;

  $v = $date_request->taxonomy_vocabulary_2->value();
  if (!empty($v)) {
    $branch_group_tid = $v[0]->tid;

    $node->taxonomy_vocabulary_2[$node->language][] = array('tid' => $branch_group_tid);
  }

  // TODO: Better way to build this record?
  $node->field_date[$node->language][0] = array(
    'value' => _wk_format_date($event_date, 'Y-m-d') . "T12:00:00",
    'value2' => _wk_format_date(_wk_end_date($event_date), 'Y-m-d') . "T22:00:00",
    'offset' => -25200,
    'offset2' => -25200,
    'timezone' => "America/Los_Angeles",
    'date_type' => 'date',
  );

  $body = t("More information will be posted as it becomes available.");
  $seneschal = _wk_get_officer($branch_group_tid, SENESCHAL_TID);
  if ($seneschal) {
    $body = t("<b>Autocrat:</b> <a href='!uri'>!name</a><br><br>", array('!uri' => 'user/' . $seneschal->uid . '/contact', '!name' => $seneschal->name)) . $body;
    $node->uid = $seneschal->uid;
  }
  $node->body[$node->language][] = array(
    'value' => $body,
    'format' => '1',
  );
  $node->revision_moderation = FALSE;
  $node->is_pending = FALSE;
  $node->status = TRUE;
  // If this is a repeat of some previous event, copy over
  // certain activities.
  $repeat_of_node = $date_request->field_repeat_of_event->value();
  if ($repeat_of_node && isset($repeat_of_node->field_activities[$repeat_of_node->language])) {
    $kingdom_or_principality = _wk_kingdom_or_principality_event($repeat_of_node);
    if ($kingdom_or_principality) {
      $carryover_activities = array();
      foreach ($repeat_of_node->field_activities[$repeat_of_node->language] as $index => $tid_info) {
        $tid = $tid_info['tid'];
        if (_wk_is_carryover_activity($tid, $kingdom_or_principality)) {
          $carryover_activities[] = $tid_info;
        }
      }
    }
    $node->field_activities[$node->language] = $carryover_activities;
  }
  node_save($node);

  // Mark date request as approved
  $date_request->field_approved_event->set($node->nid);
  $date_request->save();

  // Save an unpublished revision containing the requested event text
  if (module_exists('revisioning')) {
    $requested_event_description = $date_request->field_placeholder_event_descript->value();
    if (!empty($requested_event_description)) {
      $node->revision_operation = 2; // new revision with moderation
      $node->body[$node->language][0]['value'] = $requested_event_description;
      node_save($node);
    }
  }

  return $node;
}

// TODO:  How do we decide if an activity is a carryover activity
// or not?  A crown will always be a crown, and a coronation will
// always be a coronation, but other than that...
// For now, this is only called for Kingdom and Principality events;
// local events never have any carryover activities.  Also, the only
// activities that we carry over are those that are used in selecting
// the event as one that is added to the calendar during the planning
// phase in April.  All other activities must be re-selected each year.
function _wk_is_carryover_activity($tid, $kingdom_or_principality) {
  $activity_settings = _wk_calendar_request_get_settings();
  return array_key_exists($tid, $activity_settings[$kingdom_or_principality]);
}

// Given an array of nids, return an array of nid => node.
function wk_load_nodes($node_list) {
  $result = array();
  foreach ($node_list as $nid) {
    $result[$nid] = node_load($nid);
  }
  return $result;
}

function wk_children_of_branch_tids($parent_tid) {
  $branch_group_tree = taxonomy_get_tree(2);
  $result = array();
  foreach ($branch_group_tree as $term) {
    if (in_array($parent_tid, $term->parents)) {
      $result[$term->tid] = $term->tid;
    }
  }
  return $result;
}

// Return 'k' for Kingdom, 'p' for Principality, or FALSE.
function _wk_kingdom_or_principality_event($node) {
  $principalities = wk_children_of_branch_tids(KINGDOM_OF_THE_WEST_TID);
  $other_kingdoms = wk_children_of_branch_tids(SOCIETY_TID);
  $branch_info = $node->taxonomy_vocabulary_2[$node->language];
  $result = FALSE;

  foreach ($branch_info as $index => $tid_info) {
    $tid = $tid_info['tid'];
    if ($tid == KINGDOM_OF_THE_WEST_TID) {
      $result = 'k';
    }
    elseif (in_array($tid, $other_kingdoms)) {
      $result = 'x';
    }
    elseif (in_array($tid, $principalities)) {
      $result = 'p';
    }
    else {
      return FALSE;
    }
  }

  return $result;
}

/**
 * Return all of the branches that the user is Seneschal of.
 */
function _wk_is_seneschal($account = NULL) {
  return _wk_is_officer(SENESCHAL_TID, $account);
}

/**
 * Return the branches that the user is a web admin for (Seneschal or Web Minister).
 *
 * n.b. This function does not account for priviledged admins that can
 * administrate all branch groups.  Only use this in instances where user_access()
 * does not give the desired editing capabilities.
 */
function _wk_is_branch_web_admin($account = NULL) {
  // Return all of the branches that the user is Seneschal or Webminister of
  $branch_officer = array_merge(_wk_is_seneschal($account), _wk_is_officer(WEBMINISTER_TID, $account));
  // Repair the harm done by array_merge (array keys are preserved, unless they are numeric).
  $branch_officer = array_combine($branch_officer, $branch_officer);

  return $branch_officer;
}

// If the current user is an officer, return
// the branch group tid
function _wk_is_officer($officer_tid, $the_user = NULL) {
  global $user;
  $result = array();
  if (!$the_user) {
    $the_user = $user;
  }
  $users_groups = og_get_entity_groups("user", $the_user);
  if (array_key_exists('node', $users_groups)) {
    foreach ($users_groups['node'] as $key => $nid) {
      $node = node_load($nid);
      $officer_page = new EntityDrupalWrapper('node', $node);
      foreach ($officer_page->field_office->value() as $term) {
        if ($term->tid == $officer_tid) {
          $branches = $officer_page->taxonomy_vocabulary_2->value();
          if (!empty($branches)) {
            $result[] = $branches[0]->tid;
          }
        }
      }
    }
  }
  return $result;
}

function _wk_get_officer($branch, $office) {
  $user_info = FALSE;
  $node = _wk_get_officer_node($branch, $office);
  if ($node) {
    $user_info = user_load($node->uid);
  }
  return $user_info;
}

function _wk_get_officer_node($branch, $office) {
  // $field_map = array(
  //    'office' => 'field_office',
  //    'branch' => 'taxonomy_vocabulary_2',
  //  )
  $field_map = _regnum_group_field_map("regnum_change", "officers");
  return _regnum_get_officer_node('officers', $field_map, array('branch' => $branch, 'office' => $office));
}

// Return all calendar date requests made in a given year
function _wk_date_requests_for_year($year, $branch = NULL) {
  $start_date = $year . '-01-01T00:00:00';
  $end_date = $year + 1 . '-01-01T00:00:00';

  $date_requests = array();
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', "entityform")
        ->propertyCondition('type', 'calendar_date_request')
        ->fieldCondition('field_first_choice_date', 'value', $start_date, '>=')
        ->fieldCondition('field_first_choice_date', 'value', $end_date, '<');
  if (isset($branch)) {
    $query->fieldCondition('taxonomy_vocabulary_2', 'tid', $branch, '=');
  }
  $result = $query->execute();
  if (isset($result['entityform'])) {
    $date_requests = $result['entityform'];
  }
  return $date_requests;
}

// Return all calendar date requests
function _wk_date_request_all_ids() {
  $date_requests = array();
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', "entityform");
  $query->propertyCondition('type', 'calendar_date_request');
  $result = $query->execute();
  if (isset($result['entityform'])) {
    $date_requests = $result['entityform'];
  }
  return $date_requests;
}

// Find the specific calendar date request to re-hold the specified
// event again the following year.
function _wk_find_date_request_for_event($nid) {
  $date_requests = array();
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', "entityform");
  $query->propertyCondition('type', 'calendar_date_request');
  $query->fieldCondition('field_repeat_of_event', 'nid', $nid, '=');
  $result = $query->execute();
  if (isset($result['entityform'])) {
    $date_requests = $result['entityform'];
  }
  return $date_requests;
}

/**
 * Implements hook_node_access
 *
 * per https://api.drupal.org/api/drupal/modules%21node%21node.api.php/function/hook_node_access/7
 *
 * @see wk_form_alter__cal_event_node_form() for code that limits what can be edited.
 */
function wk_node_access($node, $op, $account) {
  $type = is_string($node) ? $node : $node->type;

  if ($type == 'cal_event') {
    // Get a list of branches that the user is Seneschal or Webminister for.
    $branch_officer = _wk_is_branch_web_admin($account);
    // We will allow Seneschals and Web Ministers of any branch to create cal_event nodes.
    // They will only be able to create meetings / practices in the branch groups
    // they are officers in; this is controlled by hook_form_alter.
    if ($op == 'create' && !empty($branch_officer)) {
      return NODE_ACCESS_ALLOW;
    }
    if ($op == 'update') {
      $event_branch = $node->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['tid'];
      if (array_key_exists($event_branch, $branch_officer)) {
        return NODE_ACCESS_ALLOW;
      }
    }
  }

  // Returning nothing from this function would have the same effect.
  return NODE_ACCESS_IGNORE;
}

function wk_menu_alter(&$items) {
  // Domain access items
  $items['admin/structure/domain']['access callback'] = '_wk_domain_view_access_callback';
  $items['admin/structure/domain']['access arguments'] = array('administer site configuration for assigned domains');
  $items['admin/structure/domain/view']['access callback'] = '_wk_domain_view_access_callback';
  $items['admin/structure/domain/view']['access arguments'] = array('administer site configuration for assigned domains');
  $items['admin/structure/domain/view/%domain']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain']['access arguments'] = array(4, 'administer site configuration for assigned domains');
  $items['admin/structure/domain/view/%domain/edit']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain/edit']['access arguments'] = array(4, 'administer site configuration for assigned domains');
  $items['admin/structure/domain/view/%domain/config']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain/config']['access arguments'] = array(4, 'administer site configuration for assigned domains');
  $items['admin/structure/domain/view/%domain/conf-reset']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain/conf-reset']['access arguments'] = array(4, 'administer site configuration for assigned domains');
  $items['admin/structure/domain/view/%domain/theme']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain/theme']['access arguments'] = array(4, 'administer themes for assigned domains', 'administer theme configuration for assigned domains');
  $items['admin/structure/domain/view/%domain/theme/%/theme-settings']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain/theme/%/theme-settings']['access arguments'] = array(4, 'administer themes for assigned domains', 'administer theme configuration for assigned domains');
}

function _wk_domain_view_access_callback($permission) {
  return user_access('administer domains') || user_access($permission);
}

function _wk_domain_conf_access_callback($domain, $permission, $alternate_permission = '') {
  if (user_access('administer domains')) {
    return TRUE;
  }
  // If the user is assigned to this domain, then allow them to
  // edit this domain configuration item if they have the right
  // to do so, as granted by our permission
  global $user;
  if (array_key_exists($domain['domain_id'], $user->domain_user)) {
    return user_access($permission) || (!empty($alternate_permission) && user_access($alternate_permission));
  }
  return FALSE;
}

/**
 * Hook token_info
 *
 * Declare tokens as_year and event_month.
 */
function wk_token_info() {
  // These tokens are only available for nodes of type 'cal_event'
  $node['as_year'] = array(
    'name' => t("Anno Societatis Year"),
    'description' => t('Year in Anno Societatis (AS) notation. See http://www.sca.org/links/calendar.html.'),
  );
  $node['event_month'] = array(
    'name' => t("Event Month"),
    'description' => t('The month that the event is held in (reconed by starting date).'),
  );
  $node['event_path'] = array(
    'name' => t("Event Path"),
    'description' => t('Part of the path for a calendar event node -- [node:as_year]/[node:event_month] for events, and [node:taxonomy-vocabulary-2] for meetings.'),
  );

  // Because of http://drupal.org/node/691078, we just hack in our own
  // field-based tokens here for now (cough).
  // These tokens are only available for nodes of type 'location' and
  // 'cal_event' (if the calendar event has a location set).
  $node['field_location_street'] = array(
    'name' => t("Location Street"),
    'description' => t('The street address that a location is located at.'),
  );
  $node['field_location_city'] = array(
    'name' => t("Location City"),
    'description' => t('The city that a location is in.'),
  );
  $node['field_location_province'] = array(
    'name' => t("Location Province"),
    'description' => t('The abbreviation for the province (State) that a location is in.'),
  );
  $node['field_location_province_name'] = array(
    'name' => t("Location Province Name"),
    'description' => t('The full name of the province (State) that a location is in.'),
  );
  $node['field_location_postal_code'] = array(
    'name' => t("Location Postal Code"),
    'description' => t('The postal code for the location.'),
  );
  $node['field_location_country'] = array(
    'name' => t("Location Country"),
    'description' => t('The country that a location is in.'),
  );
  $node['field_location_country_name'] = array(
    'name' => t("Location Country Name"),
    'description' => t('The full name of the country that a location is in.'),
  );
  $node['field_location_summary'] = array(
    'name' => t("Location Summary"),
    'description' => t('A parenthesized summary of the location (City, State).'),
  );
  $node['field_location_address'] = array(
    'name' => t("Location Summary"),
    'description' => t('A parenthesized summary of the location address (Street, City, State Zip).'),
  );
  $site['copyright'] = array(
    'name' => t("Copyright"),
    'description' => t("A range of years starting at the specified base year (as set in domain access settings) and continuing to the current year."),
  );
  $site['full-parentage'] = array(
    'name' => t("Full Parentage"),
    'description' => t("The full list of parent domains for the current domain within a site hierarchy."),
  );
  $date['as_year'] = array(
    'name' => t("AS year"),
    'description' => t("The date (year) in Anno Societatis (AS) notation. See http://www.sca.org/links/calendar.html."),
  );

  return array(
    'tokens' => array('node' => $node, 'site' => $site, 'date' => $date),
  );
}

/**
 * Hook tokens
 *
 * Provide data for as_year and event_month tokens.
 */
function wk_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'site') {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'copyright':
          $date_info = getdate(time());
          $current_year = $date_info['year'];
          $base_year = variable_get('wk_copyright_base_year', '');
          if (($base_year == $current_year) || (empty($base_year))) {
            $copyright = $current_year;
          }
          else {
            $copyright = $base_year . '-' . $current_year;
          }
          $replacements[$original] = $copyright;
          break;

        case 'full-parentage':
          $replacements[$original] = _wk_full_parentage();
          break;
      }
    }
  }
  if ($type == 'date') {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'as_year':
          $the_date = time();
          $as = wk_timestamp_to_as($the_date);
          $replacements[$original] = 'AS' . $as;
          break;
      }
    }
  }
  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];
    if ($node->type == 'cal_event') {
      foreach ($tokens as $name => $original) {
        switch ($name) {
          case 'as_year':
            $start_date = $node->field_date[LANGUAGE_NONE][0]['value'];
            $as = wk_time_string_to_as($start_date);
            $replacements[$original] = 'AS' . $as;
            break;
          case 'event_month':
            $start_date = $node->field_date[LANGUAGE_NONE][0]['value'];
            $timestamp=strtotime($start_date);
            $replacements[$original] = date('M', $timestamp);
            break;
          case 'event_path':
            // We will return a different paths for events and meetings.
            if ($node->field_event_type[LANGUAGE_NONE][0]['value'] == 0) {
              // Events will be classified by the AS year and month in which they start.
              $start_date = $node->field_date[LANGUAGE_NONE][0]['value'];
              $timestamp=strtotime($start_date);
              $as = wk_time_string_to_as($start_date);
              $replacements[$original] = strtolower('AS' . $as . '/' . date('M', $timestamp));
            }
            else {
              // Meetings will be classified by the branch group they are for.
              $branch_tid = $node->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['tid'];
              $branch_info = taxonomy_term_load($branch_tid);
              $branch_shortname = _wk_term_email_name($branch_info);
              $replacements[$original] = strtolower('meeting/' . $branch_shortname);
            }
            break;
        }
      }
    }
    $location_field = array();
    if (($node->type == 'location') && (isset($node->field_location[LANGUAGE_NONE][0]))) {
      $location_field = $node->field_location[LANGUAGE_NONE][0];
    }
    if (($node->type == 'cal_event') && (isset($node->field_event_site[LANGUAGE_NONE][0]))) {
      $location_nid = $node->field_event_site[LANGUAGE_NONE][0]['nid'];
      $location_node = node_load($location_nid);
      if (isset($location_node->field_location[LANGUAGE_NONE][0])) {
        $location_field = $location_node->field_location[LANGUAGE_NONE][0];
      }
    }
    if (isset($location_field['city']) && isset($location_field['province'])) {
      $location_field['summary'] = "(" . $location_field['city'] . ", " . $location_field['province'] . ")";
    }
    else {
      $location_field['summary'] = '(TBD)';
    }
    $location_address = '';
    if (isset($location_field['street'])) {
      $location_address = str_replace(array_keys($location_field), array_values($location_field), "(street, city province postal_code)");
    }
    else {
      $location_address = '(TBD)';
    }
    $location_field['address'] = $location_address;
    foreach ($tokens as $name => $original) {
      if (substr($name,0,15) == 'field_location_') {
        // $name is always 'field_location_xxx', so key is 'xxx'.
        $key = substr($name, 15);
        if (isset($location_field[$key])) {
          $replacements[$original] = $location_field[$key];
        }
        else {
          $replacements[$original] = '';
        }
      }
    }
  }
  return $replacements;
}

function wk_render_node_field_date($node) {
  $render_array = wk_node_field_date_render_array($node);
  return drupal_render($render_array);
}

function wk_node_field_date_render_array($node) {
  $cal_event_date = array();
  if (isset($node->field_date[LANGUAGE_NONE][0]['rrule'])) {
    // Repeating events:  special checking for "weekly", then make our
    // own formatted string.  Question: could we do this with a date format?
    if (substr($node->field_date[LANGUAGE_NONE][0]['rrule'], 0, 29) == "RRULE:FREQ=WEEKLY;INTERVAL=1;") {
      // See http://drupal.org/node/1108164 for other options.
      $date = new DateObject($node->field_date[LANGUAGE_NONE][0]['value'],$node->field_date[LANGUAGE_NONE][0]['timezone'],DATE_FORMAT_ISO);
      $cal_event_date = array('#markup' => '<div class="field-name-field-date">' . format_date($date->format('U'),'custom','\E\v\e\r\y l \a\t g:ia') . '</div>');
    }
    if (substr($node->field_date[LANGUAGE_NONE][0]['rrule'], 0, 30) == "RRULE:FREQ=MONTHLY;INTERVAL=1;") {
      preg_match('/;BYDAY=[^0-9]*([0-9]*)([^;]*);/', $node->field_date[LANGUAGE_NONE][0]['rrule'], $matches);
      //preg_match('/;BYDAY=[^0-9]*([0-9]*)([^;]*);/', 'RRULE:FREQ=MONTHLY;INTERVAL=1;BYDAY=+1WE;BYMONTH=1,2,3,4,5,6,7,8,9,10,11,12;COUNT=11;WKST=SU', $matches);

      $which = array("", "First", "Second", "Third", "Fourth", "Fifth");
      $daymap = array(
        "MO" => "Monday",
        "TU" => "Tuesday",
        "WE" => "Wednesday",
        "TH" => "Thursday",
        "FR" => "Friday",
        "SA" => "Saturday",
        "SU" => "Sunday",
      );

      $cal_event_date = '<div class="field-name-field-date">' . t("!which !day of every Month", array('!which' => $which[$matches[1]], '!day' => $daymap[$matches[2]])) . '</div>';
    }
  }
  else {
    // Non-repeating dates:  just use the default view mode, and print the
    // date with the format defined for 'field_date'.
    $cal_event_date = field_view_field('node', $node, 'field_date', 'default');
  }
  return $cal_event_date;
}

function wk_time_string_to_as($time_string) {
  $timestamp=strtotime($time_string);
  return wk_timestamp_to_as($timestamp);
}

function wk_timestamp_to_as($timestamp) {
  $date_info = getdate($timestamp);
  $as = $date_info['year'] - 1966;
  if ($date_info['mon'] >= 5) {
    $as = $as + 1;
  }
  return $as;
}

function wk_node_view($node, $view_mode, $langcode) {
  if (($node->type == 'cal_event') && ($view_mode == 'full')) {
    if (isset($node->content['field_event_site'][0]['body'])) {
      //$node->content['field_directions'] = $node->content['field_event_site'][0]['body'];
      if (!isset($node->content['field_directions'][0])) {
        $node->content['field_directions'] = array(
          '#theme' => 'field',
          '#weight' => 99,
          '#title' =>  'Directions',
          '#access' => TRUE,
          '#label_display' => 'above',
          '#view_mode' => 'full',
          '#language' => $langcode,
          '#field_name' => 'field_directions',
          '#field_type' => 'text',
          '#formatter' => 'text_default',
          '#entity_type' => 'node',
          '#bundle' => 'cal_event',
          '#object' => $node,
          '#items' => array(
            0 => array(
              'value' => '',
              'format' => NULL,
              'safe_value' => '')),
        );
      }
      $direction_diagram = '';
      if (isset($node->content['field_event_site'][0])) {
        $direction_diagram = render($node->content['field_event_site'][0]['field_directions_diagram']);
        hide($node->content['field_event_site'][0]['field_directions_diagram']);
      }
      $node->content['field_directions'][0]['#markup'] = $direction_diagram . $node->content['field_event_site'][0]['body'][0]['#markup'];
      hide($node->content['field_event_site'][0]['body']);
    }
  }
}

/**
 * Hook pathauto_alias alter.
 * See http://drupal.org/node/684132
 */
function wk_pathauto_alias_alter(&$alias, array &$context) {
  if (($context['op'] != 'return') && ($context['module'] == 'taxonomy_term')) {
    $term = $context['data']['term'];
    // Make calendar path aliases for branch group taxonomy terms (vid == 2)
    if ($term->vid == 2) {
      $short_name = _wk_term_short_name($term);
      $machine_name = _wk_to_machine_name($short_name);
      // Remap calendar/tid to calendar/term_name, etc.
      // This is like pathauto for view arguments.  :)
      $path_list = array(
        "calendar/%",
        "meetings/%"        => "meetings/%/0",
        "meetings/%/all"    => "meetings/%/9",
        "events/%"          => "events/%/0",
        "events/%/all"      => "events/%/9",
        "events/%/feed"     => "events/%/0/feed",
        "events/%/all/feed" => "events/%/9/feed",
      );
      foreach ($path_list as $alias_path => $system_path) {
        if (is_numeric($alias_path)) {
          $alias_path = $system_path;
        }
        $system_path = str_replace("%", $term->tid, $system_path);
        $alias_path = str_replace("%", $machine_name, $alias_path);
        $existing_path = path_load($system_path);
        if (!empty($existing_path)) {
          path_delete($existing_path['pid']);
        }
        if (!empty($alias_path)) {
          $path_args = array("source" => $system_path, "alias" => $alias_path);
          path_save($path_args);
        }
      }
    }
  }
}

// Find all of the nodes of one particular content type,
// and regenerate the path aliases for all of these.
//
// Run when the path alias pattern is changed, and you
// want to update to the new pattern.  Note that the
// redirect module will automatically create path redirects
// from the old alias for us, so no links will be broken.
//
// We do not have any affordance to call this from the UI
// at the moment. Instead, call via Drush:
//
// drush @wk.stage ev 'return wk_correct_altered_path_aliases("cal_event");'
//
function wk_correct_altered_path_aliases($bundle_type) {
  $query = new EntityFieldQuery();
  $query = $query->entityCondition('entity_type','node')
    ->entityCondition('bundle', array($bundle_type))
    ->propertyCondition('status', 1);
  $entities = $query->execute();

  if (!empty($entities)) {
    foreach ($entities['node'] as $nid => $info) {
      $node = node_load($nid);
      pathauto_node_update_alias($node, 'update');
    }
  }
}

function _wk_term_short_name($term) {
  $short_name = '';

  if (isset($term->field_short_name[LANGUAGE_NONE][0]['value'])) {
    $short_name = $term->field_short_name[LANGUAGE_NONE][0]['value'];
  }
  if (empty($short_name) && is_object($term)) {
    $short_name = _wk_shorten_name($term->name);
  }

  return $short_name;
}

function _wk_term_email_name($term) {
  $email_name = strtolower(_wk_term_short_name($term));
  //$email_name = strtr($email_name, ' ', '-');
  $email_name = preg_replace('/[^a-z]+/', '', $email_name);
  return $email_name;
}


function _wk_shorten_name($name) {
  $remove = array("Kingdom of ", "Principality of ", "Palatine Barony of ", "Barony of ", "Kingdom of ", "Shire of ", "Province of ", "Canton of ", "College of ", "Stronghold of ", "the ", "The ", " (incipiant)");

  foreach ($remove as $string_to_remove) {
    $name = str_replace($string_to_remove, '', $name);
  }

  return $name;
}

function _wk_to_machine_name($human_readable) {
  $machine_readable = strtolower($human_readable);
  $machine_readable = preg_replace("@['`]s@",'s',$machine_readable);
  $machine_readable = preg_replace('@[^a-z0-9_]+@','-',$machine_readable);
  return $machine_readable;
}

/**
 * Return the URL to the specified site, or FALSE if the
 * branch does not have a site.
 */
function wk_branch_site_url($branch_term) {
  $term = $branch_term;
  if (is_array($term)) {
    $term = $term['tid'];
  }
  $e = entity_metadata_wrapper("taxonomy_term", $term);
  $url = $e->field_external_site_url->value();
  if (empty($url)) {
    $domain = _regnum_domain_sitename_load($branch_term);
    if (!empty($domain)) {
      $url = $domain['scheme'] . '://' . $domain['subdomain'];
    }
    else {
      $url = FALSE;
    }
  }
  return $url;
}

function wk_branch_site_label($branch_term, $image_attributes = array(), $require_url = TRUE, $include_img = TRUE) {
  if (is_numeric($branch_term)) {
    $branch_term = taxonomy_term_load($branch_term);
  }
  if (is_object($branch_term)) {
    $branch_term = (array)$branch_term;
  }

  $url = wk_branch_site_url($branch_term);
  $title = $branch_term['name'];
  $description = strip_tags($branch_term['description']);
  $site_label = '';
  if ($url) {
    $site_label = l($title, $url, array('attributes' => array('title' => $description, 'class' => array('site-label'))));
  }
  elseif(!$require_url) {
    $site_label = "<b>$title</b>";
  }
  if (!empty($site_label) && $include_img) {
    $e = entity_metadata_wrapper("taxonomy_term", $branch_term['tid']);
    $img_info = $e->field_arms->value();
    if ($img_info) {
      $site_label = theme_image(array("path" => $img_info['uri'], "title" => $title, "attributes" => $image_attributes)) . " $site_label";
    }
  }
  return $site_label;
}

function wk_branch_site_label_list($branch_list, $image_attributes = array(), $require_url = TRUE) {
  $list = array();
  foreach ($branch_list as $branch_term) {
    $site_label = wk_branch_site_label($branch_term, $image_attributes, $require_url);
    if (!empty($site_label)) {
      $list[] = $site_label;
    }
  }
  return $list;
}

function _wk_full_parentage($domain = FALSE) {
  $result = '';
  $parent_terms = regnum_domain_parent_term_list($domain);
  if (!empty($parent_terms)) {
    foreach ($parent_terms as $branch_term) {
      if (!empty($result)) {
        $result .= t(' of the ');
      }
      $result .= wk_branch_site_label($branch_term, array(), FALSE, FALSE);
    }
  }

  return $result;
}

/**
 * Create a new custom menu for a branch group.  We create separate
 * menus for every group (rather than making a fixed dynamic menu that
 * adapts to the current domain) to make it easy for branch domain web
 * ministers to customize their main menu, if they wish.
 */
function _wk_create_branch_menu($branch_term, $homepage_path) {
  $branch_id = $branch_term->tid;
  $short_name = _wk_term_short_name($branch_term);
  $menu_name = _wk_to_machine_name(_wk_term_short_name($branch_term)) . '-main-menu';
  $menu_title = t('!name Main Menu', array('!name' => $short_name));
  $menu = array(
   'menu_name' => $menu_name,
   'title' => $menu_title,
   'description' => t('Contains the custom menu items for the main menu of the !name', array('!name' => $branch_term->name)),
  );

  $menu_items = array(
    array(
      'link_title' => t("Welcome"),
      'link_path' => "$homepage_path",
    ),
    array(
      'link_title' => t("Calendar"),
      'link_path' => "calendar/$branch_id",
    ),
    array(
      'link_title' => t("Meetings"),
      'link_path' => "meetings/$branch_id",
    ),
    array(
      'link_title' => t("Events"),
      'link_path' => "events/$branch_id",
    ),
    array(
      'link_title' => t("Officers"),
      'link_path' => "officers/$branch_id",
    ),
  );
  // Try to load the specified menu name to find out if it already exists.
  if (!menu_load($menu_name)) {
    menu_save($menu);
    $weight = 0;
    foreach ($menu_items as $link) {
      $link += array(
        'menu_name' => $menu_name,
        'weight' => $weight,
        'expanded' => 0,
      );
      $mlid = menu_link_save($link);
      $weight += 10;
    }
  }
  return $menu;
}

/**
 * Implement hook_go_role_grant
 */
function wk_og_role_grant($entity_type, $gid, $uid, $rid) {
  _wk_rewrite_email_for_group($gid);
}

/**
 * Implement hook_og_role_revoke
 */
function wk_og_role_revoke($entity_type, $gid, $uid, $rid) {
  _wk_rewrite_email_for_group($gid);
}

function _wk_rewrite_email_for_group($gid) {
  $officeNode = node_load($gid);
  $branch_tid = $officeNode->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['tid'];
  $branch_info = taxonomy_term_load($branch_tid);
  $branch_shortname = _wk_term_email_name($branch_info);
  foreach ($officeNode->field_office[LANGUAGE_NONE] as $office_node_info) {
    $office_tid = $office_node_info['tid'];
    $officer_info = taxonomy_term_load($office_tid);
    $office_shortname = _wk_term_email_name($officer_info);

    _wk_rewrite_email_list_members($gid, $branch_shortname, $office_shortname);
  }
}

function _wk_rewrite_email_list_members($gid, $branch_shortname, $office_shortname) {
  $path = "/var/list/${branch_shortname}-${office_shortname}";
  $group_info = _wk_group_members($gid);
  $members = array();
  foreach ($group_info as $uid => $user_info) {
    if (isset($user_info['user']->mail)) {
      $member_email_address = $user_info['user']->mail;
      $members[] = $member_email_address;
    }
  }
  $contents = "# $path\n" . implode("\n", $members);
  // TODO:  read existing file.
  // Find the "below this line" line.
  // Append that line and everything below to '$contents'
  // rewrite contents to file
}

function wk_group_email_list_name($node) {
  $office_shortname = wk_group_office_shortname($node);
  $branch_tid = $node->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['tid'];
  $branch_info = taxonomy_term_load($branch_tid);
  $branch_shortname = _wk_term_email_name($branch_info);
  return _wk_compose_group_email_list_name($branch_shortname, $office_shortname);
}

function _wk_compose_group_email_list_name($branch_shortname, $office_shortname) {
  return $branch_shortname . '-' . $office_shortname;
}

function wk_group_office_shortname($node) {
  $office_shortname_components = wk_group_office_shortname_components($node);
  return implode("-", $office_shortname_components);
}

function wk_group_office_shortname_components($node) {
  $office_shortname_components = array();
  foreach ($node->field_office[LANGUAGE_NONE] as $office_node_info) {
    $office_tid = $office_node_info['tid'];
    $officer_info = taxonomy_term_load($office_tid);
    $one_office_shortname = _wk_term_email_name($officer_info);
    $office_shortname_components[] = $one_office_shortname;
  }
  sort($office_shortname_components);
  return $office_shortname_components;
}

function wk_export_mailinglists() {
  $primary_domain = 'westkingdom.org'; // TODO: make this a parameter or something
  $branch_tree = taxonomy_get_tree(2);
  $officer_tree = taxonomy_get_tree(3);

  $top_level_aliases = array();

  $officer_map = array();
  foreach ($officer_tree as $info) {
    $officer_map[$info->tid] = taxonomy_term_load($info->tid);
  }
  $obranch_map = array();
  foreach ($branch_tree as $info) {
    $branch_map[$info->tid] = taxonomy_term_load($info->tid);
  }

  $branches = array();
  foreach ($branch_tree as $branch_info) {
    $offices = array();
    $aliases = array();
    $office_info = array();

    $branch_tid = $branch_info->tid;
    $branch_shortname = _wk_term_email_name($branch_map[$branch_tid]);

    // Find all of the officer nodes for the specified branch
    $query = new EntityFieldQuery();
    $query = $query->entityCondition('entity_type','node')
      ->entityCondition('bundle', array('officers'))
      ->propertyCondition('status', 1)
      ->fieldCondition('taxonomy_vocabulary_2', 'tid', $branch_tid, '=');
    $entities = $query->execute();

    if (!empty($entities)) {
      foreach ($entities['node'] as $gid => $info) {
        $officeNode = node_load($gid);
        $office_shortname_components = wk_group_office_shortname_components($officeNode);
        $office_shortname = implode("-", $office_shortname_components);
        $list_name = _wk_compose_group_email_list_name($branch_shortname, $office_shortname);
        $list_email_address = $list_name . '@' . $primary_domain;
        $email_threshhold = isset($officeNode->field_deputy_email_threshhold['und'][0]['value']) ? $officeNode->field_deputy_email_threshhold['und'][0]['value'] : 10;

        $members = array();
        $group_info = _wk_group_members($gid);
        foreach ($group_info as $uid => $user_info) {
          if (isset($user_info['user']->mail)) {
            if ($user_info['weight'] <= $email_threshhold) {
              // Delivery option is one of 'login', 'org' or 'both'.
              // Use 'both' if it has not been set.
              $deliveryOption = !empty($user_info['user']->field_delivery_options[LANGUAGE_NONE][0]['value']) ? $user_info['user']->field_delivery_options[LANGUAGE_NONE][0]['value'] : 'both';
              if (($deliveryOption == 'org') || ($deliveryOption == 'both')) {
                $org_email_record = wk_get_organization_mail($user_info['user']);
                if ($org_email_record && $org_email_record->confirmed) {
                  $members[] = strtolower($org_email_record->email);
                }
                elseif ($deliveryOption == 'org') {
                  $deliveryOption = 'login';
                }
              }
              if (($deliveryOption == 'login') || ($deliveryOption == 'both')) {
                $members[] = strtolower($user_info['user']->mail);
              }
            }
          }
        }
        $offices[$office_shortname]['members'] = $members;
        $offices[$office_shortname]['properties']['group-name'] = $officeNode->title;
        if (isset($officeNode->field_additional_email_aliases[LANGUAGE_NONE][0]['value'])) {
          foreach (explode("\n", $officeNode->field_additional_email_aliases[LANGUAGE_NONE][0]['value']) as $alias_shortname)
          {
            if (!empty($alias_shortname)) {
              $offices[$office_shortname]['properties']['alternate-addresses'] = $alias_shortname;
            }
          }
        }
      }
    }
    if (!empty($offices)) {
      $branches[$branch_shortname]['lists'] = $offices;
    }
  }
  // Build the heirarchy information -- branch subgroups.
  // Ignore any group with no offices.
  foreach ($branch_tree as $branch_info) {
    $branch_tid = $branch_info->tid;
    $branch_shortname = _wk_term_email_name($branch_map[$branch_tid]);
    $parent_tid = $branch_info->parents[0];
    if (!empty($branch_shortname) && array_key_exists($branch_shortname, $branches) && $parent_tid) {
      $parent_shortname = _wk_term_email_name($branch_map[$parent_tid]);
      if (!empty($parent_shortname) && array_key_exists($parent_shortname, $branches)) {
        $branches[$parent_shortname]['subgroups'][] = $branch_shortname;
      }
    }
  }
  return $branches;
}

function wk_officer_nodes($branch) {
  // Find all of the officer nodes for the specified branch
  $query = new EntityFieldQuery();
  $query = $query->entityCondition('entity_type','node')
    ->entityCondition('bundle', array('officers'))
    ->propertyCondition('status', 1)
    ->fieldCondition('taxonomy_vocabulary_2', 'tid', $branch, '=');
  $entities = $query->execute();
  return $entities;
}

function wk_officer_list($branch) {
  // Find all of the officer nodes for the specified branch
  $query = new EntityFieldQuery();
  $query = $query->entityCondition('entity_type','node')
    ->entityCondition('bundle', array('officers'))
    ->propertyCondition('status', 1)
    ->fieldCondition('taxonomy_vocabulary_2', 'tid', $branch, '=');
  $entities = $query->execute();

  // Create a mapping from the office tid to
  // the officer node
  $officer_map = array();
  foreach ($entities['node'] as $nid => $info) {
    $e = entity_metadata_wrapper('node', $nid);
    $office = $e->field_office->value();
    $office = reset($office);
    $officer_map[$office->tid] = $e;
  }

  // Iterate over the officer tree to build the page
  $officer_tree = taxonomy_get_tree(3);
  $page = array('#prefix' => '<div id="officers">', '#suffix' => '</div>');
  foreach ($officer_tree as $office_collection) {
    // The terms that are collections of officers
    // are those with depth == 0
    if ($office_collection->depth == 0) {
      $fn = '_wk_officer_list_section_' . strtolower(strtr($office_collection->name, " -", "__"));
      if (!function_exists($fn)) {
        $fn = '_wk_officer_list_section_officers';
      }
      $section_contents = $fn($branch, $officer_tree, $officer_map, $office_collection);
      if (!empty($section_contents)) {
        $page[$office_collection->name]['title'] = array('#markup' => '<h2>' . $office_collection->name . '</h2>');
        $page[$office_collection->name]['offices'] = $section_contents;
      }
    }
  }
  return $page;
}

function _wk_officer_list_section_regent($branch, $officer_tree, $officer_map, $office_collection) {
  $section_parent = $office_collection->tid;
  return array();
}

function _wk_officer_list_section_officers($branch, $officer_tree, $officer_map, $office_collection) {
  $section_parent = $office_collection->tid;
  $section_contents = array();
  foreach ($officer_tree as $office) {
    if (in_array($section_parent, $office->parents)) {
      // TODO: Maybe label each office on a case-by-case basis as required or not required, and set $show_vacancies based on that?
      $show_vacancies = FALSE;
      $info = array('#prefix' => '<div class="office-summary third-width">', '#suffix' => '</div>', '#office' => $office);
      //$e = entity_metadata_wrapper("taxonomy_term", $office->tid);
      $t = taxonomy_term_load($office->tid);
      $info['badge'] = field_view_field("taxonomy_term", $t, "field_badge");
      $info['badge']['#weight'] = -10;
      if (array_key_exists($office->tid, $officer_map)) {
        $e = $officer_map[$office->tid];
        // $info['node'] = $e;
        $nid = $e->getIdentifier();
        $url = url("node/$nid");
        $info['badge']['#prefix'] = "<a href='$url'>";
        $info['badge']['#suffix'] = "</a>";
        $info['#nid'] = $nid;
        $members = _wk_group_members($nid);
        foreach ($members as $id => $member) {
          if (!empty($member['title']) && (!array_key_exists('members', $info) || ($member['weight'] < 0))) {
            $info['members'][$id] = _wk_build_office_member_display($member['title'], $member['user']->name, $nid);
          }
        }
        if (!array_key_exists('members', $info)) {
          $info['members'][] = _wk_build_office_member_display($e->title->value(), $e->author->value()->name, $nid);
        }
      }
      elseif ($show_vacancies) {
        $info['members'][] = _wk_build_office_member_display($office->name, t('Vacant'));
      }
      if (array_key_exists('members', $info)) {
        $info['members']['#prefix'] = '<div class="office-members">';
        $info['members']['#suffix'] = '</div>';
        $section_contents[$office->name] = $info;
      }
    }
  }
  return $section_contents;
}

function _wk_build_office_member_display($title, $name, $nid = 0) {
  $linked_title = $title;
  $linked_name = $name;
  if ($nid) {
    $url = "node/$nid";
    $linked_title = l($title, $url);
    $linked_name = l($name, $url);
  }
  return array(
    '#prefix' => '<div class="office-member">',
    'title' => array(
      '#prefix' => "<div class='officer-title'>",
      '#markup' => $linked_title,
      '#suffix' => "</div>",
    ),
    'name' => array(
      '#prefix' => "<div class='officer-name'>",
      '#markup' => $linked_name,
      '#suffix' => "</div>",
    ),
    '#suffix' => '</div>',
  );
}

function _wk_group_members($gid, $group_type = 'node') {
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'og_membership')
    ->propertyCondition('gid', $gid, '=')
    ->propertyCondition('group_type', $group_type, '=')
    ->fieldOrderBy('field_weight', 'value')
    ->execute();
  $members = array();
  if (array_key_exists('og_membership', $result)) {
    foreach ($result['og_membership'] as $id => $info) {
      $e = entity_metadata_wrapper("og_membership", $id);
      $type_of_deputy = $e->field_type_of_deputy->value();
      $weight = $e->field_weight->value(); // todo: just sort by weight
      $user = $e->entity->value();
      if (isset($user->uid) && isset($user->mail)) {
        $members[$user->uid] = array(
          'user' => $user,
          'title' => $type_of_deputy,
          'weight' => $weight,
        );
      }
    }
  }
  return $members;
}

function wk_node_field_value_changed($node, $field_name) {
  $original_existed = isset($node->original->{$field_name}[LANGUAGE_NONE][0]['value']);
  $exists_now = isset($node->{$field_name}[LANGUAGE_NONE][0]['value']);

  return ($original_existed != $exists_now) ||
    ($exists_now &&
      ($node->original->{$field_name}[LANGUAGE_NONE][0]['value'] != $node->{$field_name}[LANGUAGE_NONE][0]['value']));
}

function wk_node_update($node) {
  if ($node->type == 'officers') {
    if (wk_node_field_value_changed($node, "field_additional_email_aliases")) {
      $_SESSION['wk_og_membership_changed'] = TRUE;
    }
  }
}

function wk_og_membership_insert(OgMembership $og_membership) {
  $_SESSION['wk_og_membership_changed'] = TRUE;
}

function wk_og_membership_update(OgMembership $og_membership) {
  $_SESSION['wk_og_membership_changed'] = TRUE;
}

function wk_og_membership_delete(OgMembership $og_membership) {
  $_SESSION['wk_og_membership_changed'] = TRUE;
}

function wk_exit() {
  if (isset($_SESSION['wk_og_membership_changed'])) {
    unset($_SESSION['wk_og_membership_changed']);
    $pid = shell_exec(dirname(DRUPAL_ROOT) . '/bin/exportmailinglists <&- 1<&- 2<&- &');
  }
}

function wk_show_list_messages($list_name) {
  return shell_exec('sudo -u list ' . dirname(DRUPAL_ROOT) . '/bin/show-list-messages ' . escapeshellarg($list_name));
}

function wk_get_message_content($list_name, $message_number) {
  return shell_exec('sudo -u list ' . dirname(DRUPAL_ROOT) . '/bin/show-list-messages ' . escapeshellarg($list_name) . ' ' . escapeshellarg($message_number));
}

/**
 * Implements hook_views_query_alter
 *
 * Alter the calendar view query such that the search terms
 * include all of the parent terms in addition to the children.
 */
function wk_views_query_alter(&$view, &$query) {
  if ($view->name == "calendar" && isset($view->args[0]) && (is_numeric($view->args[0]))) {
    $tid = $view->args[0];
    // Traverse through the 'where' part of the query.
    foreach ($query->where as &$condition_group) {
      foreach ($condition_group['conditions'] as &$condition) {
        // If this is the part of the query filtering on title, chang the
        // condition to filter on node ID.
        if (($condition['field'] == 'node.nid') && ($condition['operator'] = 'IN')) {
          if (isset($condition['value']->conditions()[0])) {
            $additional_tids = array();
            // First add in parents
            foreach (taxonomy_get_parents_all($tid) as $info) {
              $parent_tid = $info->tid;
              if ($parent_tid != 75) {
                $additional_tids[] = $parent_tid;
              }
            }
            // Then add in neighbors
            $term_info = taxonomy_term_load($tid);
            if (isset($term_info->taxonomy_vocabulary_2[LANGUAGE_NONE])) {
              foreach ($term_info->taxonomy_vocabulary_2[LANGUAGE_NONE] as $tinfo) {
                $additional_tids[] = $tinfo['tid'];
              }
            }
            // At this point, we can search insided
            // $condition['value']->conditions()[0]['field']->conditions()
            // and find one that is:
            //   'field' => 'tn.tid',
            //   'value' => $view->args[0],
            //   'operator' => '='.
            // We will search out and find this entry, and convert it
            // into an 'IN' search with our $additional_tids.
            //
            // Note that we could just add our own conditional onto the
            // end, but doing it this way results in one fewer condition.
            if (!empty($additional_tids)) {
              $additional_tids[] = $tid;
              foreach ($condition['value']->conditions()[0]['field']->conditions() as &$subquery_condition) {
                if (is_array($subquery_condition) && ($subquery_condition['field'] == 'tn.tid') && ($subquery_condition['operator'] == '=')) {
                  $subquery_condition['operator'] = 'IN';
                  $subquery_condition['value'] = $additional_tids;
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
}

/**
 * Given a society name, return a list of potential names
 * that might be used as an email address.
 */
function wk_potential_email_names($name) {
  $result = array();

  $name = strtolower($name);

  // First convert all of the different forms of "aka" to "/"
  $name = preg_replace('/ (called|formerly|also|aka) /', '/', $name);
  $names = explode('/', $name);
  foreach ($names as $one_name) {
    $result = array_merge($result, _wk_potential_email_names_parts($one_name));
  }
  return $result;
}

function _wk_potential_email_names_parts($name) {
  $result = array();

  // Strip off any titles from the beginning of the name.
  // TODO: We need a longer list of titles
  $name = preg_replace('/(duke|duchess|count|countess|earl|vicount|vicountess|baron|baroness|mistress|master|lord|lady) /', '', $name);

  $full_email_name = _wk_transliterate_potential_name($name);
  $result[] = $full_email_name;

  // Get rid of any "the" or "of the" parts in the name
  $name_part_only = preg_replace('/\.(the|of\.the)\..*/', '', $full_email_name);
  if ($full_email_name != $name_part_only) {
    $result[] = $name_part_only;
  }

  $email_name_parts = explode('.', $name_part_only);
  if (count($email_name_parts) > 1) {
    // First part only
    $result[] = $email_name_parts[0];
    // Last part only
    $result[] = $email_name_parts[count($email_name_parts)-1];
    if (count($email_name_parts) > 2) {
      $result[] = $email_name_parts[0] . '.' .  $email_name_parts[count($email_name_parts)-1];
    }
  }
  return $result;
}

function _wk_transliterate_potential_name($name) {
  // Convert special characters (umlauts and so on) to their non-transliterated counterpart
  $name = iconv("utf-8","ascii//TRANSLIT", $name);

  // Get rid of non-alphabetic characters
  $name = preg_replace('/[^a-z-]/', '.', $name);
  // Combine multiple dots into single dots
  $name = preg_replace('/\.\.*/', '.', $name);
  return $name;
}

function wk_get_organization_mail($account) {
  // Load the multiple email addresses for this account.
  // The return result here is a little odd; $addresses[0] is
  // a list of all of the addresses (string values); the
  // other elements of $addresses are the multiple email
  // objects from the database, keyed by their $eid.
  $addresses = multiple_email_load_addresses($account->uid);
  unset($addresses[0]);
  foreach ($addresses as $eid => $mmail_record) {
    $address = $mmail_record->email;
    if (substr($address, -15) == 'westkingdom.org') {
      return $mmail_record;
    }
  }
  return FALSE;
}

/**
 * Implements hook_user_view().
 */
function wk_user_view($account, $view_mode) {
  global $user;

  // On the ordinary user view page, on the user's own
  // user page, put in a note advising them to log on
  // to their Google Apps account with this address.
  $can_access = user_access('view/request organization email for any user');
  if (!$can_access && ($user->uid == $account->uid)) {
    $can_access = user_access('view/request own organization email');
  }
  if ($can_access && ($view_mode == 'full')) {
    $mmail_record = wk_get_organization_mail($account);
    if ($mmail_record) {
      $org_mail = $mmail_record->email;
      if ($mmail_record->confirmed) {
        $account->content['show_organization_email'] = array(
          '#type' => 'org-email',
          '#weight' => 100,
          'organization_email_display' => array(
            // Duplicate the markup for a field, even though this
            // is not a field.
            '#markup' => t('
<div class="field simulated-field-name-field-organization-mail field-type-text field-label-above">
  <div class="field-label">Confirmed Organization E-mail</div>
  <div class="field-items">
    <div class="field-item">@org</div>
  </div>
</div>
<span class="note">E-mail sent to %org may be configured to forward to one of your other accounts; log on to your <a href="!url">West Kingdom Google Apps</a> account to set this up. You may !reset if you do not know it.</span>', array('@org' => $org_mail, '%org' => $org_mail, '%email' => $account->mail, '!url' => 'http://www.google.com/a/westkingdom.org', '!reset' => l('reset your Google Apps password', 'users/' . $account->uid . '/mail/reset'))),
          ),
        );

        if (($user->uid == $account->uid)) {
          $deliveryOption = $account->field_delivery_options[LANGUAGE_NONE][0]['value'];
          $account->content['select_delivery_options'] = array(
            '#type' => 'delivery-options',
            '#weight' => 100,
            'delivery_options_display' => drupal_get_form('wk_select_delivery_options', $account, $org_mail, $deliveryOption),
          );
        }
      }
      else {

        $account->content['requested_organization_email'] = array(
          '#type' => 'org-email',
          '#weight' => 100,
          'organization_email_display' => array(
            // Duplicate the markup for a field, even though this
            // is not a field.
            '#markup' => t('
<div class="field simulated-field-name-field-organization-mail field-type-text field-label-above">
  <div class="field-label">Requested Organization E-mail</div>
  <div class="field-items">
    <div class="field-item">@org</div>
  </div>
</div>
<span class="note">Waiting for %org to be approved.  You will not be able to log on to your West Kingdom Google Apps account until this address is created.</span>', array('@org' => $org_mail, '%org' => $org_mail)),
          ),
        );

      }
    }
    else {
      $account->content['request_organization_email'] = array(
        '#type' => 'request-org-email',
        '#weight' => 100,
        'organization_email_display' => drupal_get_form('wk_request_organization_email', $account),
      );
    }
  }
}

function wk_select_delivery_options($form, &$form_state, $account, $org_mail, $selectedDeliveryOption = 'both') {
  if (empty($selectedDeliveryOption)) {
    $selectedDeliveryOption = 'both';
  }
  $options = array(
    'login' => t('Login email (@email)', array('@email' => $account->mail)),
    'org' => t('Organization email (@email)', array('@email' => $org_mail)),
    'both' => t('Both'),
  );
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $account->uid,
  );
  $form['choices'] = array(
    '#title' => t('Delivery Options'),
    '#description' => t('Select which addresses email forwards should be sent to.'),
    '#type' => 'radios',
    '#options' => $options,
    '#default_value' => $selectedDeliveryOption,
  );
  $form['description'] = array(
    '#type' => 'item',
    '#markup' => t('<span class="note">The most reliable delivery option is to the organization email address. Set up an email forward in your gmail account if direct delivery to your login email address is not working.</span>'),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Update',
  );
  return $form;
}

function wk_select_delivery_options_submit($form, &$form_state) {
  $uid = $form_state['values']['uid'];
  $account = user_load($uid);

  $deliveryOption = $form_state['values']['choices'];

  $edit = array(
    'field_delivery_options' => array(
      LANGUAGE_NONE => array(
        0 => array(
          'value' => $deliveryOption,
        ),
      ),
    ),
  );
  user_save($account, $edit);

  // Let the user know something happened.
  // We will create the address in hook_cron.
  drupal_set_message(t("Mail delivery options set to %option.", array('%option' => $deliveryOption)));
}

function wk_request_organization_email($form, &$form_state, $account) {
  $names = wk_potential_email_names($account->name);
  // Add '@westkingdom.org' on the end of each name.
  $names = array_map(function($v) {
      return $v . '@westkingdom.org';
    }, $names);
  $names = array_combine($names, $names);
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $account->uid,
  );
  $form['choices'] = array(
    '#title' => t('Request Organization E-mail Address'),
    '#description' => t('Select the email address you would like to use.'),
    '#type' => 'radios',
    '#options' => $names,
    '#default_value' => reset($names),
  );
  $form['description'] = array(
    '#type' => 'item',
    '#markup' => t('An organization email address is needed to use Google Apps.'),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Request',
  );
  return $form;
}

function wk_google_apps_password_reset($form, &$form_state, $uid) {
  $account = user_load($uid);
  $org_email = wk_get_organization_mail($account);
  if (!$org_email) {
    $form = wk_request_organization_email($form, $form_state, $account);
    return $form;
  }
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $account->uid,
  );
  $form['email'] = array(
    '#type' => 'hidden',
    '#value' => strtolower($org_email->email),
  );
  $form['password'] = array(
    '#type' => 'password_confirm',
    '#title' => t('New Google Apps password for %name', array('%name' => $account->name)),
    '#size' => 25,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Reset',
  );
  return $form;
}

function wk_google_apps_password_reset_submit($form, &$form_state) {
  $uid = $form_state['values']['uid'];
  $org_email = $form_state['values']['email'];
  $password = $form_state['values']['password'];
  try {
    $client = wk_get_google_apps_client();
    $service = new Google_Service_Directory($client);
    $email_info = $service->users->get($org_email);
    $email_info->setPassword($password);
    $service->users->patch($org_email, $email_info);
    drupal_set_message(t('Google Apps password changed.'));
  }
  catch (\Exception $e) {
    drupal_set_message(t('Failed to contact Google Apps; password not changed.'), 'error');
  }
  drupal_goto('user/' . $uid);
}

function wk_get_organization_email_info($client, $mail) {
  $service = new Google_Service_Directory($client);
  try {
    $email_info = $service->users->get($mail);
  }
  catch (\Exception $e) {
    return null;
  }

  return $email_info;
}

function wk_request_organization_email_validate($form, &$form_state) {
  $mail = $form_state['values']['choices'];
  if (!$mail) {
    return form_set_error('choices', t("No address selected."));
  }
  $client = wk_get_google_apps_client();
  if (empty($client->getAccessToken())) {
    return form_set_error('choices', t("Google Apps services not available."));
  }
  $uid = $form_state['values']['uid'];
  $account = user_load($uid);
  if (!isset($account->field_real_name[LANGUAGE_NONE][0]['value']) || empty($account->field_real_name[LANGUAGE_NONE][0]['value'])) {
    return form_set_error('choices', t("Your request to create %mail cannot be processed, because the 'Real Name' field has not been provided for your account.", array("%mail" => $mail)));
  }

  $email_info = wk_get_organization_email_info($client, $mail);
  if ($email_info && ($email_info->getName()->fullName == $account->field_real_name[LANGUAGE_NONE][0]['value'])) {
    $form_state['#verified'] = TRUE;
    return TRUE;
  }
  if ($email_info) {
    return form_set_error('choices', t("The address !mail is already in use by another user.  Please make another selection, or contact the Kingdom Webminister.", array('!mail' => $mail)));
  }
}

function wk_request_organization_email_submit($form, &$form_state) {
  $uid = $form_state['values']['uid'];
  $account = user_load($uid);

  $mail = $form_state['values']['choices'];

  // Create a record in the multiple-email module's tables.
  // This will be marked as "unconfirmed".
  $eid = multiple_email_register_email($account->uid, $mail);
  if (isset($form_state['#verified'])) {
    $eid = multiple_email_register_email($account->uid, $mail, TRUE, $eid);
    drupal_set_message(t("%mail has been set up for your use.", array("%mail" => $mail)));
    return;
  }

  // Notify admins that the process has begun
  _wk_org_email_notify('wk_google_apps_account_requested', $mail, $account, 'webminister@westkingdom.org');

  // Let the user know something happened.
  // We will create the address in hook_cron.
  drupal_set_message(t("Your request to create %mail was recieved; please be patient while your request is processed.", array("%mail" => $mail)));
}

define('WK_EMAIL_REQUEST_FATAL', 100);
define('WK_EMAIL_REQUEST_FAILED_DUPLICATE', 101);
define('WK_EMAIL_REQUEST_CREATED_USER', 200);
define('WK_EMAIL_REQUEST_USER_EXISTS_IN_DIRECTORY', 201);

function wk_unconfirmed_addresses() {
  $query = db_select('multiple_email', 'me');
  $query->fields('me');
  $query->join('users', 'u', 'u.uid = me.uid');
  $query->fields('u', array('name'));
  $query->condition('me.confirmed', 0);
  $query->condition('me.email', 'u.mail', 'NOT LIKE');
  $result = $query->execute();
  $unconfirmed = array();
  while ($row = $result->fetchObject()) {
    $unconfirmed[$row->eid] = $row;
  }
  return $unconfirmed;
}

function wk_unconfirmed_addresses_in_domain($domain) {
  $unconfirmed = wk_unconfirmed_addresses();
  $result = array();
  foreach ($unconfirmed as $eid => $mmail) {
    $address = $mmail->email;
    if (substr($address, -strlen($domain)) == $domain) {
      $result[$eid] = $mmail;
    }
  }
  return $result;
}

function _wk_random_password($length=16) {
  $candidates = 'aeuyAEUY@#$*23456789bdghjmnpqrstvzBDGHJLMNPQRSTVWXZ';
  $password = '';
  for ($i = 0; $i < $length; $i++) {
    $password .= $candidates[(rand() % strlen($candidates))];
  }
  return $password;
}

// This function must be called repeatedly until it succeeds.
function wk_add_organization_account($service, $account, $org_email, $eid, $password = FALSE) {
  $result = FALSE;

  // If the current action has a non-zero retry counter, then
  // skip further actions until its retry time is reached.
  if (time() > wk_email_request_get_activity_retry_time($eid)) {
    switch (wk_email_request_get_activity_status($eid)) {
      case WK_EMAIL_REQUEST_FATAL:
      case WK_EMAIL_REQUEST_FAILED_DUPLICATE:
        $result = FALSE;
        break;

      case WK_EMAIL_REQUEST_CREATED_USER:
        $result = wk_check_organization_account_status($service, $account, $org_email, $eid, $password);
        break;

      default:
        $result = wk_initiate_add_organization_account($service, $account, $org_email, $eid, $password);
    }
  }

  return $result;
}

function wk_check_organization_account_status($service, $account, $org_email, $eid, $password) {
  $status = wk_check_organization_account_exists($service, $account, $org_email, $eid, $password);
  if ($status === FALSE) {
    // We definitely need to set our retry status here and eventually give up
    // if no progress is made
    wk_email_request_bump_retry_counter($eid);
  }
  return $status;
}

function wk_check_organization_account_exists($service, $account, $org_email, $eid, $password) {
  $real_name = $account->field_real_name[LANGUAGE_NONE][0]['value'];

  // Check to see if the requested email address already exists
  try {
    $data = $service->users->get($org_email);

    // Account exists now; it either belongs to this user, or it
    // belongs to some other user.  Check to see which is the case.
    /*Google_Service_Directory_UserName*/ $name = $data->getName();
    $full_name = $name->getFullName();

    // If the 'real name' stored on westkingdom.org matches the full
    // name stored with the Google user, then we have successfully
    // created the user.
    if ($real_name == $full_name) {
      $result = wk_organization_account_created($service, $account, $org_email, $eid);
      watchdog('WK',
        'Organization email created for %user: %mail.',
        array(
          '%user' => $real_name,
          '%mail' => $org_email,
        ),
        WATCHDOG_NOTICE);

      wk_email_request_set_activity_status($eid, false);
      return WK_EMAIL_REQUEST_USER_EXISTS_IN_DIRECTORY;
    }
    else {
      // Someone else already has the email address the user requested.
      // Log the conflict and cancel the request.
      watchdog('WK',
        'Organization email creation error: %user requested email address %mail, but it is already in use by %existing.',
        array(
          '%user' => $real_name,
          '%mail' => $org_email,
          '%existing' => $full_name,
        ),
        WATCHDOG_ERROR);

      // Mark the request as being unavailable due to a duplicate address existing.
      wk_email_request_set_activity_status($eid, WK_EMAIL_REQUEST_FAILED_DUPLICATE, array('duplicate' => $full_name));
      return WK_EMAIL_REQUEST_FAILED_DUPLICATE;
    }
  }
  catch (\Exception $e) {
    // User does not exist yet -- go ahead and try to create user
  }
  return FALSE;
}

function wk_initiate_add_organization_account($service, $account, $org_email, $eid, $password) {
  $real_name = $account->field_real_name[LANGUAGE_NONE][0]['value'];

  $name_parts = explode(' ', $real_name);
  $family_name = array_pop($name_parts);
  $given_name = implode(' ', $name_parts);

  if (!$password) {
    $password = _wk_random_password();
  }

  // Check to see if the requested email address already exists
  $status = wk_check_organization_account_exists($service, $account, $org_email, $eid, $password);
  if ($status) {
    return $status;
  }

  // User does not already exist, so go ahead and add it.
  try {
    // Add a user
    $org_user = new Google_Service_Directory_User(array(
        'name' => array(
          'familyName' => $family_name,
          'givenName' => $given_name,
        ),
        'primaryEmail' => $org_email,
        'password' => sha1(($password)),
        'hashfunction' => 'SHA-1',
      ));
    $status = $service->users->insert($org_user);
  }
  catch (\Exception $e) {
    // Hopefully this is rare
    watchdog('WK',
      'Organization email creation error: could not create %user with email address %mail.  Message: %message.',
      array(
        '%user' => $real_name,
        '%mail' => $org_email,
        '%message' => $e->getMessage(),
      ),
      WATCHDOG_ERROR);

    // TODO: What should our strategy be here?  We could retry a couple of
    // times, maybe.  For now we just mark it 'fatal' and leave it alone.
    wk_email_request_set_activity_status($eid, WK_EMAIL_REQUEST_FATAL, array('error' => $e->getMessage()));
  }

  // Make note that we requested that Google create this user.
  wk_email_request_set_activity_status($eid, WK_EMAIL_REQUEST_CREATED_USER);

  // We will wait until the next run of 'cron' for the
  // user to appear in the Google directory; if a call to
  // 'get' returns the user record, we will mark it as
  // having been created.
  return TRUE;
}

function wk_organization_account_created($service, $account, $org_email, $eid) {
  // TODO: we need to set up the email address to forward
  // to $account->mail.  We need to make sure that this address
  // is DIFFERENT than the org email address.  We should not
  // mark the address as confirmed unless the forward is set
  // up correctly.  Unfortunately, Google does not currently provide
  // an API to do this, so we must defer this feature until that
  // is available.

  // Tell the user they have a Google Apps account now.
  _wk_org_email_notify('wk_google_apps_account_created', $org_email, $account);

  // If the user account was created successfully, then
  // mark the email address as 'confirmed'.
  multiple_email_register_email($account->uid, $org_email, TRUE, $eid);
  wk_email_request_delete_activity_status($eid);
  return TRUE;
}

function wk_cron() {
  wk_process_some_email_address_requests(10);
}

function wk_process_some_email_address_requests($max_addresses_to_create) {
  $client = wk_get_google_apps_client();
  if (empty($client->getAccessToken())) {
    return;
  }
  $unconfirmed = wk_unconfirmed_addresses_in_domain('@westkingdom.org');
  foreach ($unconfirmed as $eid => $mmail) {
    $result = wk_create_one_requested_email_address($client, $eid, $mmail);

    // The result will be FALSE if no progress was made on the
    // current address; in this instance, we will not count it as
    // an item that needs to be processed.  For all other return values,
    // we will count down and exit cron once we have processed more than
    // ten addresses.
    if ($result !== FALSE) {
      $max_addresses_to_create--;
      if ($max_addresses_to_create <= 0) {
        return;
      }
    }
  }
}

// This function does not create the requested address in one step;
// you must call it repeatedly until it is done.  It is sometimes necessary
// to wait a bit between calls, to give Google time to process requests.
function wk_create_one_requested_email_address($client, $eid, $mmail) {
  $org_email = $mmail->email;
  $account = user_load($mmail->uid);

  $service = new Google_Service_Directory($client);

  return wk_add_organization_account($service, $account, $org_email, $eid);
}

function wk_email_request_set_activity_cache($cache) {
  variable_set('wk_email_request_activity_status', $cache);
}

function wk_email_request_get_activity_cache() {
  return variable_get('wk_email_request_activity_status');
}

function wk_email_request_set_activity_status($eid, $status, $params = array()) {
  if ($status === FALSE) {
    return wk_email_request_delete_activity_status($eid);
  }

  $data = wk_email_request_get_activity_data($eid);
  if (!$data || ($data['s'] != $status)) {
    $data = array(
      't' => time(),
      's' => $status,
      'p' => $params,
      'r' => 0,
    );
  }
  else {
    $data['r']++;
  }
  wk_email_request_set_activity_data($eid, $data);
}

function wk_email_request_set_activity_data($eid, $data) {
  $cache = wk_email_request_get_activity_cache();
  $cache[$eid] = $data;
  wk_email_request_set_activity_cache($cache);
}

function wk_email_request_get_activity_status($eid) {
  $data = wk_email_request_get_activity_data($eid);

  return $data['s'];
}

function wk_email_request_get_activity_start_time($eid) {
  $data = wk_email_request_get_activity_data($eid);

  return $data['t'];
}

function wk_email_request_get_activity_retries($eid) {
  $data = wk_email_request_get_activity_data($eid);

  return $data['r'];
}

function wk_email_request_bump_retry_counter($eid) {
  $data = wk_email_request_get_activity_data($eid);
  $data['r']++;
  wk_email_request_set_activity_data($eid, $data);
}

function wk_email_request_get_activity_retry_delta($eid) {
  return min(wk_email_request_get_activity_retries($eid) * ONE_MINUTE * 15, ONE_DAY);
}

function wk_email_request_get_activity_retry_time($eid) {
  return wk_email_request_get_activity_start_time($eid) + wk_email_request_get_activity_retry_delta($eid);
}

function wk_email_request_get_activity_data($eid) {
  $cache = wk_email_request_get_activity_cache();

  return array_key_exists($eid, $cache) ? $cache[$eid] : array('t' => 0, 's' => FALSE, 'p' => array(), 'r' => 0);
}

function wk_email_request_delete_activity_status($eid) {
  $cache = wk_email_request_get_activity_cache();
  unset($cache[$eid]);
  wk_email_request_set_activity_cache($cache);
}

function wk_email_request_get_activity_status_label($eid) {
  $label = '';

  $data = wk_email_request_get_activity_data($eid);

  switch ($data['s']) {
    case WK_EMAIL_REQUEST_FATAL:
      $label = t("Failed: %error", array('%error' => $data['p']['error']));
      break;
    case WK_EMAIL_REQUEST_FAILED_DUPLICATE:
      $label = t("Address already claimed by %duplicate", array('%duplicate' => $data['p']['dupicate']));
      break;
    case WK_EMAIL_REQUEST_CREATED_USER:
      $label = t("Waiting for Google account creation to complete.");
      break;
  }

  return $label;
}
