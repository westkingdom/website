<?php

/**
 * @file
 * Manage officers in a large, multi-branch organization
 */

// TODO:  Add admin page to edit this, and load it from configuration
//
// To find all available roles for default role selection:
//   og_roles('node', $bundle, 0, FALSE, FALSE);
// To look up a tid from a taxonomy term name:
//   $term = taxonomy_get_term_by_name('Seneschal', 'offices');
//   $tid = reset(array_keys($term));
function _regnum_configured_entityforms() {
  return array(
    'regnum_change' => array(
      'form-bundle' => 'regnum_change',
      'group-bundle' => 'officers',
      'user-identification-fields' => array(
        'name' => 'field_society_name',
        'mail' => 'field_email_address',
      ),
      'group-configuration' => array(
        'title-template' => '!branch !office',
        // 6 == 'administrator user' for 'officers' bundle; give to all officers by default
        'default-roles-for-all-members' => array(6),
        // We don't have any roles that we give to the owner, but not other admins (at the moment)
        'default-roles-for-owner' => array(),
        // Seneschal, followed by Web Minister
        'approver-offices' => array(84, 93),
      ),
    ),
  );
}

function regnum_form_alter(&$form, &$form_state) {
  global $user;
  if ($form['#form_id'] == 'regnum_change_entityform_edit_form') {
    if ($user->uid && !isset($form['#entity']->uid)) {
      //dpm($form_state);
      //dpm($user);
      foreach ($form as $key => $item) {
        if ($key == 'field_society_name') {
          $form[$key][LANGUAGE_NONE][0]['value']['#default_value'] = $user->name;
        }
        elseif ($key == 'field_email_address') {
          $form[$key][LANGUAGE_NONE][0]['value']['#default_value'] = $user->mail;
        }
        /*
            TODO: store location in user record; restore it here.
        elseif ($key == 'field_location') {
          $form[$key][LANGUAGE_NONE][0]['#default_value']['street'] = '123 Somewhere st.';
        }
        */
        else {
          foreach (_regnum_configured_entityforms() as $entityform_bundle => $info) {
            $field_map = _regnum_user_info_update_field_map($entityform_bundle);
            $user_wrapper = entity_metadata_wrapper('user', $user);
            foreach ($field_map as $key => $variable) {
              $form_item = $variable;
              if (array_key_exists($form_item, $form)) {
                $form[$form_item][LANGUAGE_NONE][0]['value']['#default_value'] = $user_wrapper->$variable->value();
              }
            }
          }
        }
      }
    }
  }
}

/**
 * Implement hook_entity_insert
 *
 * When a new regnum submission is saved, send a notification email
 * to concerned officers.
 *
 * TODO:  We should also add a validate method that rejects entries
 * that do not have a valid email address for the recipient.
 */
function regnum_entity_insert($entity, $type) {
  // We only care about EntityForms.
  if ($type == 'entityform') {
    $configured_forms = _regnum_configured_entityforms();
    if (array_key_exists($entity->type, $configured_forms)) {
      $submission = new EntityDrupalWrapper('entityform', $entity);
      // Send a confirmation to the submitter, then notify the
      // approvers that there is a Regnum request to process.
      _regnum_mail_notify('regnum_submission_confirmation', $submission);
      _regnum_mail_notify('regnum_form_submitted', $submission);
    }
  }
}

/**
 * Implement hook_permission
 *
 * We define an override permission that allows selected roles
 * to approve any submission of the specified type, even if
 * the approver is not a member of any group in the approval workflow.
 */
function regnum_permission() {
  $perms = array();

  foreach (_regnum_configured_entityforms() as $entityform_bundle => $info) {
    $perms['approve all submissions for ' . $entityform_bundle] = array(
      'title' => t('Approve all submissions for !bundle', array('!bundle' => $entityform_bundle)),
      'description' => t('Users with this permission will be able to approve all !bundle submissions, regardless of group membership roles.', array('!bundle' => $entityform_bundle)),
    );
  }
  $perms['create subdomain for any group'] = array(
    'title' => t('Create subdomain for any group'),
    'description' => t('Users with this permission will be able to create new subdomains for any branch group, regardless of group memebership.'),
  );

  return $perms;
}

/**
 * Convenience wrapper around user_access
 */
function regnum_user_access($entityform_bundle, $user = NULL) {
  return user_access('approve all submissions for ' . $entityform_bundle, $user);
}

/**
 * regnum_assign_officer
 *
 * This is called after a submitted regnum officer change request
 * form is approved.
 *
 * Assigns the specified user to an office in some branch group.
 * By default, the user will become the primary office holder;
 * however, it is also possible to assign deputies by this
 * method.
 *
 * If the specified user does not exist, a user record for the
 * user will be created.  An officer node will also be created
 * if one does not already exist.
 *
 * @param $user_officer_info
 *   Information about the office and office holder.
 *     'mail' (Required): email address for the officer
 *     'name' (Required if new): sca name of the officer
 *     'real-name': Legal name of the officer
 *     'phone-number': Primary phone number of the officer
 *     'alternate-phone': Alternate phone number of the officer
 *     'deputy': TRUE if the user is a deputy; FALSE for the
 *        primary office holder.  Defaults to FALSE if not specified.
 *     'title': The title for the officer. Will be given a default
 *        title if none specified.
 * @param $group_info
 *   Information about the group node that represents the
 *   office.  Identifies the field names of the taxonomy
 *   fields that control the branch group and officer identification
 *   for the group node.
 */
function regnum_assign_officer($user_officer_info, $group_info) {
  // Get a reference to the user and the office being assigned to.
  $user = _regnum_get_or_create_user($user_officer_info);

  // If the user's email address has been changed, then
  // update it in the user record.
  if (!empty($user_officer_info['mail'])) {
    $user->mail = $user_officer_info['mail'];
  }
  // Similarly, update the user's name if it has
  // changed.
  if (!empty($user_officer_info['name'])) {
    $user->name = $user_officer_info['name'];
  }
  // Update the user's field-based information
  $field_map = _regnum_user_info_update_field_map($group_info['form-bundle']);
  $user_wrapper = entity_metadata_wrapper('user', $user);
  foreach ($field_map as $key => $variable) {
    if (!empty($user_officer_info[$key])) {
      $user_wrapper->$variable->set($user_officer_info[$key]);
    }
  }
  $user_wrapper->save();

  return regnum_assign_user_to_office($user, $group_info, $user_officer_info['title'], $user_officer_info['deputy'], TRUE);
}

function regnum_assign_user_to_office($user, $group_info, $desiredTitle, $asDeputy = FALSE, $retain_former_officer = FALSE) {

  // If we create the node, we make it owned by the specified user;
  // by convention, group nodes are owned by the primary officer.
  // In the odd event that a deputy is assigned to an office that
  // does not exist (and therefore has no primary officer), then we
  // will create the node owned by anonymous (vacant).
  $owner_uid = $asDeputy ? 0 : $user->uid;
  $officer_node = _regnum_get_or_create_officer_node($group_info, $owner_uid);

  return _regnum_assign_user_to_officer_node_assign_roles($user, $officer_node, $desiredTitle, $asDeputy, $retain_former_officer, $group_info['default-roles-for-owner'], $group_info['default-roles-for-all-members']);
}

function regnum_assign_user_to_officer_node($user, $officer_node, $desiredTitle, $asDeputy = FALSE, $retain_former_officer = FALSE, $weight = 0) {

  $info = _regnum_configured_entityform_for_group($officer_node->type);

  $defaultRolesForOwner = $info['group-configuration']['default-roles-for-owner'];
  $defaultRolesForAllMembers = $info['group-configuration']['default-roles-for-all-members'];

  return _regnum_assign_user_to_officer_node_assign_roles($user, $officer_node, $desiredTitle, $asDeputy, $retain_former_officer, $defaultRolesForOwner, $defaultRolesForAllMembers, $weight);
}

function _regnum_assign_user_to_officer_node_assign_roles($user, $officer_node, $desiredTitle, $asDeputy, $retain_former_officer, $defaultRolesForOwner, $defaultRolesForAllMembers, $weight = 0) {

  // If the user is the primary officer (not a deputy), then
  // change the owner of the officer node to be the specified user.
  $former_officer_uid = FALSE;
  $former_officers_new_title = '';
  if ((!$asDeputy) && ($officer_node->uid != $user->uid)) {
    $former_officer_uid = $officer_node->uid;
    $officer_node->uid = $user->uid;
  }
  // Odd situation: if the current officer is approved as a deputy,
  // then set the owner to the anonymous user (vacant office).
  if (($asDeputy) && ($officer_node->uid == $user->uid)) {
    $officer_node->uid = 0;
    // Also revoke owner-default roles when the current owner is replaced with 'anonymous'
    foreach ($defaultRolesForOwner as $rid) {
      og_role_revoke('node', $officer_node->nid, $user->uid, $rid);
    }
  }
  $officer_page_wrapper = entity_metadata_wrapper('node', $officer_node);
  $officer_page_wrapper->save();
  // Determine if the user already is a member of the group.
  // If not, add the user to the group.
  // TODO: maybe subscribe via:
  //   $ogm = og_group('node', $officer_node->nid, array('entity' => $user->uid));
  // This is the sanctioned API.  Simplify this later.
  $ogm = og_get_membership('node', $officer_node->nid, 'user', $user->uid);
  if (!$ogm) {
    $ogm = og_membership_create('node', $officer_node->nid, 'user', $user->uid, 'og_user_node');
  }
  // Add default roles to the user
  $default_roles = $defaultRolesForAllMembers;
  if (!$asDeputy) {
    $default_roles += $defaultRolesForOwner;
  }
  foreach ($default_roles as $rid) {
    og_role_grant('node', $officer_node->nid, $user->uid, $rid);
  }

  // Force the weight to -10 for the first user
  if (!$asDeputy) {
    $weight = -10;
  }
  // If any other user has a weight of -10, bump
  // it down to -9.
  elseif ($uinfo['weight'] == -10) {
    $weight = -9;
  }

  // Set the member's deputy / officer title
  $ogm_wrapper = entity_metadata_wrapper('og_membership', $ogm);
  $ogm_wrapper->field_type_of_deputy->set($desiredTitle);
  $ogm_wrapper->field_weight->set($weight);
  $ogm_wrapper->save();

  // Should we keep the former officer listed as a deputy,
  // or remove the record?  For now, we retain the officer
  // as a 'Transitional Deputy ...' until manually deleted.
  if ($former_officer_uid) {
    $ogm_former = og_get_membership('node', $officer_node->nid, 'user', $former_officer_uid);
    if ($ogm_former) {
      if ($retain_former_officer) {
        $former_ogm_wrapper = entity_metadata_wrapper('og_membership', $ogm_former);
        // CONFIGURATION: How do we deal with re-titling former officers who are kept on as deputies?
        if (empty($former_officers_new_title)) {
          $former_officers_new_title = "Transitional Deputy " . $former_ogm_wrapper->field_type_of_deputy->value();
        }
        $former_ogm_wrapper->field_type_of_deputy->set($former_officers_new_title);
        $former_ogm_wrapper->field_weight->set(10);
        $former_ogm_wrapper->save();
        // Remove owner-only default roles whenever the owner becomes a deputy.
        foreach ($defaultRolesForOwner as $rid) {
          og_role_revoke('node', $officer_node->nid, $former_officer_uid, $rid);
        }
      }
      else {
        og_membership_delete($ogm_former->id);
      }
    }
  }
}

function regnum_remove_user_from_office($office_node, $uid) {
  // If the user being removed is the author of $office_nid,
  // then we need to make $office_nid owned by the anonymous user.
  if ($uid == $office_node->uid) {
    $office_node->uid = 0;
    node_save($office_node);
  }

  // Get the og membership object and delete it,
  // effectively removing the user from the group.
  $ogm_to_remove = og_get_membership('node', $office_node->nid, 'user', $uid);
  og_membership_delete($ogm_to_remove->id);
}

/**
 * Given a Regnum change submission, process the
 * request, assigning the specified user to the
 * desired office.
 *
 * @param $submission
 *   An EntityDrupalWrapper for the regnum_change entityform.
 *
 * To approve all submissions:
 *
 *   $toc = entityform_get_submissions('regnum_change');
 *   foreach ($toc as $id => $info) {
 *     $submission = new EntityDrupalWrapper('entityform', $id);
 *     regnum_approve_officer($submission);
 *   }
 */
function regnum_approve_officer($submission, $approver = null) {
  $regnum_form_bundle = $submission->getBundle();
  $field_map = _regnum_regnum_change_field_map($regnum_form_bundle);
  $user_info = _regnum_entity_to_data_array($submission, $field_map);
  $user_info = _regnum_fix_up_submission_data($user_info);
  $group_info = _regnum_group_info($submission);
  regnum_assign_officer($user_info, $group_info);
  // Mark $submission as approved, so that we do not show it again
  $submission->field_submission_status->set("approved");
  // If we were given an approver, then record it for posterity.
  if (isset($approver)) {
    $submission->field_submission_approver->set($approver->uid);
  }
  $submission->save();

  // Notify the user in the Regnum change, and all officers who can approve
  // this submission that the change was processed.
  _regnum_mail_notify('regnum_submission_approved', $submission);
}

function regnum_approve_officer_later($submission, $approver = null) {
  // Mark $submission as denied
  $submission->field_submission_status->set("auto");
  if (isset($approver)) {
    $submission->field_submission_approver->set($approver->uid);
  }
  $submission->save();
  // Notify all officers who can approve
  // this submission that the change was denied.
  _regnum_mail_notify('regnum_submission_approved_later', $submission);
}

function regnum_deny_request($submission, $approver = null) {
  // Mark $submission as denied
  $submission->field_submission_status->set("denied");
  // In this case, the approver is really the denier.
  if (isset($approver)) {
    $submission->field_submission_approver->set($approver->uid);
  }
  $submission->save();
  // Notify all officers who can approve
  // this submission that the change was denied.
  _regnum_mail_notify('regnum_submission_denied', $submission);
}

/**
 * Implement hook_cron()
 */
function regnum_cron() {
  foreach (_regnum_configured_entityforms() as $entityform_bundle => $info) {
    // Now iterate over all of the submissions.
    $toc = entityform_get_submissions($entityform_bundle);
    foreach ($toc as $id => $info) {
      $submission = new EntityDrupalWrapper('entityform', $id);

      // Look for all of the submissions that are in the 'auto'
      // approval state (make approval active on effective date)
      if ($submission->field_submission_status->value() == 'auto') {

        // TODO (Again): This presumes $dv['date_type'] == 'datetime'. Is there a Drupal API to do this?
        $dv = $submission->field_effective_date->value();
        $d = new DateTime($dv['value'], new DateTimeZone($dv['timezone']));
        $unixtime = $d->format('U');
        $effective_now = ($unixtime < time());
        if ($effective_now) {
          regnum_approve_officer($submission);
        }
      }
    }
  }
}

// If we need to find the groups that a user belongs to:
// $ drush ev '$u = user_load(4); return og_get_entity_groups("user", $u);'
// array(
//   'node' => array(
//     2 => '851',
//     22 => '889',
//     23 => '890',
//     25 => '892',
//   ),
// )

/**
 * Check if the provided user can approve the specified submission.
 *
 * TODO:  Use this to validate Regnum change requests.
 * If they are entered by someone who can approve the
 * submission, then offer to immediately approve it.
 */
function regnum_submission_is_approvable($submission, $the_user) {
  $approvable = FALSE;
  $regnum_form_bundle = $submission->getBundle();
  if (regnum_user_access($regnum_form_bundle, $the_user)) {
    return TRUE;
  }
  $users_groups = og_get_entity_groups("user", $the_user);
  if (array_key_exists('node', $users_groups)) {
    $users_groups = array_flip($users_groups['node']);
    $approval_offices = regnum_approval_offices_for_submission($submission);
    $users_approval_offices = array_intersect_key($approval_offices, $users_groups);
    if (!empty($users_approval_offices)) {
      $approvable = TRUE;
    }
  }
  return $approvable;
}

/**
 * Given a user ID or user record, return a list of submissions
 * that can be approved by the user.
 *
 * Note: This returns all submissions, including those that have
 * already been approved or denied.  This list must be post-processed
 * to remove undesired entries.
 */
function regnum_submissions_user_can_approve($the_user) {
  $result = array();

  // If a user id was passed in, load the user record
  if (!is_object($the_user)) {
    $the_user = user_load($the_user);
  }
  // Get the groups that the user is in.  It comes to us like this:
  // array(
  //   'node' => array(
  //     2 => '851',
  //     22 => '889',
  //     23 => '890',
  //     25 => '892',
  //   ),
  // )
  // We'll look at only the groups of type 'node', and will flip
  // the array around so that the group IDs are the key, and the
  // og_membership id is the value.
  //
  // We look this up now so that we do not need to get it
  $users_groups = og_get_entity_groups("user", $the_user);
  if (array_key_exists('node', $users_groups)) {
    $users_groups = array_flip($users_groups['node']);
  }
  foreach (_regnum_configured_entityforms() as $entityform_bundle => $info) {
    // Now iterate over all of the submissions.
    $toc = entityform_get_submissions($entityform_bundle);
    foreach ($toc as $id => $info) {
      $submission = new EntityDrupalWrapper('entityform', $id);
      $approval_offices = regnum_approval_offices_for_submission($submission);
      // Check to see if the user can approve all submissions of this type
      $approvable = regnum_user_access($id, $the_user);
      // If the user cannot approve all submissions, it might still be possible
      // that the user can approve this submission based on group membership.
      if (!empty($users_groups)) {
        $users_approval_offices = array_intersect_key($approval_offices, $users_groups);
        $approvable = !empty($users_approval_offices);
      }
      if ($approvable) {
        $approval_office_gids = array_keys($approval_offices);
        $primary_approver_gid = array_shift($approval_office_gids);
        // This user is the primary approver only if the
        // primary approver group is one of his groups, AND
        // he is the primary officer of that group.  Otherwise, he
        // is a secondary approver.
        $is_primary = array_key_exists($primary_approver_gid, $users_groups) && ($approval_offices[$primary_approver_gid]->uid = $the_user->uid);

        // Compose a result array that contains the submissions
        // the user can approve, along with information about
        // who else can approve the submission.
        $result[$id] = array(
          'submission' => $submission,
          'is-primary' => $is_primary,
          'approval-offices' => $approval_office_gids,
        );
      }
    }
  }

  return $result;
}

function regnum_test_approval_offices($submission) {
  if (is_numeric($submission)) {
    $submission = new EntityDrupalWrapper('entityform', $submission);
  }
  $approval_offices = regnum_approval_offices_for_submission($submission);
  $approvers = array();
  foreach ($approval_offices as $nid => $node) {
    $approvers[] = regnum_primary_officer($node, TRUE);
  }
  return $approvers;
}

/**
 * Given a Regnum change submission, return a list
 * of all of the offices ('offices' og group nodes)
 * that have the right to approve the submission.
 *
 * The first office in the returned array is always
 * the "primary approver".  The other offices in the
 * list also have the ability to approve the submission,
 * but by convention should only do so if they know
 * that the primary approver approves of this action.
 */
function regnum_approval_offices_for_submission($submission) {
  $approval_offices = array();
  $approval_name = FALSE;
  $heirarchy_name = FALSE;

  $group_info = _regnum_group_info($submission);

  if (!empty($group_info['approver-offices'])) {
    // Load the vocabulary machine name for the first taxonomy term
    // in the listed approver offices (e.g. Seneschal, Web Minister, etc.).
    // Regardless of the configuration, these should all be in the same
    // vocabulary.
    // For example, in the Kingdom of the West, the approver offices
    // are array(84, 93), which are the taxonomy term ids for
    // "Seneschal" and "Web Minister", respectively (primary and backup).
    $primary_approver_tid = reset($group_info['approver-offices']);
    $term = taxonomy_term_load($primary_approver_tid);
    $approval_vocabulary = $term->vocabulary_machine_name;

    // Get a reference to the taxonomy term ids that will be
    // used later to identify group nodes.  This will return
    // something like:
    //  array(
    //    'office' => 84
    //    'branch' => 2
    //  )
    // In other words, the name of the vocabulary, and the id
    // of a taxonomy term in that vocabulary.  In the example above,
    // 84 is "Seneschal" and 2 is "The Kingdom of the West".  This
    // indicates that this submission is an application for the
    // position of Kingdom Seneschal.
    $tids = $group_info['tids'];

    // Now find the name (label) of the approval term -- which is
    // used to determine which taxononmy term indicates the group
    // node that approves submissions -- and the heirarchy term --
    // which is used to determine which taxonomy term indicates the
    // group node that is in charge of subordinate groups.
    // For the Kingdom of the West, the approval name will therefore
    // be 'office' and the heirarchy name will be 'branch'.
    foreach ($tids as $name => $tid) {
      $term = taxonomy_term_load($tid);
      if ($term->vocabulary_machine_name == $approval_vocabulary) {
        $approval_name = $name;
      }
      else {
        $heirarchy_name = $name;
      }
    }

    if ($approval_name) {
      // First, find the "primary approver".  The primary
      // approver is the first officer indicated in 'approver-offices',
      // for the same branch in the heirarchy (if any)
      // UNLESS the primary approver is the same office that the
      // applicant is applying for, in which case the primary
      // approver is the same office from the parent group (if any).
      // For applications for deputy positions, the "primary approver"
      // is simply the office that is being applied for.
      $primary_approver_tids = $tids;
      if (!$submission->field_deputy->value()) {
        if ($primary_approver_tids[$approval_name] != $primary_approver_tid) {
          $primary_approver_tids[$approval_name] = $primary_approver_tid;
        }
        elseif($heirarchy_name) {
          $parents = taxonomy_get_parents($primary_approver_tids[$heirarchy_name]);
          if ($parents) {
            $parent = reset($parents);
            // HACK: Do not go upt to Corpora here.
            if ($parent->name != "Society for Creative Anachronism Corpora") {
              $primary_approver_tids[$heirarchy_name] = $parent->tid;
            }
          }
        }
      }
      // Add the primary approver to the approval offices.
      _regnum_add_approval_office($approval_offices, $group_info, $primary_approver_tids);

      // We will allow the Seneschal and Web Minister of
      // the same branch group to be alternate approvers
      // for the Regnum change.
      $tids = $primary_approver_tids;
      _regnum_add_approval_offices($approval_offices, $group_info, $tids, $approval_name, $group_info['approver-offices']);

      // Next, we'll walk up the branch group hierarchy
      // until we get to the top.  Note that the top is
      // Corporate, which we do not process.  Note also
      // that we do not bother anyone other than the officers
      // of the immediate group with approval requests
      // of deputies.
      if (!$submission->field_deputy->value() && $heirarchy_name && array_key_exists($heirarchy_name, $tids)) {
        // We will only admit to at most one parent per branch group.
        $parents = taxonomy_get_parents($tids[$heirarchy_name]);
        while ($parents) {
          $parent = reset($parents);
          $tids[$heirarchy_name] = $parent->tid;
          _regnum_add_approval_offices($approval_offices, $group_info, $tids, $approval_name, $group_info['approver-offices']);
          // For each branch group above the first, we allow,
          // as an alternate approver, the Seneschal, the Web
          // Minister, and the officer above the office
          $parents = taxonomy_get_parents( $tids[$heirarchy_name]);
        }
      }
    }
  }
  return $approval_offices;
}

function _regnum_add_approval_office(&$approval_offices, $group_info, $tids) {
  $approver = _regnum_get_officer_node($group_info['group-bundle'], $group_info['field-map'], $tids);
  if (($approver) && !array_key_exists($approver->nid, $approval_offices)) {
    $approval_offices[$approver->nid] = $approver;
  }
}

function _regnum_add_approval_offices(&$approval_offices, $group_info, $tids, $approval_name, $approver_officer_list) {
  foreach ($approver_officer_list as $tid) {
    $tids[$approval_name] = $tid;
    _regnum_add_approval_office($approval_offices, $group_info, $tids);
  }
}

function _regnum_get_or_create_officer_node($group_info, $owner_uid) {
  $node = _regnum_find_officer_node($group_info);
  if (!$node) {
    $node = _regnum_create_officer_node($group_info, $owner_uid);
  }
  return $node;
}

function _regnum_find_officer_node($group_info) {
  return _regnum_get_officer_node($group_info['group-bundle'], $group_info['field-map'], $group_info['tids']);
}

// Search for all of the submissions with a given email address.
// This might be used for something in the future.
function _regnum_get_submissions($email) {
  $query = new EntityFieldQuery();
  $query = $query->entityCondition('entity_type','entityform')
    ->fieldCondition('field_email_address', 'value', $email, '=');
  $entities = $query->execute();

  return $entities;
}

function _regnum_get_officer_node($group_bundle, $field_map, $tids) {
  $node = FALSE;
  $query = new EntityFieldQuery();
  $query = $query->entityCondition('entity_type','node')
    ->entityCondition('bundle', array($group_bundle))
    ->propertyCondition('status', 1); // it might actually cause a problem to include this
  foreach ($tids as $name => $value) {
    $field = $field_map[$name];
    $query = $query->fieldCondition($field, 'tid', $value, '=');
  }
  $entities = $query->execute();
  if (!empty($entities)) {
    // There should never be more than one officer node
    $nids = array_keys($entities['node']);
    $node = node_load($nids[0]);
  }
  return $node;
}

function _regnum_create_officer_node($group_info, $owner_uid) {
  $replacements = _regnum_map_to_dt_data($group_info['data']);
  $node = new stdClass();
  $node->type = 'officers';
  node_object_prepare($node);
  $node->title = t($group_info['title-template'], $replacements);
  $node->language = LANGUAGE_NONE;
  //$node->created = strtotime($item->created_on);
  $node->uid = $owner_uid;

  $description = '';
  foreach ($group_info['tids'] as $term_name => $tid) {
    $field_name = $group_info['field-map'][$term_name];
    $term = taxonomy_term_load($tid);
    // TODO: Need to check configuration or something to identify the
    // taxonomy term whose description holds the origial contents of
    // the officer node body. For now, we hardcode '3', which is right
    // for the SCA.  If there is no term with vid 3, the node just
    // starts out empty, is all.
    if ($term->vid == 3) {
      $description = $term->description;
    }
    $node->{$field_name}[$node->language][] = array('tid' => $tid);
  }

  // TODO: We should add a field to $office_term that contains the
  // template text for new officer nodes that we can use here.
  $node->body[$node->language][0] = array(
    'value' => $description,
    'format' => '1',
  );

  // n.b. Pathauto hooks fire, so node will be given a standard-format url
  node_save($node);

  // TODO: make sure that the 'institutional-email' address (if specified)
  // is saved in the og_contact "Additional Recipients" field.

  return $node;
}

function _regnum_get_user($user_info) {
  $user_info += array(
    'name' => '',
    'mail' => '',
  );
  $query = "SELECT uid FROM {users} WHERE name = :name OR mail = :mail";
  $parameters[':mail'] = $user_info['mail'];
  $parameters[':name'] = $user_info['name'];
  if (empty($user_info['name'])) {
    $query = "SELECT uid FROM {users} WHERE mail = :mail";
    unset($parameters[':name']);
  }
  elseif (empty($user_info['mail'])) {
    $query = "SELECT uid FROM {users} WHERE name = :name";
    unset($parameters[':mail']);
  }

  $result = db_query($query, $parameters);
  $uid = $result->fetchField();
  $user = $uid ? user_load($uid) : NULL;

  return $user;
}

function _regnum_get_or_create_user($user_info) {
  $user_info += array(
    'name' => '',
    'mail' => '',
  );
  $user = _regnum_get_user($user_info);
  // If the user record does not exist, then create it.
  if (!isset($user)) {
    $pass = _regnum_random_password();
    $new_user = array(
      'name' => $user_info['name'],
      'pass' => $pass,
      'mail' => $user_info['mail'],
      'access' => '0',
      'status' => 1,
    );
    $new_user_object = user_save(NULL, $new_user, NULL);
    $uid = $new_user_object->uid;
    $user = user_load($uid);
  }

  return $user;
}

/**
 * Given the bundle name of an entityform that feeds into
 * the Regnum change process, return the configuration information
 * about that bundle.  In particular, this provides the name
 * of the bundle that should be used as the group node for
 * this entityform.
 */
function _regnum_configured_entityform($regnum_form_bundle) {
  $configured_forms = _regnum_configured_entityforms();
  $result = isset($configured_forms[$regnum_form_bundle]) ? $configured_forms[$regnum_form_bundle] : array();
  return $result;
}

function _regnum_configured_entityform_for_group($group_bundle) {
  $configured_forms = _regnum_configured_entityforms();
  $result = array();
  foreach ($configured_forms as $entityform_bundle => $info) {
    if ($info['group-bundle'] == $group_bundle) {
      $result = $info;
    }
  }
  return $result;
}

/**
 * Return a mapping of all of the field names that appear in
 * the given entityform that are relevant for processing a
 * Regnum Change submission.
 *
 * The 'key' of the result is the simple name of the field
 * (i.e. the flag that you would use to identify it via a
 * drush option); in particular, 'name' and 'mail' are significant,
 * as these map to the user's name and email address in the
 * user object.
 *
 * The 'value' of the result is the field name that maps to
 * the corresponding key.
 */
function _regnum_regnum_change_field_map($regnum_form_bundle) {
  $form_info = _regnum_configured_entityform($regnum_form_bundle);
  $form_field_instances = field_info_instances('entityform', $regnum_form_bundle);

  $result = array();

  // Get the field name for the user 'name' and 'mail' fields.
  // The admin should indicate these on the configuration page,
  // but at the moment they are hardcoded into _regnum_configured_entityform().
  $special_fields = array_flip($form_info['user-identification-fields']);
  foreach (array_keys($form_field_instances) as $field) {
    if (array_key_exists($field, $special_fields)) {
      $name = $special_fields[$field];
      $result[$name] = $field;
    }
  }

  return $result + _regnum_user_info_update_field_map($regnum_form_bundle) + _regnum_group_field_map($regnum_form_bundle, $form_info['group-bundle']) +
  array(  // CONFIGURATION: here are some extra fields that we need to account for somehow
    'deputy' => 'field_deputy',
    'title' => 'field_type_of_deputy',
    'info' => 'field_additional_information',
    'institutional-email' => 'field_institutional_memory_email',
  );
/*
  return array(
    'name' => 'field_society_name',
    'real-name' => 'field_real_name',
    'branch' => 'taxonomy_vocabulary_2',
    'office' => 'field_office',
    'deputy' => 'field_deputy',
    'title' => 'field_type_of_deputy',
    'mail' => 'field_email_address',
    'phone-number' => 'field_phone_number',
    'alternate-phone' => 'field_alternate_phone',
    'membership-id' => 'field_membership_number',
    'info' => 'field_additional_information',
  );
*/
}

/**
 * This function returns the name and field name of every
 * field in the Regnum Change submission form that also appears
 * in a user object.
 */
function _regnum_user_info_update_field_map($regnum_form_bundle) {
  $user_field_instances = field_info_instances('user', 'user');
  return _regnum_entity_field_map($regnum_form_bundle, $user_field_instances);
}

/**
 * This function returns the name and field name of every field
 * in the Regnum Change submission form that also appears in
 * the group node for the office.
 */
function _regnum_group_field_map($regnum_form_bundle, $group_bundle) {
  $group_field_instances = field_info_instances('node', $group_bundle);
  return _regnum_entity_field_map($regnum_form_bundle, $group_field_instances);
}

/**
 * This function returns the vocabulary name and default value (key
 * and value, respectively) of every taxonomy field in the specified
 * group bundle.
 */
function _regnum_group_taxonomy_fields($group_bundle) {
  $result = array();
  $group_field_instances = field_info_instances('node', $group_bundle);
  foreach ($group_field_instances as $key => $info) {
    // If the field in question is a taxonomy term field, and
    // if it has a default value, then the default value should
    // be stored as a tid.  If we do have a tid default value,
    // then we know this is a taxonomy term field.
    $is_taxonomy_field = FALSE;
    $default_value = NULL;
    if (  isset($info['default_value']) &&
          is_array($info['default_value']) &&
          isset($info['default_value'][0]) &&
          is_array($info['default_value'][0]) &&
          isset($info['default_value'][0]['tid'])) {
      $default_value = $info['default_value'][0]['tid'];
      $is_taxonomy_field = TRUE;
    }
    // If there is no default value, then how can we tell if this
    // is a taxonomy field?  I'm not sure.  We'll check to see
    // if there are any display modes that use taxonomy formatters.
    // Maybe there is a better way?
    elseif (array_key_exists('display', $info)) {
      foreach ($info['display'] as $mode => $mode_info) {
        if (strstr($mode_info['type'], 'taxonomy') !== FALSE) {
          $is_taxonomy_field = TRUE;
        }
      }
    }
    if ($is_taxonomy_field) {
      // TODO: "$key" is not actually the vocabulary for the
      // taxonomy term field.  For our branch taxonomy field,
      // it happens to be the same, but for our officer taxonomy
      // field, the key is "field_office", whereas the vocabulary
      // is "offices".  There must be some way to map from the
      // field info to the taxonomy vocabulary that it uses, as
      // the UI needs this information.  For now, just hack it
      // in.
      $vocabulary = $key;
      if ($key == 'field_office') {
        $vocabulary = 'offices';
      }
      if ($key == 'taxonomy_vocabulary_2') {
        $vocabulary = 'vocabulary_2';
      }
      $result[] = array('field-name' => $key, 'vocabulary' => $vocabulary, 'default' => $default_value);
    }
  }
  return $result;
}

/**
 * Return the info about the group that is / will be associated
 * with the specified Regnum change submission.
 *
 * Example:
 *
 * array(
 *   'form-bundle' => 'regnum_change',
 *   'group-bundle' => 'officers',
 *   'title-template' => '!branch !office',
 *   'field-map' => array(
 *     'office' => 'field_office',
 *     'branch' => 'taxonomy_vocabulary_2',
 *   ),
 *   'data' => array(
 *     'office' => 'Web Minister',
 *     'branch' => 'Kingdom of the West',
 *   ),
 *   'tids' => array(
 *     'office' => '93',
 *     'branch' => '2',
 *   ),
 * )
 */
function _regnum_group_info($submission) {
  $regnum_form_bundle = $submission->getBundle();
  $form_info = _regnum_configured_entityform($regnum_form_bundle);
  $field_map = _regnum_group_field_map($regnum_form_bundle, $form_info['group-bundle']);
  $data = _regnum_entity_to_data_array($submission, $field_map);
  // TODO: only returns the first value of multi-value taxonomy term fields.
  $tids = _regnum_entity_to_tids($submission, $field_map);
  $group_info = array(
    'form-bundle' => $regnum_form_bundle,
    'group-bundle' => $form_info['group-bundle'],
    'field-map' => $field_map,
    'data' => $data,
    'tids' => $tids,
  ) + $form_info['group-configuration'];
  return $group_info;
}

/**
 * Examine the fields of two entity types, and return a list
 * of all of the fields that appear in common between the two.
 */
function _regnum_entity_field_map($regnum_form_bundle, $entity_field_instances) {
  $form_field_instances = field_info_instances('entityform', $regnum_form_bundle);
  $result = array();

  // Find every field in the regnum form that also exist
  // in the user object.
  foreach (array_keys($form_field_instances) as $key) {
    $name = FALSE;
    if (array_key_exists($key, $entity_field_instances)) {
      if (substr($key,0,6) == 'field_') {
        $name = strtr(substr($key, 6), '_', '-');
      }
      if (substr($key,0,9) == 'taxonomy_') {
        $name = strtr(substr($key, 9), '_', '-');
        // CONFIGURATION: rename 'vocabulary-2' to 'branch'
        if ($name == 'vocabulary-2') {
          $name = 'branch';
        }
      }
    }
    if ($name) {
      $result[$name] = $key;
    }
  }
  return $result;
/*
  return array(
    'real-name' => 'field_real_name',
    'phone-number' => 'field_phone_number',
    'alternate-phone' => 'field_alternate_phone',
    'membership-id' => 'field_membership_number',
  );
*/
}

// TODO: This should probably call through to a Drupal hook,
// so that customizations can be done in an external module.
function _regnum_fix_up_submission_data($data) {
  if (empty($data['title'])) {
    if ($data['deputy']) {
      $data['office'] = "Deputy " . $data['office'];
    }
    $data['title'] = str_replace(array_keys($data), array_values($data), "branch office");
  }
  return $data;
}

function _regnum_map_to_dt_data($map) {
  $dt_data = array();
  foreach ($map as $key => $value) {
    $dt_data['!' . $key] = $value;
  }
  return $dt_data;
}

function _regnum_entity_to_data_array($e, $field_map) {
  $data = array();
  foreach ($field_map as $key => $variable) {
    $data[$key] = $e->$variable->value();
    if (!is_string($data[$key]) && !is_bool($data[$key])) {
      $a = (array)$data[$key];
      if (is_array($a) && !empty($a) && is_object($a[0]) && isset($a[0]->tid)) {
        $data[$key] = $a[0]->name;
      }
      else {
        $data[$key] = '';
      }
    }
  }
  return $data;
}

function _regnum_entity_to_tids($e, $field_map) {
  $tids = array();
  foreach ($field_map as $key => $variable) {
    // TODO: This is for multi-value fields. Single-value fields will just be an object.
    $a = (array)$e->$variable->value();
    if (is_array($a) && !empty($a) && is_object($a[0]) && isset($a[0]->tid)) {
      $tids[$key] = $a[0]->tid;
    }
  }
  return $tids;
}

function _regnum_random_password($length=16) {
  $vowels = 'aeuyAEUY@#$*23456789';
  $consonants = 'bdghjmnpqrstvzBDGHJLMNPQRSTVWXZ';
  $password = '';
  for ($i = 0; $i < $length; $i++) {
    if ($i % 2) {
      $password .= $consonants[(rand() % strlen($consonants))];
    } else {
      $password .= $vowels[(rand() % strlen($vowels))];
    }
  }
  return $password;
}

/**
 * Implementation of hook_block_info().
 */
function regnum_block_info() {
  $blocks['regnum_approvals'] = array(
    'info' => t('Regnum Change Approval List'),
    'cache' => DRUPAL_NO_CACHE,
  );
  $blocks['regnum_create_domain'] = array(
    'info' => t('Regnum Create Domain'),
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implementation of hook_block_view().
 */
function regnum_block_view($delta = '') {
  $block = array();
  global $user;

  switch ($delta) {
    // This block shows up only on a user's home page.
    case 'regnum_approvals':
      $content = '';
      $user_page = menu_get_object('user', 1);
      if (($user_page != NULL) && ($user != NULL) && ($user->uid == $user_page->uid)) {
        $result = regnum_submissions_user_can_approve($user);
        $result = regnum_remove_approved_forms($result);
        foreach ($result as $id => $info) {
          $submission = $info['submission'];
          $regnum_form_bundle = $submission->getBundle();
          $field_map = _regnum_regnum_change_field_map($regnum_form_bundle);
          $user_info = _regnum_entity_to_data_array($submission, $field_map);
          $user_info = _regnum_fix_up_submission_data($user_info);
          $content .= l(t("!name: !title.", _regnum_map_to_dt_data($user_info)), "regnum/$id/confirm") . '</br>';
        }
      }
      if (!empty($content)) {
        $block['subject'] = t('Approval List for ' . $user->name);
        $block['content'] = t($content);
      }
      break;

    case 'regnum_create_domain':
      $content = '';
      $node = menu_get_object('node', 1);
      if (($node != NULL) && ($user != NULL)) {
        $current_page = new EntityDrupalWrapper('node', $node);
        foreach (_regnum_configured_entityforms() as $entityform_bundle => $info) {
          // If this is an 'officers' page
          if ($node->type == $info['group-bundle']) {
            $can_create_subdomain =  user_access('create subdomain for any group', $user);
            if (!$can_create_subdomain) {
              // TODO: we should check to see if the user is a member of this
              // page, OR of any page that is a parent officer page for this page.
              $ogm = og_get_membership('node', $node->nid, 'user', $user->uid);
              if ($ogm) {
                $can_create_subdomain = TRUE;
              }
            }
            if ($can_create_subdomain) {
              $field_map = _regnum_group_field_map("regnum_change", "officers");
              $officer_field_name = $field_map['office'];
              $officer_term = $current_page->$officer_field_name->value();
              $officer_term = reset($officer_term);
              if (in_array($officer_term->tid, $info['group-configuration']['approver-offices'])) {
                // look up the domain whose sitename == $branch_term->name.
                $branch_field_name = $field_map['branch'];
                $branch_term = $current_page->$branch_field_name->value();
                $branch_term = reset($branch_term);
                $domain = _regnum_domain_sitename_load($branch_term->name);
                // If the domain does not exist, then show a block offering to create it.
                if (empty($domain)) {
                  $block['subject'] = t('Domain for ' . $branch_term->name);
                  $block['content'] = drupal_get_form('regnum_create_subdomain', $branch_term->tid);
                }
              }
            }
          }
        }
      }
      break;
  }
  return $block;
}

function regnum_remove_approved_forms($submission_list) {
  $result = array();
  foreach($submission_list as $id => $info) {
    $submission = $info['submission'];
    if ($submission->field_submission_status->value() != "approved") {
      $result[$id] = $info;
    }
  }
  return $result;
}

/**
 * Implement hook_menu
 */
function regnum_menu() {
  $items = array();

  $items['regnum/%/confirm'] = array(
    'title' => 'Confirm Regnum Change Submission',
    'description' => 'Approve or deny a submitted Regnum change submission.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('regnum_submission_confirm_form', 1),
    'access callback' => 'regnum_submission_access',
    'access arguments' => array(1),
  );

  $items['regnum/%/warrant'] = array(
    'title' => 'Warrant of Appointment to Office',
    'description' => 'Display warrant to be signed for Regnum Change Submission.',
    'page callback' => 'regnum_warrant',
    'page arguments' => array(1),
    'access callback' => 'regnum_submission_access',
    'access arguments' => array(1),
  );

  $items['regnum/pending'] = array(
    'title' => 'Pending regnum change submissions',
    'description' => 'Show list of all pending regnum change submissions.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('regnum_pending_submissions_form'),
    'access arguments' => array('administer users'),
  );

  $items['admin/config/regnum'] = array(
    'title' => 'Regnum change submission settings',
    'description' => 'Configure default behavior of Regnum change submissions, particularly the email confirmation templates.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('regnum_admin_settings'),
    'access arguments' => array('administer users'),
    'file' => 'regnum.admin.inc',
    'weight' => -10,
  );

  return $items;
}

function regnum_warrant($submission_id) {
  $submission_entity = entityform_load($submission_id);
  $submission = new EntityDrupalWrapper('entityform', $submission_entity);

  $image_dir = drupal_get_path('module', 'regnum') . '/images';
  $letterhead = $image_dir . '/warrant_letterhead.png';


  $variables = array();
  foreach ($submission->getPropertyInfo() as $varname => $info) {
    if ((substr($varname, 0, 6) == 'field_') || (substr($varname, 0, 9) == 'taxonomy_')) {
      $value = $submission->$varname->value();
      if (!isset($value)) {
        $value = '';
      }
      if (is_array($value)) {
        if (array_key_exists(0, $value) && is_object($value[0])) {
          $value = $value[0];
        }
        if (array_key_exists('timezone', $value)) {
          $d = new DateTime($value['value2'], new DateTimeZone($value['timezone']));
          $variables[$varname . '_end'] = $d->format('Y F d');
          $d = new DateTime($value['value'], new DateTimeZone($value['timezone']));
          $value = $d->format('Y F d');
        }
      }
      if (is_object($value)) {
        if (isset($value->tid)) {
          $value = $value->name;
        }
      }
      if (is_string($value)) {
        $variables[$varname] = $value;
      }
    }
  }
  //$info = var_export($variables, TRUE);
  //$info = var_export($submission_entity, TRUE);
  //$info = var_export($submission->getPropertyInfo(), TRUE);
  $location = $submission_entity->field_location[LANGUAGE_NONE][0];
  //$info = var_export($location, TRUE);
  $variables['field_address'] = $location['street'] . ' ' . $location['city'] . ' ' . $location['province'] . ' ' . $location['postal_code'];
  extract($variables);
  // $field_type_of_deputy

  $as = $herald = $chirugeon = $chronicler =  $marshal = $other = '&nbsp;';
  $other_office = "_____________________";
  $check = "&#x2713;";
  switch ($field_office) {
    case "Marshal":
    case "Heavy Marshal":
      $marshal = $check;
      break;
    case "Arts":
    case "Sciences":
      $as = $check;
      break;
    case "Chirugeon":
      $chirugeon = $check;
      break;
    case "Chronicler":
      $chronicler = $check;
      break;
    case "Herald":
      $herald = $check;
      break;
    default;
      $other = $check;
      $other_office = $field_office;
      break;
  }
  echo "<html>
  <head>
    <title>Warrant of Appointment to Office</title>

    <style type='text/css'>
      body {
        font-size: 24pt;
        width: 100%;
        margin: 60px auto 60px auto;
        max-width: 1360px;
      }

      .block {
        margin: 30px;
      }

      .border {
        border: 2px solid black;
      }

      .full {
        width: 90%;
      }

      .half {
        float: left;
        width: 45%;
      }

      .letterhead, h1 {
        text-align: center;
      }

      .letterhead img {
        width: 95%;
      }

      .fields p b {
        font-variant: small-caps;
      }

      .fields p {
        border-bottom: 1px solid black;
        width: 100%;
      }

      .warrant-info {
        padding: 10px;
        font-size: 18pt;
      }

      .warrant-info p {
        margin: 0;
        padding: 0;
      }

      .office-selection {
        margin-right: 20px;
      }

      #footer {
        clear: both;
        text-align: center;
        font-style: italic;
      }

      #personal-info,
      #office-of-appointment,
      #footer {
        margin-top: 120px;
      }

      .clear {
        clear: both;
      }
    </style>
  </head>
  <body>
    <div class='letterhead'>
      <img src='/$letterhead' alt='Society for Creative Anachronism'>
    </div>
    <h1>Warrant of Appointment to Office</h1>

    <div id='personal-info' class='fields full block'>
      <p><b>Legal Name:</b> $field_real_name</p>
      <p><b>Address:</b> $field_address</p>
      <p><b>Telephone: (Home)</b> $field_phone_number <b>(Other)</b> $field_alternate_phone</p>
      <p><b>EMail Address:</b> $field_email_address <b>Member Number:</b> $field_membership_number</p>
      <p><b>SCA Reference Name:</b> $field_society_name</p>
    </div>

    <div id='office-of-appointment' class='full block'>
      <p class='proclamation'>
        Let it be known that the above-referenced person is hereby appointed to the office of
      </p>
      <p class='office-list'>
        <span class='office-selection'>[ $as ] A & S Officer</span>
        <span class='office-selection'>[ $herald ] Herald</span>
        <span class='office-selection'>[ $chirugeon ] Chirugeon</span>
        <span class='office-selection'>[ $chronicler ] Chronicler</span>
        <span class='office-selection'>[ $marshal ] Marshal</span>
        <span class='office-selection'>[ $other ] $other_office</span>
      </p>
      <div class='fields'>
        <p class='branch'>
          <b>For branch:</b> $taxonomy_vocabulary_2
        </p>
        <p class='effective-date'>
          <b>Effective as of:</b> $field_effective_date <b>And expiring as of:</b> $field_effective_date_end
        </p>
      </div>
      <p>
        with all rights, privileges, insignia, precedence, and responsibilities
        thereto appertaining the office while the Warrant is effective. This
        Warrant supersedes any existing or previous Warrant for this office.
      </p>
    </div>

    <div class='signatures-and-info'>
      <div class='signature fields half block'>
        <p><b>Print:</b></p>
        <p><b>Sign:</b></p>
        <p><b>Office:</b></p>
      </div>
      <div class='signature fields half block'>
        <p><b>Print:</b></p>
        <p><b>Sign:</b></p>
        <p><b>Office:</b></p>
      </div>
      <div class='signature fields half block'>
        <p><b>Print:</b></p>
        <p><b>Sign:</b></p>
        <p><b>Office:</b></p>
      </div>
      <div class='half block border'>
        <div class='warrant-info'>
          <p><b>Required signatures:</b></p>
          <p><b>Corporate and Society Officers:</b> three members of the SCA Board of Directors</p>
          <p><b>Deputy Corporate / Society officers:</b> two Board members and the appropriate Corporate / Society officer.</p>
          <p><b>Kingdom Officers with Corporate Superiors:</b> Crown and the appropriate Coprorate Officer</p>
          <p><b>Other Great Officers and Lesser Officers:</b> Crown or Coronet and the appropriate kingdom or principality officer, if any.</p>
          <p><b>Other officers:</b> as established by Kingdom Law and custom, but must include more than one signature, and must include royalty.</p>
        </div>
      </div>

      <div class='clear'></div>
    </div>

    <div id='footer' class='full block'>
      This form may be photocopied or reproduced in any mechanical medium that preserves the complete text and letterhead image.
    </div>
  </body>
</html>";
  exit;
}

function regnum_pending_submissions_form($form, &$form_state) {
  global $user;
  $result = regnum_submissions_user_can_approve($user);
  $result = regnum_remove_approved_forms($result);

  foreach ($result as $id => $info) {
    $submission = $info['submission'];
    $regnum_form_bundle = $submission->getBundle();
    $field_map = _regnum_regnum_change_field_map($regnum_form_bundle);
    $user_info = _regnum_entity_to_data_array($submission, $field_map);
    $user_info = _regnum_fix_up_submission_data($user_info);
    // $submission_list[] = '<li>' . l(t("!name: !title.", _regnum_map_to_dt_data($user_info)), "regnum/$id/confirm") . '<pre>' . var_export($user_info, true) . '</pre></li>';

    $submission_render_array = entityform_page_view($submission);
    $form_element_id = 'submission-' . $id;

    $form[$form_element_id] = array(
      '#type' => 'fieldset',
      '#title' => t("!name: !title.", _regnum_map_to_dt_data($user_info)),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $form[$form_element_id]['info'] = $submission_render_array;

    $form[$form_element_id]['export'] = array(
      '#markup' => '<pre>' . var_export($user_info, true) . '</pre>',
    );

    $form[$form_element_id]['id'] = array(
      '#type' => 'hidden',
      '#value' => $id,
      '#attributes' => array('id' => $form_element_id . '-id')
    );
    $form[$form_element_id]['edit'] = array(
      '#markup' => l("#$id", "regnum/$id/confirm"),
    );
  }

  if (empty($result)) {
    $form['no-submissions'] = array(
      '#markup' => t('<p><b>No pending regnum submissions.</p>'),
    );
  }

  return $form;
}


function regnum_submission_confirm_form($form, &$form_state, $submission_id) {
  global $user;
  $submission_entity = entityform_load($submission_id);
  $submission = new EntityDrupalWrapper('entityform', $submission_entity);
  $regnum_form_bundle = $submission->getBundle();

  $field_map = _regnum_regnum_change_field_map($regnum_form_bundle);
  $user_info = _regnum_entity_to_data_array($submission, $field_map);
  $user_info = _regnum_fix_up_submission_data($user_info);
  $content = t("!name has applied for !title.", _regnum_map_to_dt_data($user_info)) . '<br>';

  // TODO: This presumes $dv['date_type'] == 'datetime'. Is there a Drupal API to do this?
  $dv = $submission->field_effective_date->value();
  $d = new DateTime($dv['value'], new DateTimeZone($dv['timezone']));
  $unixtime = $d->format('U');
  $effective_now = ($unixtime < time());

/*
  dpm($submission->field_effective_date->value());
  dpm();
  //dpm(dateapi_convert_datetime_to_timestamp($submission->field_effective_date));
  dpm(time());
*/

  $submission_render_array = entityform_page_view($submission_entity);

  $form['info'] = $submission_render_array;
  $form['submission-id'] = array(
    '#type' => 'hidden',
    '#value' => $submission_id,
    '#attributes' => array('id' => 'submission')
  );
  $approvable = regnum_submission_is_approvable($submission, $user);

  $submission_status = $submission->field_submission_status->value();
  if (($submission_status == 'approved') || ($submission_status == 'denied')) {
    $form['status-indicator'] = array(
      '#markup' => '<p><b>' . t('This submission is already %status', array('%status' => $submission_status)) . '</b></p>',
    );
    $approvable = false;
  }

  if ($approvable) {
    if ($effective_now) {
      $form['approve_button'] = array(
        '#type' => 'submit',
        '#value' => t('Confirm'),
        '#submit' => array('regnum_submission_confirm_form_approve'),
      );
    }
    else {
      $form['approve_button'] = array(
        '#type' => 'submit',
        '#value' => t('Confirm Now'),
        '#submit' => array('regnum_submission_confirm_form_approve'),
      );
      $form['approve_later_button'] = array(
        '#type' => 'submit',
        '#value' => t('Confirm on Effective Date'),
        '#submit' => array('regnum_submission_confirm_form_approve_later'),
      );
    }
    $form['deny_button'] = array(
      '#type' => 'submit',
      '#value' => t('Deny'),
      '#submit' => array('regnum_submission_confirm_form_deny'),
    );
  }
  $form['edit_button'] = array(
    '#type' => 'submit',
    '#value' => t('Edit'),
    '#submit' => array('regnum_submission_confirm_form_edit'),
  );
  $form['cancel_button'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel'),
    '#submit' => array('regnum_submission_confirm_form_cancel'),
  );

  return $form;
}

function regnum_submission_confirm_form_validate($form, &$form_state) {
}

function regnum_submission_access($submission_id) {
  global $user;
  $submission = new EntityDrupalWrapper('entityform', $submission_id);
  // Anyone who can approve the form can see it.
  $approvable = regnum_submission_is_approvable($submission, $user);
  if ($approvable) {
    return TRUE;
  }
  // Users may also see their own form if they are logged in
  // using an account with the same email address as the one
  // on the form.
  if (isset($user->mail) && ($user->mail == $submission->field_email_address->value())) {
    return TRUE;
  }
  return FALSE;
}

function regnum_submission_confirm_form_approve($form, &$form_state) {
  global $user;
  $submission_id = $form['submission-id']['#value'];
  $submission = new EntityDrupalWrapper('entityform', $submission_id);
  $approvable = regnum_submission_is_approvable($submission, $user);
  if ($approvable) {
    regnum_approve_officer($submission, $user);
    drupal_set_message(t("Submission approved."), 'ok');
  }
  else {
    drupal_set_message(t("You do not have access rights to approve this Regnum change submission."), 'error');
  }
  drupal_goto("user");
}

function regnum_submission_confirm_form_approve_later($form, &$form_state) {
  global $user;
  $submission_id = $form['submission-id']['#value'];
  $submission = new EntityDrupalWrapper('entityform', $submission_id);
  $approvable = regnum_submission_is_approvable($submission, $user);
  if ($approvable) {
    regnum_approve_officer_later($submission, $user);
    drupal_set_message(t("Submission approved, and will become active on the effective date."), 'ok');
  }
  else {
    drupal_set_message(t("You do not have access rights to approve this Regnum change submission."), 'error');
  }
  drupal_goto("user");
}

function regnum_submission_confirm_form_deny($form, &$form_state) {
  global $user;
  $submission_id = $form['submission-id']['#value'];
  $submission = new EntityDrupalWrapper('entityform', $submission_id);
  $approvable = regnum_submission_is_approvable($submission, $user);
  if ($approvable) {
    regnum_deny_request($submission, $user);
    drupal_set_message(t("Submission denied."), 'ok');
  }
  else {
    drupal_set_message(t("You do not have access rights to deny this Regnum change submission."), 'error');
  }
  drupal_goto("user");
}

function regnum_submission_confirm_form_edit($form, &$form_state) {
  $submission_id = $form['submission-id']['#value'];
  drupal_goto("entityform/$submission_id/edit", array('query' => array('destination' => 'regnum/' . $submission_id . '/confirm')));
}

function regnum_submission_confirm_form_cancel($form, &$form_state) {
  drupal_goto("user");
}

function regnum_test() {
  $field_info_bundles = field_info_bundles('entityform');
  foreach (_regnum_configured_entityforms() as $entityform_bundle => $info) {
    $field_map = _regnum_group_field_map($entityform_bundle, $info['group-bundle']);
    $field_map = _regnum_user_info_update_field_map($entityform_bundle);
    return $field_map;
  }
}

/**
 * @defgroup tokens Token replacement
 * @{
 */

/**
 * Hook token_info
 *
 * Declare tokens for fields on the submission form
 */
function regnum_token_info() {
  // First, the tokens for all regnum forms
  $submission['url'] = array(
    'name' => t("Submission URL"),
    'description' => t('URL to the submission.'),
  );
  $submission['warrant'] = array(
    'name' => t("Submission URL"),
    'description' => t('URL to a filled-out warrant form for the submission.'),
  );
  $submission['name'] = array(
    'name' => t("Submitter Name"),
    'description' => t('Name of the submitter, as entered on the form.'),
  );
  $submission['mail'] = array(
    'name' => t("Submitter email"),
    'description' => t('Email address of the submitter, as entered on the form.'),
  );
  $submission['deputy'] = array(
    'name' => t("Deputy"),
    'description' => t('Either "deputy" or "officer", depending on whether the submitter requested a deputy position or not.'),
  );
  $submission['title'] = array(
    'name' => t("Title"),
    'description' => t('Office title requested by the submitter.'),
  );
  $submission['additional_information'] = array(
    'name' => t("Additional information"),
    'description' => t('Any additional information provided by the submitter.'),
  );
  $submission['approver'] = array(
    'name' => t("Approver"),
    'description' => t('The officer who approved the submission.'),
  );
  $submission['primary_approver'] = array(
    'name' => t("Approver"),
    'description' => t('The primary approver responsible for this submission.'),
  );
  $submission['alternate_approvers'] = array(
    'name' => t("Alternate approvers"),
    'description' => t('Other officers who may also approve this submission.'),
  );
  $submission['approver_summary'] = array(
    'name' => t("Approver Summary"),
    'description' => t('Summary of who can approve the Regnum change request.'),
  );

  // Next, include the dynamic fields
  $field_info_bundles = field_info_bundles('entityform');
  foreach (_regnum_configured_entityforms() as $entityform_bundle => $info) {
    $field_map = _regnum_group_field_map($entityform_bundle, $info['group-bundle']);
    $field_map += _regnum_user_info_update_field_map($entityform_bundle);
    foreach ($field_map as $field => $value) {
      $key = strtr($field, '-', '_');
      $submission[$key] = array(
        'name' => t("Field '!key'", array('!key' => $key)),
        'description' => t("User-supplied value for the field '!field'", array('!field' => $field)),
      );
    }
  }

  return array( 'submission' => $submission );
}

function regnum_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'submission' && !empty($data['submission'])) {
    $submission = $data['submission'];
    $recipient = isset($data['recipient']) ? $data['recipient'] : NULL;
    $entityform_bundle = $submission->getBundle();

    $field_map = _regnum_regnum_change_field_map($entityform_bundle);
    $user_info = _regnum_entity_to_data_array($submission, $field_map);
    $user_info = _regnum_fix_up_submission_data($user_info);
    $group_info = _regnum_group_info($submission);

    $user = _regnum_get_user($user_info);
    $approval_offices = FALSE;
    foreach ($tokens as $name => $original) {
      $key = strtr($name, '_', '-');
      switch ($name) {
        case 'url':
          $replacements[$original] = 'http://' . $_SERVER['SERVER_NAME'] . '/regnum/' . $submission->entityform_id->value() . '/confirm';
          break;
        case 'warrant':
          $replacements[$original] = 'http://' . $_SERVER['SERVER_NAME'] . '/regnum/' . $submission->entityform_id->value() . '/warrant';
          break;
        case 'name':
          $replacements[$original] = $user_info['name'];
          break;
        case 'mail':
          $replacements[$original] = $user_info['mail'];
          break;
        case 'deputy':
          $replacements[$original] = $user_info['deputy'] ? t("Deputy") : t("Primary officer");
          break;
        case 'title':
          $replacements[$original] = $user_info['title'];
          break;
        case 'additional_information':
          $replacements[$original] = $user_info['info'];
          break;
        case 'approver':
          $replacements[$original] = 'tbd';
          break;
        case 'primary_approver':
        case 'alternate_approvers':
        case 'approver_summary':
          $lines = array();
          if (!$approval_offices) {
            $approval_offices = regnum_approval_offices_for_submission($submission);
          }
          if (empty($approval_offices)) {
            $lines[] = t("No approvers.");
          }
          else {
            // Make two lists: a single-item list
            // with the office of the primary approver,
            // and another list with all of the offices
            // of the alternate approvers.
            $alternate_approvers = $approval_offices;
            $primary_approver = array_shift($alternate_approvers);
            $list = array();
            $is_secondary = FALSE;
            if ($name == 'approver_summary') {
              if (isset($recipient) && ($primary_approver->uid == $recipient->uid)) {
                $lines[] = t("You are the primary officer responsible for approving this Regnum change request.");
                $lines[] = "";
                $list = $alternate_approvers;
              }
              else {
                $lines[] = t("The primary officer responsible for approving this request is:");
                $lines[] = "";
                $lines[] = regnum_primary_officer($primary_approver);
                $lines[] = "";
                foreach ($alternate_approvers as $nid => $node) {
                  if (isset($recipient) && ($node->uid == $recipient->uid)) {
                    $is_secondary = TRUE;
                  }
                  else {
                    $list[$nid] = $node;
                  }
                }
              }
              if ($is_secondary) {
                $lines[] = t("You are an alternate approver for this Regnum change request.");
                $lines[] = "";
              }
              if (!empty($list)) {
                $lines[] = t("Other officers who may serve as alternate approvers for this request include:");
                $lines[] = "";
              }
            }
            else {
              // Pick the list to render based on our token
              $list = ($name == 'primary_approver') ? array($primary_approver) : $alternate_approvers;
            }
            // If there is a list of officer nodes, then convert it
            // to a list of primary officers, and add it to the result.
            foreach ($list as $nid => $node) {
              $officer_name_and_title = regnum_primary_officer($node);
              if ($officer_name_and_title) {
                $lines[] = $officer_name_and_title;
              }
            }
          }
          $replacements[$original] = implode("\n", $lines);
          break;
        default:
          if (array_key_exists($key, $user_info)) {
            $replacements[$original] = $user_info[$key];
          }
          break;
      }
    }
  }
  return $replacements;
}

/**
 * Return the name and title of the primary officer for the
 * given office node.
 *
 * Ex:
 *   Gregor Eilburg, West Kingdom Web Minister
 */
function regnum_primary_officer($node, $vacant_ok = FALSE) {
  if (!is_object($node)) {
    return NULL;
  }
  $office_title = $node->title;
  $office_holder_uid = $node->uid;
  if ($office_holder_uid > 0) {
    $office_holder = user_load($office_holder_uid);
    return $office_holder->name . ', ' . $office_title;
  }
  elseif ($vacant_ok) {
    return $office_title . t(" (vacant)");
  }
  return NULL;
}

function regnum_officer_name_replacements($node) {
  if (!is_object($node)) {
    return NULL;
  }
  $replacements = array();
  $replacements['!title'] = $node->title;
  $office_holder_uid = $node->uid;
  if ($office_holder_uid > 0) {
    $office_holder = user_load($office_holder_uid);
    $replacements['!name'] = $office_holder->name;
    $replacements['!comma'] = ', ';
    $replacements['!vacant'] = '';
  }
  else {
    $replacements['!name'] = '';
    $replacements['!comma'] = '';
    $replacements['!vacant'] = t("(vacant)");
  }
  return $replacements;
}

/**
 * @} End of "Token replacement".
 */

/**
 * @defgroup email Email notification
 * @{
 */

/**
 * Send a notification email when a certain Regnum operation happens.
 *
 * @see regnum_mail_tokens()
 * @see drupal_mail()
 *
 * @param $op
 *   The operation being performed. Possible values:
 *   - 'regnum_form_submitted': A Regnum change request was submitted.
 *   - 'regnum_submission_approved': A Regnum change was approved.
 *
 * @param $submission
 *   The entity form of the Regnum form.
 * @param $language
 *   Optional language to use for the notification, overriding account language.
 *
 * @return
 *   The return value from drupal_mail_system()->mail(), if ends up being
 *   called.
 */
function _regnum_mail_notify($op, $submission, $language = NULL) {
  // By default, we notify.
  $notify = variable_get('regnum_mail_' . $op . '_notify', TRUE);
  if ($notify) {
    $params['submission'] = $submission;

    // Pull out user and group info from the submission
    $regnum_form_bundle = $submission->getBundle();
    $field_map = _regnum_regnum_change_field_map($regnum_form_bundle);
    $user_info = _regnum_entity_to_data_array($submission, $field_map);
    $user_info = _regnum_fix_up_submission_data($user_info);
    $group_info = _regnum_group_info($submission);

    $account = _regnum_get_user($user_info);
    if ($account) {
      $params['account'] = $account;
    }

    // Determine who to send this email message to.
    $send_to = explode(',', _regnum_mail_text($op . '_send_to'));

    // TODO: We should add a field to the submission, and use it to store
    // which notifications have been sent.  That way, we could also add tokens
    // that say "The submitter has [or has not] been notified that this request
    // was received".
    foreach ($send_to as $destination) {
      switch ($destination) {
        case 'configured':
          // First, notify regnum@westkingdom.org
          // TODO: Add a preference where people can configure the notification address.
          $mail = drupal_mail('regnum', $op, 'regnum@westkingdom.org', $language, $params);
          break;

        case 'officers':
          if (module_exists("og_contact")) {
            $approval_offices = regnum_approval_offices_for_submission($submission);
            $additional_recipients = array();
            foreach ($approval_offices as $nid => $node) {
              if (og_contact_group_has_form($nid)) {
                // Load og_contact.pages.inc, which contains og_contact_get_recipients().
                module_load_include('inc', 'og_contact', 'og_contact.pages');
                $group_recipients = og_contact_get_recipients($nid);
                // We do not need to break up $group_recipients; we could pass it
                // to drupal_mail as-is.  However, we want to vary our tokens based
                // on the recipient of the email, and for that we'll need to call
                // drupal_mail once per message.  Additionally, should some user
                // happen to appear in the recipients list more than once, then we'd
                // like to insure that they only recieve ONE email.  To do that, we
                // put all of the recipients into an associative array, so that duplicates
                // are automatically combined.
                foreach (explode(',', $group_recipients) as $recipient) {
                  $additional_recipients[$recipient] = $recipient;
                }
              }
            }
            foreach ($additional_recipients as $recipient) {
              $recipient_user = _regnum_get_user(array('mail' => $recipient));
              $params_copy = $params;
              $params_copy['recipient'] = $recipient_user;
              $mail = drupal_mail('regnum', $op, $recipient, $language, $params_copy);
            }
          }
          break;

        case 'submitter':
          $recipient = $user_info['mail'];
          $recipient_user = _regnum_get_user(array('mail' => $recipient));
          $params_copy = $params;
          $params_copy['recipient'] = $recipient_user;
          $mail = drupal_mail('regnum', $op, $recipient, $language, $params_copy);
          break;
      }
    }
  }
  return empty($mail) ? NULL : $mail['result'];
}

/**
 * Implements hook_mail().
 */
function regnum_mail($key, &$message, $params) {
  $language = $message['language'];

  $variables['user'] = $params['account'];
  $variables['submission'] = $params['submission'];
  if (isset($params['recipient'])) {
    $variables['recipient'] = $params['recipient'];
  }

  $message['subject'] .= _regnum_mail_text($key . '_subject', $language, $variables);
  $message['body'][] = _regnum_mail_text($key . '_body', $language, $variables);
}

/**
 * Returns a mail string for a variable name.
 */
function _regnum_mail_text($key, $language = NULL, $variables = array(), $replace = TRUE) {
  $langcode = isset($language) ? $language->language : NULL;

  if ($admin_setting = variable_get('regnum_mail_' . $key, FALSE)) {
    // An admin setting overrides the default string.
    $text = $admin_setting;
  }
  else {
    // No override, return default string.
    switch ($key) {
      case 'regnum_submission_confirmation_send_to':
        $text = "submitter";
        break;
      // IMPORTANT: No tokens containing user-supplied values should be used here.
      case 'regnum_submission_confirmation_subject':
        $text = t('Thank you for your Regnum submission for [submission:branch] [submission:office]', array(), array('langcode' => $langcode));
        break;
      // IMPORTANT: The submission confirmation email is sent back to whatever
      // email address the submitter provides.  Therefore, no tokens containing
      // user-supplied values should be used here; otherwise, a spammer might
      // attempt to use this form as an open relay to deliver content to arbitrary
      // email addresses.
      case 'regnum_submission_confirmation_body':
        $text = t("Your submission was sent to the following Officers:

[submission:primary_approver]
[submission:alternate_approvers]

You will be notified once your submission is processed.

Thank you for your patience.

--  [site:name] team", array(), array('langcode' => $langcode));
        break;

      case 'regnum_form_submitted_send_to':
        $text = "configured,officers";
        break;
      case 'regnum_form_submitted_subject':
        $text = t('Regnum change request made by [submission:name] at [site:name]', array(), array('langcode' => $langcode));
        break;
      case 'regnum_form_submitted_body':
        $text = t("[submission:name] submitted a Regnum change request.

Name                      : [submission:name]
Real name                 : [submission:real_name]
Email address             : [submission:mail]
Phone number              : [submission:phone_number]
Alternate phone           : [submission:alternate_phone]
Membership number         : [submission:membership_number]

Branch group              : [submission:branch]
Office                    : [submission:office]
Deputy or Primary officer : [submission:deputy]
Requested title           : [submission:title]

Additional information provided by the submitter:

[submission:additional_information]

[submission:approver_summary]

Deputies of the above-named officers may also serve as alternate approvers.
Alternate approvers should insure that the requested change is acceptable
to the primary approver before processing the approval on the web site.
The primary approver should insure that the change is acceptable to the
Crown or Coronet before proceding, if such approval is necessary.

Please insure that applicant provided a personal email address in the change
request.  Any request that uses an 'officer@westkingdom.org' or any sort of
shared or \"institutional memory\" account should be rejected.

You can view the request here:

[submission:url]

--  [site:name] team", array(), array('langcode' => $langcode));
        break;

      case 'regnum_submission_approved_send_to':
        $text = "submitter,configured,officers";
        break;
      case 'regnum_submission_approved_subject':
        $text = t('Regnum change approved for [submission:name] at [site:name]', array(), array('langcode' => $langcode));
        break;
      case 'regnum_submission_approved_body':
        $text = t("The Regnum change request made by [submission:name] was approved.

Name                      : [submission:name]
Real name                 : [submission:real_name]
Email address             : [submission:mail]
Phone number              : [submission:phone_number]
Alternate phone           : [submission:alternate_phone]
Membership number         : [submission:membership_number]

Branch group              : [submission:branch]
Office                    : [submission:office]
Deputy or Primary officer : [submission:deputy]
Requested title           : [submission:title]

Thank you,

--  [site:name] team", array(), array('langcode' => $langcode));
        break;

      case 'regnum_submission_approved_later_send_to':
        $text = "submitter,configured,officers";
        break;
      case 'regnum_submission_approved_later_subject':
        $text = t('Regnum change approved for [submission:name] at [site:name]', array(), array('langcode' => $langcode));
        break;
      case 'regnum_submission_approved_later_body':
        $text = t("The Regnum change request made by [submission:name] was approved, and will become active on the effective date.

Name                      : [submission:name]
Real name                 : [submission:real_name]
Email address             : [submission:mail]
Phone number              : [submission:phone_number]
Alternate phone           : [submission:alternate_phone]
Membership number         : [submission:membership_number]

Branch group              : [submission:branch]
Office                    : [submission:office]
Deputy or Primary officer : [submission:deputy]
Requested title           : [submission:title]

Thank you,

--  [site:name] team", array(), array('langcode' => $langcode));
        break;

      case 'regnum_submission_denied_send_to':
        $text = "configured,officers";
        break;
      case 'regnum_submission_denied_subject':
        $text = t('Regnum change denied for [submission:name] at [site:name]', array(), array('langcode' => $langcode));
        break;
      case 'regnum_submission_denied_body':
        $text = t("The Regnum change request made by [submission:name] was denied.

Name                      : [submission:name]
Real name                 : [submission:real_name]
Email address             : [submission:mail]
Phone number              : [submission:phone_number]
Alternate phone           : [submission:alternate_phone]
Membership number         : [submission:membership_number]

Branch group              : [submission:branch]
Office                    : [submission:office]
Deputy or Primary officer : [submission:deputy]
Requested title           : [submission:title]

Thank you,

--  [site:name] team", array(), array('langcode' => $langcode));
        break;

      default:
        $text = '';
        break;
    }
  }

  /*
  // Debug
  if (strstr($key, 'body') !== FALSE) {
    foreach (array('submission:office', 'submission:branch', 'submission:real_name', 'submission:phone_number', 'submission:alternate_phone', 'submission:membership_number', 'submission:name', 'submission:mail', 'submission:deputy', 'submission:approver', 'submission:alternate_approvers') as $id) {
    $text .= "$id : [$id]\n";
   }
  */

  if ($replace) {
    // We do not sanitize the token replacement, since the output of this
    // replacement is intended for an e-mail message, not a web browser.
    $text = token_replace($text, $variables, array('language' => $language, 'callback' => 'regnum_mail_tokens', 'sanitize' => FALSE, 'clear' => TRUE));
  }

  return $text;
}

/**
 * Token callback to add tokens for regnum mails.
 *
 * This function is used by the token_replace() call at the end of
 * _regnum_mail_text() to set up some additional tokens that can be
 * used in email messages generated by regnum_mail().
 *
 * @param $replacements
 *   An associative array variable containing mappings from token names to
 *   values (for use with strtr()).
 * @param $data
 *   An associative array of token replacement values.
 * @param $options
 *   Unused parameter required by the token_replace() function.
 */
function regnum_mail_tokens(&$replacements, $data, $options) {
  /*
  $e = $data['submission'];
  $c = entity_view("entityform", $e, "full");
  $t = drupal_html_to_text(drupal_render($c));
  replacements['[submission:summary]'] = $t;
  */
}

/**
 * @} End of "Email notification".
 */

/**
 * @defgroup filters Text input filters
 * @{
 */

/**
 * Implements hook_filter_info().
 */
function regnum_filter_info() {
  $filters['filter_officer'] = array(
    'title' => t('Officer Filter (regnum)'),
    'description' => t('Every instance of "[:Office:]" will be replaced with the current office holder in the current branch group.  If an officer in another group is desired, "[:Branch/Office:]" may be used.  Alternately, "[:^/Office:]" is shorthand for the specified office in the group immediately above the current group.'),
    'process callback'  => '_regnum_filter_officer_process',
    'default settings' => array(
      '[:West Kingdom/Web Minister:]' => 'Gregor Eilburg',
    ),
    'settings callback' => '_regnum_filter_officer_settings',
    'tips callback' => '_regnum_filter_officer_tips',
  );
  return $filters;
}

/**
 * Settings callback for regnum officer filter
 *
 * The settings defined in this form are stored in database by the filter
 * module, and they will be available in the $filter argument.
 */
function _regnum_filter_officer_settings($form, $form_state, $filter, $format, $defaults) {
  $settings['group_shorten_function'] = array(
    '#type' => 'textfield',
    '#title' => t('Function name of routine that will shorten branch group names.'),
    '#default_value' => isset($filter->settings['group_shorten_function']) ? $filter->settings['group_shorten_function'] : '', // $defaults['group_shorten_function'],
    '#description' => t('This function is called for each branch group taxononmy term to return the shorthand form for that group.')
  );
  return $settings;
}

/**
 * Return all of the taxonomy terms associated with each
 * configured entityform.
 */
function _regnum_configured_taxonomy_sets() {
  $configured_forms = _regnum_configured_entityforms();
  foreach ($configured_forms as $entityform_bundle => $info) {
    $taxonomy_fields = _regnum_group_taxonomy_fields($info['group-bundle']);
    // Ignore any set that does not have at least two taxonomy tern fields
    // (branch and office).
    if (count($taxonomy_fields) >= 2) {
      $taxonomy_sets[$entityform_bundle] = $taxonomy_fields;
    }
  }
  return $taxonomy_sets;
}

function _regnum_filter_officer_process($text, $filter, $format) {
  $shorten_function = isset($filter->settings['group_shorten_function']) ? $filter->settings['group_shorten_function'] : 'bar';
  $replacements = array();
  $image_attributes = array();

  //
  // Regular expresion is:
  //
  //    \[:                     # [:
  //          ([^\]:/~]*)       #     any number of characters except ], :, ~ or /
  //          /*                #     an optional /
  //          ([^\]:/~]*)       #     any number of characters except ], :, ~ or /
  //          (~[^\]:/~]*|)     #     a tilde followed by some characters, or nothing
  //    :                       # :
  //    (
  //    [i]*                    #     any number of flags. So far, i is the only valid flag
  //    )
  //    \]                      # ]
  //    (
  //       \(                   #  (
  //           [^)]*            #     any number of characters except )
  //       \)                   #  )
  //       |                    #     or nothing
  //    )
  //
  // We use PREG_SET_ORDER, so that $matches is returned as an array of
  // match sets, where, for the string "[:branch/office:]" the corresponding
  // match set will contain:
  //
  //    array('[:branch/office:]', 'branch', 'office')
  //
  // And, for the string "[:office:]", the match set will contain:
  //
  //    array('[:office:]', 'office', '')
  //
  if (preg_match_all('#\[:([^\]:/~]*)/*([^\]:/~]*)(~[^\]:/~]*|):([i]*)\](\([^)]*\)|)#', $text, $matches, PREG_SET_ORDER)) {
    // For each configured entity form, get the set of taxonomy terms
    // that we can potentially look up in.
    $configured_forms = _regnum_configured_entityforms();
    $taxonomy_sets = _regnum_configured_taxonomy_sets();
    // Process all of the matches, looking for suitable entries
    // in the taxonomy term sets for the branch and office that was specified.
    foreach ($matches as $match_set) {
      $template = '!name!comma!title';
      if (empty($match_set[2])) {
        $branch = '';
        $office = $match_set[1];
        // If there is no branch specified, then we presume that the
        // branch is set by the name of the current domain.
        // TODO: Should we just require domain access, so we don't need to test?
        if (module_exists('domain')) {
          $domain_info = domain_get_domain();
          if (array_key_exists('sitename', $domain_info)) {
            $branch = $domain_info['sitename'];
          }
        }
      }
      else {
        $branch = $match_set[1];
        $office = $match_set[2];
      }
      $deputy = $match_set[3];
      $flags = $match_set[4];
      if (!empty($match_set[5])) {
        $template = substr($match_set[5], 1, -1);
      }
      // If we cannot find a matching taxonomy term, then we will replace
      // the token with an empty string.
      $replacement = '';
      foreach ($taxonomy_sets as $entityform_bundle => $taxonomy_set) {
        // We will presume that the taxonomy set that was built for
        // us was constructed such that the first entry is the branch,
        // and the second entry is the office.  If we can find a tid for
        // both the branch and the office, then we have a match; otherwise,
        // we will go on to the next taxonomy set (there will be only
        // one for the West Kingdom).
        // TODO: Should we also allow the user to specify a short name
        // for their term?  This would require a slower search.  Maybe
        // we could build a cache of name => tid for each entityform bundle.
        $branch_vocabulary = $taxonomy_set[0]['vocabulary'];
        $branch_term = taxonomy_get_term_by_name($branch, $branch_vocabulary);
        $office_vocabulary = $taxonomy_set[1]['vocabulary'];
        $office_term = taxonomy_get_term_by_name($office, $office_vocabulary);
        if (!empty($office_term)) {
          $term_info = reset($office_term);
          $office_tid = $term_info->tid;
          if (!empty($branch_term)) {
            $term_info = reset($branch_term);
            $branch_tid = $term_info->tid;
          }
          // Found!  If we have a branch and an office, then look up the
          // officer node.
          if (isset($branch_tid)) {
            $officer_node = FALSE;
            $group_bundle = $configured_forms[$entityform_bundle]['group-bundle'];
            $field_map = _regnum_group_field_map($entityform_bundle, $group_bundle);
            $tid_map[$taxonomy_set[0]['field-name']] = $branch_tid;
            $tid_map[$taxonomy_set[1]['field-name']] = $office_tid;
            $tids = array();
            foreach ($field_map as $name => $field_name) {
              $tids[$name] = $tid_map[$field_name];
            }
            $officer_node = _regnum_get_officer_node($group_bundle, $field_map, $tids);
            if ($officer_node) {
              $link_replacements = regnum_officer_name_replacements($officer_node);
              $url = 'node/' . $officer_node->nid . '/contact';
              $replacement = l(t($template, $link_replacements), $url, array('attributes' => array('class' => array('officer-link'))));
              // If the user requested an icon, then assume that the
              // first attached field of type field_item_image is the
              // one we want to use.  Usually, there should only be one
              // image field on an officer taxonomy term.
              if (strpos($flags, "i") !== FALSE) {
                $e = entity_metadata_wrapper("taxonomy_term", $office_tid);
                $image_field_name = FALSE;
                foreach ($e->getPropertyInfo() as $id => $info) {
                  if ($info['type'] == 'field_item_image') {
                    $image_field_name = $id;
                    $img_info = $e->$image_field_name->value();
                    $replacement = theme_image(array("path" => $img_info['uri'], "title" => $link_replacements['!title'], "attributes" => $image_attributes)) . " $replacement";
                    break;
                  }
                }
              }
            }
          }
        }
      }
      // What do we do if the replacement is not found at all?
      // Currently, we erase it ($replacement will be empty).
      $replacements[$match_set[0]] = $replacement;
    }
  }
  return str_replace(array_keys($replacements), array_values($replacements), $text);
}

/**
 * Filter tips callback for regnum officer filter.
 */
function _regnum_filter_officer_tips($filter, $format, $long = FALSE) {
  if (!$long) {
    // This string will be shown in the content add/edit form
    return t('<em>[:Office:]</em> replaced with the name of the officer currently holding the office.', array());
  }
  else {
    return t('Every instance of "[:Office:]" will be replaced with the current office holder in the current branch group.  If an officer in another group is desired, "[:Branch/Office:]" may be used.', array());
  }
}

/**
 * @} End of "Text input filters".
 */


/**
 * Return the appropriate domain record for the specified
 * sitename.
 *
 * @param sitename Name of the domain, or a taxonomy term
 * corresponding with the desired domain.
 */
function _regnum_domain_sitename_load($sitename, $full = FALSE) {
  // Convert from taxonomy term to string
  if (is_object($sitename) && isset($sitename->name)) {
    $sitename = $sitename->name;
  }
  if (is_array($sitename) && isset($sitename['name'])) {
    $sitename = $sitename['name'];
  }
  // If we don't have a valid sitename, return empty (no domain).
  if (!is_string($sitename)) {
    return array();
  }
  // Do a domain lookup on the sitename.
  $domain = db_query('SELECT domain_id, subdomain, sitename, scheme, valid, weight, is_default, machine_name FROM {domain} WHERE sitename = :sitename', array(':sitename' => $sitename))->fetchAssoc();
  if ($full && !empty($domain)) {
    domain_api($domain, TRUE);
  }
  return $domain;
}

/**
 * Return the taxonomy term corresponding with the branch
 * group for the specified domain.
 */
function regnum_domain_taxonomy_term($domain = FALSE) {
  if (!$domain) {
    $domain = domain_get_domain();
  }
  $branch = $domain['sitename'];
  $taxonomy_sets = _regnum_configured_taxonomy_sets();
  foreach ($taxonomy_sets as $entityform_bundle => $taxonomy_set) {
    $branch_vocabulary = $taxonomy_set[0]['vocabulary'];
    $branch_term = taxonomy_get_term_by_name($branch, $branch_vocabulary);
    return reset($branch_term);
  }
  return FALSE;
}

/**
 * Returns a list of taxonomy terms corresponding with
 * the parents of the specified domain.
 */
function regnum_domain_parent_term_list($domain = FALSE) {
  $result = array();
  $branch_term = regnum_domain_taxonomy_term($domain);
  if ($branch_term) {
    $branch_tid = $branch_term->tid;
    $parents = taxonomy_get_parents($branch_term->tid);
    while ($parents) {
      // Only look at the first parent (there should not be more than one)
      $parent_term = reset($parents);
      $result[$parent_term->tid] = (array)$parent_term;
      $parents = taxonomy_get_parents($parent_term->tid);
    }
  }
  return $result;
}

function regnum_create_subdomain($form, &$form_state, $domain) {
  // TODO: we should figure out what the path for the domain would
  // be, and figure out if DNS has been configured correctly.  We
  // should include a message that says that everything is okay, or
  // gives instructions on how to test.

  $form['description'] = array(
    '#type' => 'item',
    '#markup' => t('A subdomain does not exist for this branch yet. You may create it if you wish.'),
  );
  // This is the first form element. It's a textfield with a label, "Name"
  $form['domain'] = array(
    '#type' => 'hidden',
    '#value' => $domain,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Create',
  );
  return $form;
}

// TODO: validate the form -- insure that user is allowed to create this domain, etc.

function regnum_create_subdomain_submit(&$form_state) {
  $branch_tid = $form_state['domain']['#value'];
  $branch_term = taxonomy_term_load($branch_tid);
  $domain = regnum_domain_add($branch_term);
  // Redirect to our newly-created domain.
  // If we created the domain from 'dev.', then
  // redirect to 'dev.' when going to the new url.
  drupal_goto(_regnum_add_prefix_to_url(_regnum_domain_prefix(), $domain['path']));
}

function _regnum_domain_prefix() {
  $current_domain = domain_get_domain();
  $path_without_scheme = preg_replace('#https*://#', '', $current_domain['path']);
  $path_without_scheme = preg_replace('#/$#', '', $path_without_scheme);
  $prefix = preg_replace('#' . $path_without_scheme . '#', '', $current_domain['subdomain']);

  return $prefix;
}

function _regnum_add_prefix_to_url($prefix, $url) {
  return preg_replace('#://#', '://' . $prefix, $url);
}

function regnum_domain_add($branch_term) {
  $start_weight = (int) db_query("SELECT weight FROM {domain} ORDER BY weight DESC")->fetchField();
  $sitename = $branch_term->name;
  // Look up the default domain and get its URL.
  $default_domain = domain_default();
  $domain_base_url = $default_domain['subdomain'];
  // TODO: need to call shortname via a hook. For now, make an illegal cross-module call to wk
  $subdomain = _wk_term_short_name($branch_term);
  // Remove spaces and illegal characters from the short name.
  // TODO: make a function to get the subdomain short name
  $subdomain = strtolower(preg_replace('/[^A-Za-z]*/', '', $subdomain));
  $record = array(
    'subdomain' => $subdomain . '.' . $domain_base_url,
    'sitename' => $sitename,
    'valid' => 1,
    'scheme' => 'http',
    'weight' => $start_weight + 1,
    'is_default' => 0,
  );
  $domain = domain_save($record, $record);
  if (isset($domain['domain_id'])) {
    regnum_domain_initialize($domain);
  }
  return $domain;
}

function regnum_domain_initialize($domain) {
  $branch_term = regnum_domain_taxonomy_term($domain);
  $sitename = $domain['sitename'];

  // Create a new home page for the new domain, if one has
  // not already been set.
  $homepage_default_text = t("This is the recognized website for the !branch.", array('!branch' => $branch_term->name));

  $node = new stdClass();
  $node->type = 'page'; // TODO: what content type?
  node_object_prepare($node);
  $node->title = $sitename;
  $node->language = LANGUAGE_NONE;
  //$node->created = strtotime($item->created_on);
  $node->uid = 1; // TODO: find $owner_uid; should be the web minister for the new domain

  $node->body[$node->language][0] = array(
    'value' => $homepage_default_text,
    'format' => '1',
  );
  $node->domain_site = 0;
  $node->domain_source = $domain['domain_id'];
  $node->domains = array($domain['domain_id'] => $domain['domain_id']);
  $node->og_group_ref = array();
  $node->revision_moderation = FALSE;
  $node->is_pending = FALSE;
  $node->status = TRUE;

  // n.b. Pathauto hooks fire, so node will be given a standard-format url
  node_save($node);

  $homepage_path = 'node/' . $node->nid;
  // Save the path to the new homepage as this domain's front page
  domain_conf_variable_set($domain['domain_id'], 'site_frontpage', "$homepage_path");

  // If there is no main menu, create one
  $main_menu_name = domain_conf_variable_get($domain['domain_id'], 'menu_main_links_source');
  if (empty($main_menu_name) || ($main_menu_name == 'main-menu')) {
    // TODO: create a menu for this domain. This should also be called via a hook
    $menu = _wk_create_branch_menu($branch_term, $homepage_path);
    // set the created menu as the domain's main menu
    domain_conf_variable_set($domain['domain_id'], 'menu_main_links_source', $menu["menu_name"]);
  }

  // Set the site slogan to the taxonomy term description
  domain_conf_variable_set($domain['domain_id'], 'site_slogan', strip_tags($branch_term->description));

  // Set up a 'dev' alias for the new domain
  regnum_create_domain_alias($domain, array('dev'));

  // TODO: email address for domain?

  // set theme for domain. TODO: put default theme in a setting somewhere,
  // or do this in a hook
  regnum_domain_set_theme($domain, 'wk_bartik');

  $theme_data = domain_theme_lookup($domain['domain_id'], "wk_bartik");
  $theme_settings = unserialize($theme_data["settings"]);

  $theme_settings['toggle_slogan'] = 1;
  $theme_settings['toggle_name'] = 1;
  $theme_settings['toggle_logo'] = 0;
  $theme_settings['default_logo'] = 0;

  // If the branch term has arms, then set the logo path
  if (isset($branch_term->field_arms)) {
    if (isset($branch_term->field_arms[LANGUAGE_NONE][0]['uri'])) {
      $img_path = $branch_term->field_arms[LANGUAGE_NONE][0]['uri'];
      $img_thumbnail_path = image_style_path('thumbnail', $img_path);
      $theme_settings['logo_path'] = $img_thumbnail_path;
      $theme_settings['toggle_logo'] = 1;
      $theme_settings['page_style'] = 'borderless';
    }
  }

  db_update('domain_theme')
    ->fields(array('settings' => serialize($theme_settings)))
    ->condition('domain_id', $domain['domain_id'])
    ->execute();

  // Rebuild files for color module support
  _regnum_repair_domain_color_theme();
}

function _regnum_repair_domain_color_theme() {
  // The color module just won't be happy unless it gets
  // a form submit.  Thanks, https://drupal.org/node/1245148#comment-5067026
  require('modules/system/system.admin.inc');
  $theme = 'wk_bartik'; // name of the theme supporting the color module
  $scheme = 'default';
  // start building our "fake form"
  $fform = array();
  $fform_state = array();
  $fform_state['build_info']['args'][0] = $theme;
  $fform = system_theme_settings($fform, $fform_state, $theme);
  // add the color theme settings to the form
  color_form_system_theme_settings_alter($fform, $fform_state);
  // simulate selecting values for the form
  $fform_state['values']['theme'] = $theme;
  $fform_state['values']['info'] = color_get_info($theme);
  $fform_state['values']['palette'] = $fform_state['values']['info']['schemes'][$scheme]['colors'];
  $fform_state['values']['scheme'] = $scheme;
  // submitting the form
  color_scheme_form_submit($fform, $fform_state);
}

function regnum_create_aliases_for_all_domains($alias_prefixes, $redirect = 0) {
  foreach (domain_id_list() as $machine_name => $domain_id) {
    $domain = domain_lookup($domain_id);
    regnum_create_domain_alias($domain, $alias_prefixes, $redirect);
  }
}

// domain_alias does not include an API function to create aliases.
function regnum_create_domain_alias($domain, $alias_prefixes, $redirect = 0) {
  if (module_exists("domain_alias")) {
    $domain_id = $domain['domain_id'];
    $alias_list = domain_alias_list($domain_id);
    $existing_aliases = array();
    foreach ($alias_list as $alias_id => $info) {
      $existing_aliases[$info['pattern']] = $info;
    }
    foreach ($alias_prefixes as $alias_prefix) {
      $pattern = $alias_prefix . '.' . $domain['subdomain'];
      if (!array_key_exists($pattern, $existing_aliases)) {
        db_insert('domain_alias')
          ->fields(array(
              'domain_id' => $domain_id,
              'pattern' => $pattern,
              'redirect' => $redirect,
            ))
          ->execute();
      }
    }
  }
}

// domain_theme does not include an API function to set the domain theme.
function regnum_domain_set_theme($domain, $theme) {
  // Update or Insert?
  $domain_id = $domain['domain_id'];
  // Set all themes in this domain to null status.
  db_update('domain_theme')
    ->fields(array(
      'status' => 0,
    ))
    ->condition('domain_id', $domain_id)
    ->execute();
  // Now activate the selected theme.
  // This lookup returns -1 on failure.
  $check = domain_theme_lookup($domain_id, $theme);
  // Update.
  if ($check != -1) {
    db_update('domain_theme')
      ->fields(array(
        'status' => 1,
      ))
      ->condition('domain_id', $domain_id)
      ->condition('theme', $theme)
      ->execute();
  }
  // Insert.
  else {
    db_insert('domain_theme')
      ->fields(array(
        'domain_id' => $domain_id,
        'theme' => $theme,
        'settings' => '',
        'status' => 1,
        'filepath' => '',
      ))
      ->execute();
  }
  cache_clear_all();
}
//Added to include code based view. ~Karius
function regnum_views_api() {
  return array(
    'api' => 2.0,
  );
}
